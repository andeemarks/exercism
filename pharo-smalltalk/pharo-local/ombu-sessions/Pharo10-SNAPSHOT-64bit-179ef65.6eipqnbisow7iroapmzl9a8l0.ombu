OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-12-16T08:08:31.071351+11:00' ],		#prior : OmReference [ 'Pharo10-SNAPSHOT-64bit-179ef65.75bib9b4ccx602fas5tnnp3vs', '8370' ],		#self : OmReference [ '1' ]	},	#content : EpRedo {		#entryReferences : OrderedCollection [			OmReference [ '6eipqn9altuim872zb5636294', '1' ]		]	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ],		#time : DateAndTime [ '2023-12-16T08:08:31.080607+11:00' ],		#trigger : @3	},	#content : EpCategoryAddition {		#classCategoryName : #BaselineOfExercism,		#affectedPackageName : #BaselineOfExercism	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-12-16T08:08:40.975553+11:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpRedo {		#entryReferences : OrderedCollection [			OmReference [ '6eipqneu3jhh5hlqj8hj31o55', '1' ]		]	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ],		#time : DateAndTime [ '2023-12-16T08:08:41.000518+11:00' ],		#trigger : @3	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'BaselineOf subclass: #BaselineOfExercism\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpackage: \'BaselineOfExercism\'',				#superclassName : 'BaselineOf'			},			#name : #BaselineOfExercism,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'BaselineOfExercism class\r\tinstanceVariableNames: \'\''				},				#name : #'BaselineOfExercism class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #BaselineOfExercism,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #BaselineOfExercism,			#package : #BaselineOfExercism,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-12-16T08:08:47.021035+11:00' ],		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpRedo {		#entryReferences : OrderedCollection [			OmReference [ '6eipqn8kpropp83a3ze1ultc1', '1' ]		]	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ],		#time : DateAndTime [ '2023-12-16T08:08:47.03347+11:00' ],		#trigger : @3	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'BaselineOf subclass: #BaselineOfExercism\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpackage: \'BaselineOfExercism\'',				#superclassName : 'BaselineOf'			},			#name : #BaselineOfExercism,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'BaselineOfExercism class\r\tinstanceVariableNames: \'\''				},				#name : #'BaselineOfExercism class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #BaselineOfExercism,					#isMetaSide : false				},				#parent : @7,				#content : 'Project baseline to load entire Exercism Pharo track, including all its dependencies',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #BaselineOfExercism,			#package : #BaselineOfExercism,			#sharedPools : OrderedCollection [ ]		},		#oldComment : '',		#newComment : 'Project baseline to load entire Exercism Pharo track, including all its dependencies',		#oldStamp : '',		#newStamp : ''	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2023-12-16T08:08:59.799741+11:00' ],		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ]	},	#content : EpRedo {		#entryReferences : OrderedCollection [			OmReference [ '6eipqnbph5vn8vjeag5vs3yt6', '1' ]		]	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ],		#time : DateAndTime [ '2023-12-16T08:09:10.283572+11:00' ],		#trigger : @3	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'BaselineOfExercism class',				#isMetaSide : true			},			#name : #exerciseGoldenTestPackageNames,			#protocol : #baselines,			#sourceCode : 'exerciseGoldenTestPackageNames\r\t"Answer the list of exercise package names used for golden tests executed by Exercism\'s test runner"\r\r\t^ #(\'Exercise@ExampleAllFail\' \'Exercise@ExampleAllPass\' \'Exercise@ExampleAllRaiseError\' \'Exercise@ExampleEmptySolutionClass\' \'Exercise@ExampleEmptySolutionFile\' \'Exercise@ExampleErrorFailPass\' \'Exercise@ExampleExtensionMethod\' \'Exercise@ExampleSyntaxError\' \'Exercise@ExampleTypoInMethodName\')',			#stamp : 'AndyMarks 12/16/2023 08:09',			#package : #BaselineOfExercism		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:09:34.17482+11:00' ],		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ]	},	#content : EpRedo {		#entryReferences : OrderedCollection [			OmReference [ '6eipqng3ajwbklbpkt01nj7wh', '1' ]		]	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ],		#time : DateAndTime [ '2023-12-16T08:09:34.198193+11:00' ],		#trigger : @3	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'BaselineOfExercism class',				#isMetaSide : true			},			#name : #exercisePackageNames,			#protocol : #baselines,			#sourceCode : 'exercisePackageNames\r\t"Answer the list of exercise package names (as we don\'t yet have proper projects)"\r\r\t^ #(\'Exercise@Acronym\' \'Exercise@Allergies\' \'Exercise@Anagram\' \'Exercise@ArmstrongNumbers\' \'Exercise@AtbashCipher\' \'Exercise@Binary\' \'Exercise@BinarySearchTree\' \'Exercise@Bowling\' \'Exercise@CircularBuffer\' \'Exercise@Clock\' \'Exercise@CollatzConjecture\' \'Exercise@Darts\' \'Exercise@Diamond\' \'Exercise@Die\' \'Exercise@Etl\' \'Exercise@FlattenArray\' \'Exercise@Forth\' \'Exercise@GradeSchool\' \'Exercise@Grains\' \'Exercise@Hamming\' \'Exercise@HelloWorld\' \'Exercise@HighScores\' \'Exercise@IsbnVerifier\' \'Exercise@Isogram\' \'Exercise@Leap\' \'Exercise@Luhn\' \'Exercise@MatchingBrackets\' \'Exercise@Matrix\' \'Exercise@Minesweeper\' \'Exercise@Pangram\' \'Exercise@Proverb\' \'Exercise@Raindrops\' \'Exercise@ResistorColorDuo\' \'Exercise@ReverseString\' \'Exercise@RobotSimulator\' \'Exercise@RomanNumerals\' \'Exercise@SecretHandshake\' \'Exercise@Sieve\' \'Exercise@SimpleCipher\' \'Exercise@SpaceAge\' \'Exercise@SumOfMultiples\' \'Exercise@Tournament\' \'Exercise@TwelveDays\' \'Exercise@TwoFer\' \'Exercise@Welcome\' \'Exercise@WordCount\')',			#stamp : 'AndyMarks 12/16/2023 08:09',			#package : #BaselineOfExercism		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:09:42.196961+11:00' ],		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ]	},	#content : EpRedo {		#entryReferences : OrderedCollection [			OmReference [ '6eipqn971xncqgdcudvc3mzu7', '1' ]		]	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '11' ],		#self : OmReference [ '12' ],		#time : DateAndTime [ '2023-12-16T08:09:42.219827+11:00' ],		#trigger : @3	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'BaselineOfExercism class',				#isMetaSide : true			},			#name : #exerciseTestPackageNames,			#protocol : #baselines,			#sourceCode : 'exerciseTestPackageNames\r\t"Answer the list of exercise package names used for testing (as we don\'t yet have proper projects)"\r\r\t^ #(\'ExercismTests-ExerciseEmpty\' \'ExercismTests-ExerciseMany\' \'ExercismTests-ExerciseNormal\' \'ExercismTests-ExerciseExtension\')',			#stamp : 'AndyMarks 12/16/2023 08:09',			#package : #BaselineOfExercism		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:09:53.422343+11:00' ],		#prior : OmReference [ '12' ],		#self : OmReference [ '13' ]	},	#content : EpRedo {		#entryReferences : OrderedCollection [			OmReference [ '6eipqnc3fi30jp45v2n7g7v1w', '1' ]		]	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '13' ],		#self : OmReference [ '14' ],		#time : DateAndTime [ '2023-12-16T08:09:53.459348+11:00' ],		#trigger : @3	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #BaselineOfExercism,				#isMetaSide : false			},			#name : #'baseline:',			#protocol : #baselines,			#sourceCode : 'baseline: spec\r\t<baseline>\r\tspec\r\t\tfor: #common\r\t\tdo: [ self setExercismLogo.\r\t\t\tself setUpDependencies: spec.\r\t\t\tself setUpExercisesFor: spec.\r\t\t\tself setUpGoldenTestsFor: spec.\r\t\t\tspec\r\t\t\t\tpackage: \'ExercismTools\';\r\t\t\t\tpackage: \'ExercismMocking\' with: [ spec requires: #(\'Mocketry\') ];\r\t\t\t\tpackage: \'ExercismTests\'\r\t\t\t\t\twith: [ spec\r\t\t\t\t\t\trequires:\r\t\t\t\t\t\t\t#(\'ExercismTools\' \'ExercismMocking\')\r\t\t\t\t\t\t\t\t, self class exerciseTestPackageNames ];\r\t\t\t\tpackage: \'ExercismSystemTests\'\r\t\t\t\t\twith: [ spec requires: #(\'ExercismTests\') ];\r\t\t\t\tpackage: \'ExercismWIP\'\r\t\t\t\t\twith: [ spec requires: #(\'ExercismTools\') ];\r\t\t\t\tpackage: \'ExercismDev\'\r\t\t\t\t\twith: [ spec\r\t\t\t\t\t\trequires:\r\t\t\t\t\t\t\t#(\'ExercismTools\' \'OSSubprocess\' \'OSWinSubprocess\')\r\t\t\t\t\t\t\t\t, self class exercisePackageNames\t"For shelling out to configlet" ];\r\t\t\t\tpackage: \'ExercismTestRunner\'\r\t\t\t\t\twith:\r\t\t\t\t\t\t[ spec requires: #(\'ExercismTools\') , self class exercisePackageNames ];\r\t\t\t\tpackage: \'ExercismTestRunnerTests\'\r\t\t\t\t\twith: [ spec requires: #(\'ExercismTestRunner\' \'ExercismTests\') ];\r\t\t\t\tpackage: \'ExercismV3\';\r\t\t\t\tgroup: \'default\' with: #(\'ExercismTools\' \'Exercise@Welcome\');\r\t\t\t\tgroup: \'mentor\' with: #(\'ExercismDev\');\r\t\t\t\tgroup: \'dev\'\r\t\t\t\t\twith: #(\'ExercismDev\' \'ExercismWIP\' \'ExercismSystemTests\');\r\t\t\t\tgroup: \'testRunner\' with: #(\'ExercismTestRunner\');\r\t\t\t\tgroup: \'testRunnerTests\' with: #(\'ExercismTestRunnerTests\'), self class exerciseGoldenTestPackageNames;\r\t\t\t\tgroup: \'v3\' with: #(\'ExercismV3\')\r\t\t\t].\r\t\t\tspec for: #\'pharo9.x\' do: [ \r\t\t\t\tspec package: \'ExercismTools\' with: [ spec includes: #(\'ExercismPharo90\') ].\r\t\t\t\tspec package: \'ExercismPharo90\' ].\r\t\t\tspec for: #\'pharo11.x\' do: [\r\t\t\t\t"ExercismTools must be loaded prior compatibilty package, to overwrite original class definition of ExTonelWriter"\r\t\t\t\tspec package: \'ExercismTools\' with: [ spec includes: #(\'ExercismPharo110\') ].\r\t\t\t\tspec package: \'ExercismPharo110\' with: [ spec requires: \'ExercismTools\' ]\r\t\t\t]\r\t\t',			#stamp : 'AndyMarks 12/16/2023 08:09',			#package : #BaselineOfExercism		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:10:00.054647+11:00' ],		#prior : OmReference [ '14' ],		#self : OmReference [ '15' ]	},	#content : EpRedo {		#entryReferences : OrderedCollection [			OmReference [ '6eipqng7lccl02x1mwr9zhqeo', '1' ]		]	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '15' ],		#self : OmReference [ '16' ],		#time : DateAndTime [ '2023-12-16T08:10:00.076709+11:00' ],		#trigger : @3	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #BaselineOfExercism,				#isMetaSide : false			},			#name : #projectClass,			#protocol : #baselines,			#sourceCode : 'projectClass\r\t^ MetacelloCypressBaselineProject',			#stamp : 'AndyMarks 12/16/2023 08:10',			#package : #BaselineOfExercism		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:10:05.628105+11:00' ],		#prior : OmReference [ '16' ],		#self : OmReference [ '17' ]	},	#content : EpRedo {		#entryReferences : OrderedCollection [			OmReference [ '6eipqn8ofr3bpbuvql8ecvijr', '1' ]		]	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '17' ],		#self : OmReference [ '18' ],		#time : DateAndTime [ '2023-12-16T08:10:05.644613+11:00' ],		#trigger : @3	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #BaselineOfExercism,				#isMetaSide : false			},			#name : #setExercismLogo,			#protocol : #baselines,			#sourceCode : 'setExercismLogo\r\t| exercismLogo |\r\texercismLogo := (AlphaImageMorph\r\t\twithForm:\r\t\t(ZnEasy\r\t\tgetPng:\r\t\t\t\'https://user-images.githubusercontent.com/38899847/48952150-634e9b80-eefe-11e8-890e-7a233d56df65.png\'))\r\t\tlayout: #scaledAspect;\r\t\textent: 100 @ 100;\r\t\tposition: 10 @ 135;\r\t\tlock.\r\tWorld addMorph: exercismLogo',			#stamp : 'AndyMarks 12/16/2023 08:10',			#package : #BaselineOfExercism		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:10:11.228952+11:00' ],		#prior : OmReference [ '18' ],		#self : OmReference [ '19' ]	},	#content : EpRedo {		#entryReferences : OrderedCollection [			OmReference [ '6eipqnbym19svabk5fxp8t5cf', '1' ]		]	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '19' ],		#self : OmReference [ '20' ],		#time : DateAndTime [ '2023-12-16T08:10:11.259435+11:00' ],		#trigger : @3	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #BaselineOfExercism,				#isMetaSide : false			},			#name : #'setUpDependencies:',			#protocol : #baselines,			#sourceCode : 'setUpDependencies: spec\r\r\tspec \r\t\tbaseline: \'OSSubprocess\'\r \t\twith: [spec repository: \'github://pharo-contributions/OSSubprocess:master/repository\'].\r\t\r\tspec \r\t\tbaseline: \'OSWinSubprocess\'\r \t\twith: [spec repository: \'github://pharo-contributions/OSWinSubprocess:master/repository\'].\r\t\t\t\t\t\r\tspec\r    \tbaseline: \'Mocketry\'\r    \twith: [ spec repository: \'github://dionisiydk/Mocketry:v6.0.x\' ].\r\t\r\tspec\r    \tbaseline: \'Ring2\'\r    \twith: [ spec repository: \'github://pavel-krivanek/Ring2\'; loads: #(calypso)].',			#stamp : 'AndyMarks 12/16/2023 08:10',			#package : #BaselineOfExercism		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:10:15.929573+11:00' ],		#prior : OmReference [ '20' ],		#self : OmReference [ '21' ]	},	#content : EpRedo {		#entryReferences : OrderedCollection [			OmReference [ '6eipqndfi9gzu16j70k0lwkid', '1' ]		]	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '21' ],		#self : OmReference [ '22' ],		#time : DateAndTime [ '2023-12-16T08:10:15.954401+11:00' ],		#trigger : @3	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #BaselineOfExercism,				#isMetaSide : false			},			#name : #'setUpExercisesFor:',			#protocol : #baselines,			#sourceCode : 'setUpExercisesFor: spec\r\tself class exercisePackageNames, self class exerciseTestPackageNames \r\t\tdo:\r\t\t\t[ :name | spec package: name with: [ spec requires: #(\'ExercismTools\') ] ]',			#stamp : 'AndyMarks 12/16/2023 08:10',			#package : #BaselineOfExercism		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:10:20.756325+11:00' ],		#prior : OmReference [ '22' ],		#self : OmReference [ '23' ]	},	#content : EpRedo {		#entryReferences : OrderedCollection [			OmReference [ '6eipqnfpjo2mprltejgawrg3m', '1' ]		]	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '23' ],		#self : OmReference [ '24' ],		#time : DateAndTime [ '2023-12-16T08:10:20.763737+11:00' ],		#trigger : @3	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #BaselineOfExercism,				#isMetaSide : false			},			#name : #'setUpGoldenTestsFor:',			#protocol : #baselines,			#sourceCode : 'setUpGoldenTestsFor: spec\r\t\r\tself class exerciseGoldenTestPackageNames \r\t\tdo:\r\t\t\t[ :name | spec package: name with: [ spec requires: #(\'ExercismTools\') ] ]',			#stamp : 'AndyMarks 12/16/2023 08:10',			#package : #BaselineOfExercism		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:10:35.775151+11:00' ],		#prior : OmReference [ '24' ],		#self : OmReference [ '25' ]	},	#content : EpRedo {		#entryReferences : OrderedCollection [			OmReference [ '6eipqneavcckx1kvps2gquznl', '1' ]		]	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '25' ],		#self : OmReference [ '26' ],		#time : DateAndTime [ '2023-12-16T08:10:35.784905+11:00' ],		#trigger : @3	},	#content : EpCategoryAddition {		#classCategoryName : #ExercismTools-Core,		#affectedPackageName : #ExercismTools-Core	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:10:44.827455+11:00' ],		#prior : OmReference [ '26' ],		#self : OmReference [ '27' ]	},	#content : EpRedo {		#entryReferences : OrderedCollection [			OmReference [ '6eipqn9v1swxte4uqvrvp8snt', '1' ]		]	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '27' ],		#self : OmReference [ '28' ],		#time : DateAndTime [ '2023-12-16T08:10:44.87832+11:00' ],		#trigger : @3	},	#content : EpTraitAddition {		#trait : RGTraitDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Trait named: #TExercise\r\tinstanceVariableNames: \'\'\r\tpackage: \'ExercismTools-Core\'',				#superclassName : #Trait			},			#name : #TExercise,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#metaClass : RGMetatraitDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'TExercise classTrait\r\tinstanceVariableNames: \'\''				},				#name : #'TExercise classTrait',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #TExercise,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#category : #ExercismTools-Core,			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:10:49.551569+11:00' ],		#prior : OmReference [ '28' ],		#self : OmReference [ '29' ]	},	#content : EpRedo {		#entryReferences : OrderedCollection [			OmReference [ '6eipqnfqc89j9pwwsgvpbyi9y', '1' ]		]	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '29' ],		#self : OmReference [ '30' ],		#time : DateAndTime [ '2023-12-16T08:10:49.557372+11:00' ],		#trigger : @3	},	#content : EpBehaviorCommentChange {		#behavior : RGTraitDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Trait named: #TExercise\r\tinstanceVariableNames: \'\'\r\tpackage: \'ExercismTools-Core\'',				#superclassName : #Trait			},			#name : #TExercise,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#metaClass : RGMetatraitDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'TExercise classTrait\r\tinstanceVariableNames: \'\''				},				#name : #'TExercise classTrait',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #TExercise,					#isMetaSide : false				},				#parent : @7,				#content : '# TExercise\r\rI am a trait containing methods for getting exercise meta data from\robjects that play the role of a Exercism version 3 exercise.\r\r## Usage\r\rMy methods reference instance variables and methods that must be \rimplemented by objects that use me. \r\r## Instance Variables \r\rThese will need to be initialized in the using classes `#initialize` \rmethod.\r\r- solutionId \r- customData: An `Array`. This can be safely initialized empty.\r- isActive: A `Boolean`. Is the exercise active (not depricated or for testing).\r- isCustom: A `Boolean`. `true` if `customData` is not empty.\r- uuid: A `String`. The exercises unique ID in the Execism project.\r- version\r- aliasesAndHints: An `Array`. This can be safely initialized empty.\r\r## Methods\r\r### `#configuredExerciseMetadata`\r\rMust answer the configured exercise meta data for this exercise, an `ExercismExercise`.',				#stamp : ''			},			#category : #ExercismTools-Core,			#package : #ExercismTools-Core		},		#oldComment : '',		#newComment : '# TExercise\r\rI am a trait containing methods for getting exercise meta data from\robjects that play the role of a Exercism version 3 exercise.\r\r## Usage\r\rMy methods reference instance variables and methods that must be \rimplemented by objects that use me. \r\r## Instance Variables \r\rThese will need to be initialized in the using classes `#initialize` \rmethod.\r\r- solutionId \r- customData: An `Array`. This can be safely initialized empty.\r- isActive: A `Boolean`. Is the exercise active (not depricated or for testing).\r- isCustom: A `Boolean`. `true` if `customData` is not empty.\r- uuid: A `String`. The exercises unique ID in the Execism project.\r- version\r- aliasesAndHints: An `Array`. This can be safely initialized empty.\r\r## Methods\r\r### `#configuredExerciseMetadata`\r\rMust answer the configured exercise meta data for this exercise, an `ExercismExercise`.',		#oldStamp : '',		#newStamp : ''	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:10:54.095753+11:00' ],		#prior : OmReference [ '30' ],		#self : OmReference [ '31' ]	},	#content : EpRedo {		#entryReferences : OrderedCollection [			OmReference [ '6eipqndkiq67zno4u9duy0iz2', '1' ]		]	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '31' ],		#self : OmReference [ '32' ],		#time : DateAndTime [ '2023-12-16T08:10:54.118609+11:00' ],		#trigger : @3	},	#content : EpTraitModification {		#oldTrait : RGMetatraitDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'TExercise classTrait\r\tinstanceVariableNames: \'\''			},			#name : #'TExercise classTrait',			#methods : IdentityDictionary { },			#protocols : Set [ ],			#baseClass : RGTraitDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Trait named: #TExercise\r\tinstanceVariableNames: \'\'\r\tpackage: \'ExercismTools-Core\'',					#superclassName : #Trait				},				#name : #TExercise,				#methods : IdentityDictionary { },				#protocols : Set [ ],				#metaClass : @7,				#comment : RGCommentDefinition {					#annotations : IdentityDictionary {						#className : #TExercise,						#isMetaSide : false					},					#parent : @11,					#content : '# TExercise\r\rI am a trait containing methods for getting exercise meta data from\robjects that play the role of a Exercism version 3 exercise.\r\r## Usage\r\rMy methods reference instance variables and methods that must be \rimplemented by objects that use me. \r\r## Instance Variables \r\rThese will need to be initialized in the using classes `#initialize` \rmethod.\r\r- solutionId \r- customData: An `Array`. This can be safely initialized empty.\r- isActive: A `Boolean`. Is the exercise active (not depricated or for testing).\r- isCustom: A `Boolean`. `true` if `customData` is not empty.\r- uuid: A `String`. The exercises unique ID in the Execism project.\r- version\r- aliasesAndHints: An `Array`. This can be safely initialized empty.\r\r## Methods\r\r### `#configuredExerciseMetadata`\r\rMust answer the configured exercise meta data for this exercise, an `ExercismExercise`.',					#stamp : ''				},				#category : #ExercismTools-Core,				#package : #ExercismTools-Core			}		},		#newTrait : RGMetatraitDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'TExercise classTrait\r\tinstanceVariableNames: \'solutionId customData isActive uuid version aliasesAndHints\''			},			#name : #'TExercise classTrait',			#methods : IdentityDictionary { },			#protocols : Set [ ],			#baseClass : RGTraitDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Trait named: #TExercise\r\tinstanceVariableNames: \'\'\r\tpackage: \'ExercismTools-Core\'',					#superclassName : #Trait				},				#name : #TExercise,				#methods : IdentityDictionary { },				#protocols : Set [ ],				#metaClass : @17,				#comment : RGCommentDefinition {					#annotations : IdentityDictionary {						#className : #TExercise,						#isMetaSide : false					},					#parent : @21,					#content : '# TExercise\r\rI am a trait containing methods for getting exercise meta data from\robjects that play the role of a Exercism version 3 exercise.\r\r## Usage\r\rMy methods reference instance variables and methods that must be \rimplemented by objects that use me. \r\r## Instance Variables \r\rThese will need to be initialized in the using classes `#initialize` \rmethod.\r\r- solutionId \r- customData: An `Array`. This can be safely initialized empty.\r- isActive: A `Boolean`. Is the exercise active (not depricated or for testing).\r- isCustom: A `Boolean`. `true` if `customData` is not empty.\r- uuid: A `String`. The exercises unique ID in the Execism project.\r- version\r- aliasesAndHints: An `Array`. This can be safely initialized empty.\r\r## Methods\r\r### `#configuredExerciseMetadata`\r\rMust answer the configured exercise meta data for this exercise, an `ExercismExercise`.',					#stamp : ''				},				#category : #ExercismTools-Core,				#package : #ExercismTools-Core			}		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:10:58.909321+11:00' ],		#prior : OmReference [ '32' ],		#self : OmReference [ '33' ]	},	#content : EpRedo {		#entryReferences : OrderedCollection [			OmReference [ '6eipqn9ylpgen36q0fzk7irsy', '1' ]		]	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '33' ],		#self : OmReference [ '34' ],		#time : DateAndTime [ '2023-12-16T08:10:58.935157+11:00' ],		#trigger : @3	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'TestCase subclass: #ExercismTest\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpackage: \'ExercismTools-Core\'',				#superclassName : 'TestCase'			},			#name : #ExercismTest,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ExercismTest class\r\tinstanceVariableNames: \'\''				},				#name : #'ExercismTest class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ExercismTest,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #ExercismTools-Core,			#package : #ExercismTools-Core,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '34' ],		#self : OmReference [ '35' ],		#time : DateAndTime [ '2023-12-16T08:10:58.94529+11:00' ],		#trigger : OmReference [ '33' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'TestCase subclass: #ExercismTest\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpackage: \'ExercismTools-Core\'',				#superclassName : 'TestCase'			},			#name : #ExercismTest,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ExercismTest class\r\tinstanceVariableNames: \'\''				},				#name : #'ExercismTest class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ExercismTest,					#isMetaSide : false				},				#parent : @8,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #ExercismTools-Core,			#package : #ExercismTools-Core,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'TestCase subclass: #ExercismTest\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpackage: \'ExercismTools-Core\'',				#superclassName : 'TestCase'			},			#name : #ExercismTest,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ExercismTest class\r\tinstanceVariableNames: \'solutionId\''				},				#name : #'ExercismTest class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#isMetaSide : true,							#className : #'ExercismTest class'						},						#name : #solutionId,						#parent : @27					}				],				#baseClass : @22			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ExercismTest,					#isMetaSide : false				},				#parent : @22,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #ExercismTools-Core,			#package : #ExercismTools-Core,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:11:04.081891+11:00' ],		#prior : OmReference [ '35' ],		#self : OmReference [ '36' ]	},	#content : EpRedo {		#entryReferences : OrderedCollection [			OmReference [ '6eipqnajolqq17qhaj30u2amn', '1' ]		]	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '36' ],		#self : OmReference [ '37' ],		#time : DateAndTime [ '2023-12-16T08:11:04.096224+11:00' ],		#trigger : @3	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'TestCase subclass: #ExercismTest\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpackage: \'ExercismTools-Core\'',				#superclassName : 'TestCase'			},			#name : #ExercismTest,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ExercismTest class\r\tinstanceVariableNames: \'solutionId\''				},				#name : #'ExercismTest class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#isMetaSide : true,							#className : #'ExercismTest class'						},						#name : #solutionId,						#parent : @12					}				],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ExercismTest,					#isMetaSide : false				},				#parent : @7,				#content : 'I am the root of Exercism test examples but also provide a hook to specify some simple exercise metadata that can be used to generate the exercism config.json file (used by the platform to unlock exercises for users as they progress).',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #ExercismTools-Core,			#package : #ExercismTools-Core,			#sharedPools : OrderedCollection [ ]		},		#oldComment : '',		#newComment : 'I am the root of Exercism test examples but also provide a hook to specify some simple exercise metadata that can be used to generate the exercism config.json file (used by the platform to unlock exercises for users as they progress).',		#oldStamp : '',		#newStamp : ''	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:11:09.580252+11:00' ],		#prior : OmReference [ '37' ],		#self : OmReference [ '38' ]	},	#content : EpRedo {		#entryReferences : OrderedCollection [			OmReference [ '6eipqn96dhsd5283d00jvwurm', '1' ]		]	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '38' ],		#self : OmReference [ '39' ],		#time : DateAndTime [ '2023-12-16T08:11:09.587427+11:00' ],		#trigger : @3	},	#content : EpCategoryAddition {		#classCategoryName : #ExercismTools,		#affectedPackageName : #ExercismTools	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:11:14.27931+11:00' ],		#prior : OmReference [ '39' ],		#self : OmReference [ '40' ]	},	#content : EpRedo {		#entryReferences : OrderedCollection [			OmReference [ '6eipqneh9ms10sd6n71trvt19', '1' ]		]	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '40' ],		#self : OmReference [ '41' ],		#time : DateAndTime [ '2023-12-16T08:11:14.306579+11:00' ],		#trigger : @3	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'ReAbstractRule subclass: #ExercismHintRule\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpackage: \'ExercismTools\'',				#superclassName : 'ReAbstractRule'			},			#name : #ExercismHintRule,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ExercismHintRule class\r\tinstanceVariableNames: \'\''				},				#name : #'ExercismHintRule class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ExercismHintRule,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #ExercismTools,			#package : #ExercismTools,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:11:35.672037+11:00' ],		#prior : OmReference [ '41' ],		#self : OmReference [ '42' ]	},	#content : EpRedo {		#entryReferences : OrderedCollection [			OmReference [ '6eipqn9bz2gyvlrzk4t58rrss', '1' ]		]	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '42' ],		#self : OmReference [ '43' ],		#time : DateAndTime [ '2023-12-16T08:11:35.700347+11:00' ],		#trigger : @3	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'ExercismHintRule subclass: #ExercismHintTwoFerReuseRule\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpackage: \'ExercismTools\'',				#superclassName : 'ExercismHintRule'			},			#name : #ExercismHintTwoFerReuseRule,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ExercismHintTwoFerReuseRule class\r\tinstanceVariableNames: \'\''				},				#name : #'ExercismHintTwoFerReuseRule class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ExercismHintTwoFerReuseRule,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #ExercismTools,			#package : #ExercismTools,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:11:40.212046+11:00' ],		#prior : OmReference [ '43' ],		#self : OmReference [ '44' ]	},	#content : EpRedo {		#entryReferences : OrderedCollection [			OmReference [ '6eipqneiaumll8aov62o1gaex', '1' ]		]	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '44' ],		#self : OmReference [ '45' ],		#time : DateAndTime [ '2023-12-16T08:11:40.225103+11:00' ],		#trigger : @3	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'ExercismHintRule subclass: #ExercismHintTwoFerReuseRule\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpackage: \'ExercismTools\'',				#superclassName : 'ExercismHintRule'			},			#name : #ExercismHintTwoFerReuseRule,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ExercismHintTwoFerReuseRule class\r\tinstanceVariableNames: \'\''				},				#name : #'ExercismHintTwoFerReuseRule class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ExercismHintTwoFerReuseRule,					#isMetaSide : false				},				#parent : @7,				#content : 'The TwoFer exercise introduces you to calling between methods.\rFor practice, your \'#who\'  method should reuse your  \'#who:\'  method. ',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #ExercismTools,			#package : #ExercismTools,			#sharedPools : OrderedCollection [ ]		},		#oldComment : '',		#newComment : 'The TwoFer exercise introduces you to calling between methods.\rFor practice, your \'#who\'  method should reuse your  \'#who:\'  method. ',		#oldStamp : '',		#newStamp : ''	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:11:46.843703+11:00' ],		#prior : OmReference [ '45' ],		#self : OmReference [ '46' ]	},	#content : EpRedo {		#entryReferences : OrderedCollection [			OmReference [ '6eipqnckvs60cn8cbiohagt82', '1' ]		]	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '46' ],		#self : OmReference [ '47' ],		#time : DateAndTime [ '2023-12-16T08:11:46.853139+11:00' ],		#trigger : @3	},	#content : EpCategoryAddition {		#classCategoryName : #ExercismTools-Menus,		#affectedPackageName : #ExercismTools	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:12:43.855799+11:00' ],		#prior : OmReference [ '47' ],		#self : OmReference [ '48' ]	},	#content : EpRedo {		#entryReferences : OrderedCollection [			OmReference [ '6eipqnb1ie68qipe1pgpt8ubw', '1' ]		]	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:12:56.515825+11:00' ],		#prior : OmReference [ '48' ],		#self : OmReference [ '49' ]	},	#content : EpRedo {		#entryReferences : OrderedCollection [			OmReference [ '6eipqn919uujiovversjal1az', '1' ]		]	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:17:04.456893+11:00' ],		#prior : OmReference [ '49' ],		#self : OmReference [ '50' ]	},	#content : EpRedo {		#entryReferences : OrderedCollection [			OmReference [ '6eipqndgda85t9q1l230vtcm4', '1' ]		]	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '50' ],		#self : OmReference [ '51' ],		#time : DateAndTime [ '2023-12-16T08:17:04.483861+11:00' ],		#trigger : @3	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Error subclass: #ExercismError\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpackage: \'ExercismTools-Core\'',				#superclassName : 'Error'			},			#name : #ExercismError,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ExercismError class\r\tinstanceVariableNames: \'\''				},				#name : #'ExercismError class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ExercismError,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #ExercismTools-Core,			#package : #ExercismTools-Core,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:17:09.24072+11:00' ],		#prior : OmReference [ '51' ],		#self : OmReference [ '52' ]	},	#content : EpRedo {		#entryReferences : OrderedCollection [			OmReference [ '6eipqn9tvr9t34owiw7zl15jd', '1' ]		]	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '52' ],		#self : OmReference [ '53' ],		#time : DateAndTime [ '2023-12-16T08:17:09.255098+11:00' ],		#trigger : @3	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Error subclass: #ExercismError\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpackage: \'ExercismTools-Core\'',				#superclassName : 'Error'			},			#name : #ExercismError,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ExercismError class\r\tinstanceVariableNames: \'\''				},				#name : #'ExercismError class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ExercismError,					#isMetaSide : false				},				#parent : @7,				#content : 'I am a hierarchy of Exercism errors, so its east to catch them',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #ExercismTools-Core,			#package : #ExercismTools-Core,			#sharedPools : OrderedCollection [ ]		},		#oldComment : '',		#newComment : 'I am a hierarchy of Exercism errors, so its east to catch them',		#oldStamp : '',		#newStamp : ''	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:17:14.301682+11:00' ],		#prior : OmReference [ '53' ],		#self : OmReference [ '54' ]	},	#content : EpRedo {		#entryReferences : OrderedCollection [			OmReference [ '6eipqng5x89hp7egn9819vdi6', '1' ]		]	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '54' ],		#self : OmReference [ '55' ],		#time : DateAndTime [ '2023-12-16T08:17:14.328604+11:00' ],		#trigger : @3	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'ExercismError subclass: #ExDomainError\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpackage: \'ExercismTools-Core\'',				#superclassName : 'ExercismError'			},			#name : #ExDomainError,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ExDomainError class\r\tinstanceVariableNames: \'\''				},				#name : #'ExDomainError class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ExDomainError,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #ExercismTools-Core,			#package : #ExercismTools-Core,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:17:18.68446+11:00' ],		#prior : OmReference [ '55' ],		#self : OmReference [ '56' ]	},	#content : EpRedo {		#entryReferences : OrderedCollection [			OmReference [ '6eipqncwwpzhepfoa8baaxn4e', '1' ]		]	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '56' ],		#self : OmReference [ '57' ],		#time : DateAndTime [ '2023-12-16T08:17:18.70971+11:00' ],		#trigger : @3	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'ExercismError subclass: #ExSolutionIdError\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpackage: \'ExercismTools-Core\'',				#superclassName : 'ExercismError'			},			#name : #ExSolutionIdError,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ExSolutionIdError class\r\tinstanceVariableNames: \'\''				},				#name : #'ExSolutionIdError class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ExSolutionIdError,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #ExercismTools-Core,			#package : #ExercismTools-Core,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:17:23.211261+11:00' ],		#prior : OmReference [ '57' ],		#self : OmReference [ '58' ]	},	#content : EpRedo {		#entryReferences : OrderedCollection [			OmReference [ '6eipqne23fb62hx448pjgsxfi', '1' ]		]	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '58' ],		#self : OmReference [ '59' ],		#time : DateAndTime [ '2023-12-16T08:17:23.237896+11:00' ],		#trigger : @3	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'ExercismError subclass: #ExUnauthorized\r\tinstanceVariableNames: \'token\'\r\tclassVariableNames: \'\'\r\tpackage: \'ExercismTools-Core\'',				#superclassName : 'ExercismError'			},			#name : #ExUnauthorized,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ExUnauthorized,						#isMetaSide : false					},					#name : #token,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ExUnauthorized class\r\tinstanceVariableNames: \'\''				},				#name : #'ExUnauthorized class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ExUnauthorized,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #ExercismTools-Core,			#package : #ExercismTools-Core,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:17:27.578792+11:00' ],		#prior : OmReference [ '59' ],		#self : OmReference [ '60' ]	},	#content : EpRedo {		#entryReferences : OrderedCollection [			OmReference [ '6eipqnc3ia3gjefcoj7ep5s5r', '1' ]		]	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '60' ],		#self : OmReference [ '61' ],		#time : DateAndTime [ '2023-12-16T08:17:27.593097+11:00' ],		#trigger : @3	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'ExercismError subclass: #ExUnauthorized\r\tinstanceVariableNames: \'token\'\r\tclassVariableNames: \'\'\r\tpackage: \'ExercismTools-Core\'',				#superclassName : 'ExercismError'			},			#name : #ExUnauthorized,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ExUnauthorized,						#isMetaSide : false					},					#name : #token,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ExUnauthorized class\r\tinstanceVariableNames: \'\''				},				#name : #'ExUnauthorized class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ExUnauthorized,					#isMetaSide : false				},				#parent : @7,				#content : 'I am an authorisation error for Exercism',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #ExercismTools-Core,			#package : #ExercismTools-Core,			#sharedPools : OrderedCollection [ ]		},		#oldComment : '',		#newComment : 'I am an authorisation error for Exercism',		#oldStamp : '',		#newStamp : ''	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:17:32.537072+11:00' ],		#prior : OmReference [ '61' ],		#self : OmReference [ '62' ]	},	#content : EpRedo {		#entryReferences : OrderedCollection [			OmReference [ '6eipqnccqhkx0hk2of7e6b5tk', '1' ]		]	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '62' ],		#self : OmReference [ '63' ],		#time : DateAndTime [ '2023-12-16T08:17:32.563998+11:00' ],		#trigger : @3	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'TonelWriter subclass: #ExTonelWriter\r\tinstanceVariableNames: \'sourceDirectory\'\r\tclassVariableNames: \'\'\r\tpackage: \'ExercismTools-Core\'',				#superclassName : 'TonelWriter'			},			#name : #ExTonelWriter,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ExTonelWriter,						#isMetaSide : false					},					#name : #sourceDirectory,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ExTonelWriter class\r\tinstanceVariableNames: \'\''				},				#name : #'ExTonelWriter class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ExTonelWriter,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #ExercismTools-Core,			#package : #ExercismTools-Core,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:17:38.52547+11:00' ],		#prior : OmReference [ '63' ],		#self : OmReference [ '64' ]	},	#content : EpRedo {		#entryReferences : OrderedCollection [			OmReference [ '6eipqn8xnunacavyr5fstya8w', '1' ]		]	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '64' ],		#self : OmReference [ '65' ],		#time : DateAndTime [ '2023-12-16T08:17:38.531028+11:00' ],		#trigger : @3	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'TonelWriter subclass: #ExTonelWriter\r\tinstanceVariableNames: \'sourceDirectory\'\r\tclassVariableNames: \'\'\r\tpackage: \'ExercismTools-Core\'',				#superclassName : 'TonelWriter'			},			#name : #ExTonelWriter,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ExTonelWriter,						#isMetaSide : false					},					#name : #sourceDirectory,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ExTonelWriter class\r\tinstanceVariableNames: \'\''				},				#name : #'ExTonelWriter class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ExTonelWriter,					#isMetaSide : false				},				#parent : @7,				#content : 'I am a TonelWriter that provides finer level control of writing Tonel files for Exercism',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #ExercismTools-Core,			#package : #ExercismTools-Core,			#sharedPools : OrderedCollection [ ]		},		#oldComment : '',		#newComment : 'I am a TonelWriter that provides finer level control of writing Tonel files for Exercism',		#oldStamp : '',		#newStamp : ''	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:17:49.051723+11:00' ],		#prior : OmReference [ '65' ],		#self : OmReference [ '66' ]	},	#content : EpRedo {		#entryReferences : OrderedCollection [			OmReference [ '6eipqn9hqaifaawneedibthdc', '1' ]		]	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '66' ],		#self : OmReference [ '67' ],		#time : DateAndTime [ '2023-12-16T08:17:49.067178+11:00' ],		#trigger : @3	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'TextMorph subclass: #StaticTextMorph\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpackage: \'ExercismTools-Core\'',				#superclassName : 'TextMorph'			},			#name : #StaticTextMorph,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'StaticTextMorph class\r\tinstanceVariableNames: \'\''				},				#name : #'StaticTextMorph class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #StaticTextMorph,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #ExercismTools-Core,			#package : #ExercismTools-Core,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:17:53.47422+11:00' ],		#prior : OmReference [ '67' ],		#self : OmReference [ '68' ]	},	#content : EpRedo {		#entryReferences : OrderedCollection [			OmReference [ '6eipqnet66eb5ri2lyqwgwv0p', '1' ]		]	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '68' ],		#self : OmReference [ '69' ],		#time : DateAndTime [ '2023-12-16T08:17:53.486968+11:00' ],		#trigger : @3	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'TextMorph subclass: #StaticTextMorph\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpackage: \'ExercismTools-Core\'',				#superclassName : 'TextMorph'			},			#name : #StaticTextMorph,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'StaticTextMorph class\r\tinstanceVariableNames: \'\''				},				#name : #'StaticTextMorph class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #StaticTextMorph,					#isMetaSide : false				},				#parent : @7,				#content : 'Provide a non editable text morph suitable for hosting a clickable URL',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #ExercismTools-Core,			#package : #ExercismTools-Core,			#sharedPools : OrderedCollection [ ]		},		#oldComment : '',		#newComment : 'Provide a non editable text morph suitable for hosting a clickable URL',		#oldStamp : '',		#newStamp : ''	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:18:01.821371+11:00' ],		#prior : OmReference [ '69' ],		#self : OmReference [ '70' ]	},	#content : EpRedo {		#entryReferences : OrderedCollection [			OmReference [ '6eipqnc5cd2ntbwietphhuxge', '1' ]		]	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '70' ],		#self : OmReference [ '71' ],		#time : DateAndTime [ '2023-12-16T08:18:01.824995+11:00' ],		#trigger : @3	},	#content : EpCategoryAddition {		#classCategoryName : #ExercismTools-Meta,		#affectedPackageName : #ExercismTools	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:18:08.485856+11:00' ],		#prior : OmReference [ '71' ],		#self : OmReference [ '72' ]	},	#content : EpRedo {		#entryReferences : OrderedCollection [			OmReference [ '6eipqnaa70mhxhsio64ekg8nz', '1' ]		]	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '72' ],		#self : OmReference [ '73' ],		#time : DateAndTime [ '2023-12-16T08:18:08.51342+11:00' ],		#trigger : @3	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #ExercismExercise\r\tinstanceVariableNames: \'testCase difficulty topics isAutoApproved isCore unlockedBy isDeprecated\'\r\tclassVariableNames: \'\'\r\tpackage: \'ExercismTools-Meta\'',				#superclassName : 'Object'			},			#name : #ExercismExercise,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ExercismExercise,						#isMetaSide : false					},					#name : #testCase,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ExercismExercise,						#isMetaSide : false					},					#name : #difficulty,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ExercismExercise,						#isMetaSide : false					},					#name : #topics,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ExercismExercise,						#isMetaSide : false					},					#name : #isAutoApproved,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ExercismExercise,						#isMetaSide : false					},					#name : #isCore,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ExercismExercise,						#isMetaSide : false					},					#name : #unlockedBy,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ExercismExercise,						#isMetaSide : false					},					#name : #isDeprecated,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ExercismExercise class\r\tinstanceVariableNames: \'\''				},				#name : #'ExercismExercise class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ExercismExercise,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #ExercismTools-Meta,			#package : #ExercismTools,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:18:12.589075+11:00' ],		#prior : OmReference [ '73' ],		#self : OmReference [ '74' ]	},	#content : EpRedo {		#entryReferences : OrderedCollection [			OmReference [ '6eipqnfhdbxn3bpe8fjnbzyu2', '1' ]		]	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '74' ],		#self : OmReference [ '75' ],		#time : DateAndTime [ '2023-12-16T08:18:12.606037+11:00' ],		#trigger : @3	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #ExercismExercise\r\tinstanceVariableNames: \'testCase difficulty topics isAutoApproved isCore unlockedBy isDeprecated\'\r\tclassVariableNames: \'\'\r\tpackage: \'ExercismTools-Meta\'',				#superclassName : 'Object'			},			#name : #ExercismExercise,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ExercismExercise,						#isMetaSide : false					},					#name : #testCase,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ExercismExercise,						#isMetaSide : false					},					#name : #difficulty,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ExercismExercise,						#isMetaSide : false					},					#name : #topics,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ExercismExercise,						#isMetaSide : false					},					#name : #isAutoApproved,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ExercismExercise,						#isMetaSide : false					},					#name : #isCore,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ExercismExercise,						#isMetaSide : false					},					#name : #unlockedBy,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ExercismExercise,						#isMetaSide : false					},					#name : #isDeprecated,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ExercismExercise class\r\tinstanceVariableNames: \'\''				},				#name : #'ExercismExercise class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ExercismExercise,					#isMetaSide : false				},				#parent : @7,				#content : 'I am the meta data for an exercise, and am typically created from the #excerise method on any of the specified ExercismTest tests (which are a type of SUnit test).\r\rOf note is that the exercise submission id is stored as a class instance variable on ExercismTest.',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #ExercismTools-Meta,			#package : #ExercismTools,			#sharedPools : OrderedCollection [ ]		},		#oldComment : '',		#newComment : 'I am the meta data for an exercise, and am typically created from the #excerise method on any of the specified ExercismTest tests (which are a type of SUnit test).\r\rOf note is that the exercise submission id is stored as a class instance variable on ExercismTest.',		#oldStamp : '',		#newStamp : ''	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:18:16.382323+11:00' ],		#prior : OmReference [ '75' ],		#self : OmReference [ '76' ]	},	#content : EpRedo {		#entryReferences : OrderedCollection [			OmReference [ '6eipqncrzx61m3ljpv41wjssl', '1' ]		]	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '76' ],		#self : OmReference [ '77' ],		#time : DateAndTime [ '2023-12-16T08:18:16.409173+11:00' ],		#trigger : @3	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'ExercismExercise subclass: #MockExercismExercise\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpackage: \'ExercismTools-Meta\'',				#superclassName : 'ExercismExercise'			},			#name : #MockExercismExercise,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'MockExercismExercise class\r\tinstanceVariableNames: \'\''				},				#name : #'MockExercismExercise class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #MockExercismExercise,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #ExercismTools-Meta,			#package : #ExercismTools,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:18:20.38772+11:00' ],		#prior : OmReference [ '77' ],		#self : OmReference [ '78' ]	},	#content : EpRedo {		#entryReferences : OrderedCollection [			OmReference [ '6eipqng330izdrqlavcxo3pbj', '1' ]		]	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '78' ],		#self : OmReference [ '79' ],		#time : DateAndTime [ '2023-12-16T08:18:20.390969+11:00' ],		#trigger : @3	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'ExercismExercise subclass: #MockExercismExercise\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpackage: \'ExercismTools-Meta\'',				#superclassName : 'ExercismExercise'			},			#name : #MockExercismExercise,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'MockExercismExercise class\r\tinstanceVariableNames: \'\''				},				#name : #'MockExercismExercise class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #MockExercismExercise,					#isMetaSide : false				},				#parent : @7,				#content : '# MockExercismExercise\r\rI am a subclass of `ExercismExercise` exclusively for use in testing. I override `#allExercises`\rto return a small number of exercises instead of all the exercises in production,\rwhich can grow in number. This is to help keep tests fast and predictable.\r\r## Overridden Methods\r\r### `#allExercises`\r\rAnswers a small constant number of exercises.',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #ExercismTools-Meta,			#package : #ExercismTools,			#sharedPools : OrderedCollection [ ]		},		#oldComment : '',		#newComment : '# MockExercismExercise\r\rI am a subclass of `ExercismExercise` exclusively for use in testing. I override `#allExercises`\rto return a small number of exercises instead of all the exercises in production,\rwhich can grow in number. This is to help keep tests fast and predictable.\r\r## Overridden Methods\r\r### `#allExercises`\r\rAnswers a small constant number of exercises.',		#oldStamp : '',		#newStamp : ''	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:18:25.797358+11:00' ],		#prior : OmReference [ '79' ],		#self : OmReference [ '80' ]	},	#content : EpRedo {		#entryReferences : OrderedCollection [			OmReference [ '6eipqn97jgkg87wcmngojmhhi', '1' ]		]	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '80' ],		#self : OmReference [ '81' ],		#time : DateAndTime [ '2023-12-16T08:18:25.825505+11:00' ],		#trigger : @3	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #ExercismHttpClient\r\tinstanceVariableNames: \'hostName zincClient\'\r\tclassVariableNames: \'ApiToken\'\r\tpackage: \'ExercismTools-Core\'',				#superclassName : 'Object'			},			#name : #ExercismHttpClient,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ExercismHttpClient,						#isMetaSide : false					},					#name : #hostName,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ExercismHttpClient,						#isMetaSide : false					},					#name : #zincClient,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ExercismHttpClient class\r\tinstanceVariableNames: \'\''				},				#name : #'ExercismHttpClient class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ExercismHttpClient,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #ExercismHttpClient,						#isMetaSide : false					},					#name : #ApiToken,					#parent : @7				}			],			#category : #ExercismTools-Core,			#package : #ExercismTools-Core,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:18:29.849173+11:00' ],		#prior : OmReference [ '81' ],		#self : OmReference [ '82' ]	},	#content : EpRedo {		#entryReferences : OrderedCollection [			OmReference [ '6eipqnejafncpoo6agpix7skm', '1' ]		]	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '82' ],		#self : OmReference [ '83' ],		#time : DateAndTime [ '2023-12-16T08:18:29.86582+11:00' ],		#trigger : @3	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #ExercismHttpClient\r\tinstanceVariableNames: \'hostName zincClient\'\r\tclassVariableNames: \'ApiToken\'\r\tpackage: \'ExercismTools-Core\'',				#superclassName : 'Object'			},			#name : #ExercismHttpClient,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ExercismHttpClient,						#isMetaSide : false					},					#name : #hostName,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ExercismHttpClient,						#isMetaSide : false					},					#name : #zincClient,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ExercismHttpClient class\r\tinstanceVariableNames: \'\''				},				#name : #'ExercismHttpClient class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ExercismHttpClient,					#isMetaSide : false				},				#parent : @7,				#content : 'I am a wrapper over a ZnClient to streamline the HTTP interactions with exercism, and to also make it re-testable.\r',				#stamp : ''			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #ExercismHttpClient,						#isMetaSide : false					},					#name : #ApiToken,					#parent : @7				}			],			#category : #ExercismTools-Core,			#package : #ExercismTools-Core,			#sharedPools : OrderedCollection [ ]		},		#oldComment : '',		#newComment : 'I am a wrapper over a ZnClient to streamline the HTTP interactions with exercism, and to also make it re-testable.\r',		#oldStamp : '',		#newStamp : ''	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:18:33.411972+11:00' ],		#prior : OmReference [ '83' ],		#self : OmReference [ '84' ]	},	#content : EpRedo {		#entryReferences : OrderedCollection [			OmReference [ '6eipqnev791u2pen2h15ypy9f', '1' ]		]	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '84' ],		#self : OmReference [ '85' ],		#time : DateAndTime [ '2023-12-16T08:18:33.439084+11:00' ],		#trigger : @3	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #ExercismHttpCommand\r\tinstanceVariableNames: \'httpClient\'\r\tclassVariableNames: \'\'\r\tpackage: \'ExercismTools-Core\'',				#superclassName : 'Object'			},			#name : #ExercismHttpCommand,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ExercismHttpCommand,						#isMetaSide : false					},					#name : #httpClient,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ExercismHttpCommand class\r\tinstanceVariableNames: \'\''				},				#name : #'ExercismHttpCommand class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ExercismHttpCommand,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #ExercismTools-Core,			#package : #ExercismTools-Core,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:18:37.315913+11:00' ],		#prior : OmReference [ '85' ],		#self : OmReference [ '86' ]	},	#content : EpRedo {		#entryReferences : OrderedCollection [			OmReference [ '6eipqn9xf2jcr4ewish659bgs', '1' ]		]	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '86' ],		#self : OmReference [ '87' ],		#time : DateAndTime [ '2023-12-16T08:18:37.328956+11:00' ],		#trigger : @3	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #ExercismHttpCommand\r\tinstanceVariableNames: \'httpClient\'\r\tclassVariableNames: \'\'\r\tpackage: \'ExercismTools-Core\'',				#superclassName : 'Object'			},			#name : #ExercismHttpCommand,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ExercismHttpCommand,						#isMetaSide : false					},					#name : #httpClient,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ExercismHttpCommand class\r\tinstanceVariableNames: \'\''				},				#name : #'ExercismHttpCommand class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ExercismHttpCommand,					#isMetaSide : false				},				#parent : @7,				#content : 'I am the root of Http commands that will use a (now) seperate httpClient object to fetch/put solution data',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #ExercismTools-Core,			#package : #ExercismTools-Core,			#sharedPools : OrderedCollection [ ]		},		#oldComment : '',		#newComment : 'I am the root of Http commands that will use a (now) seperate httpClient object to fetch/put solution data',		#oldStamp : '',		#newStamp : ''	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:18:41.448451+11:00' ],		#prior : OmReference [ '87' ],		#self : OmReference [ '88' ]	},	#content : EpRedo {		#entryReferences : OrderedCollection [			OmReference [ '6eipqnbth891z5iaprcahhe9u', '1' ]		]	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '88' ],		#self : OmReference [ '89' ],		#time : DateAndTime [ '2023-12-16T08:18:41.474367+11:00' ],		#trigger : @3	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'ExercismHttpCommand subclass: #ExercismFetchCommand\r\tinstanceVariableNames: \'parser\'\r\tclassVariableNames: \'\'\r\tpackage: \'ExercismTools-Core\'',				#superclassName : 'ExercismHttpCommand'			},			#name : #ExercismFetchCommand,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ExercismFetchCommand,						#isMetaSide : false					},					#name : #parser,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ExercismFetchCommand class\r\tinstanceVariableNames: \'\''				},				#name : #'ExercismFetchCommand class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ExercismFetchCommand,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #ExercismTools-Core,			#package : #ExercismTools-Core,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:18:48.308491+11:00' ],		#prior : OmReference [ '89' ],		#self : OmReference [ '90' ]	},	#content : EpRedo {		#entryReferences : OrderedCollection [			OmReference [ '6eipqn9p1jsvwq96rk9ik0gnx', '1' ]		]	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '90' ],		#self : OmReference [ '91' ],		#time : DateAndTime [ '2023-12-16T08:18:48.331829+11:00' ],		#trigger : @3	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'ExercismFetchCommand subclass: #ExercismDownloadCommand\r\tinstanceVariableNames: \'exerciseId trackName\'\r\tclassVariableNames: \'\'\r\tpackage: \'ExercismTools-Core\'',				#superclassName : 'ExercismFetchCommand'			},			#name : #ExercismDownloadCommand,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ExercismDownloadCommand,						#isMetaSide : false					},					#name : #exerciseId,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ExercismDownloadCommand,						#isMetaSide : false					},					#name : #trackName,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ExercismDownloadCommand class\r\tinstanceVariableNames: \'\''				},				#name : #'ExercismDownloadCommand class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ExercismDownloadCommand,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #ExercismTools-Core,			#package : #ExercismTools-Core,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:18:52.401073+11:00' ],		#prior : OmReference [ '91' ],		#self : OmReference [ '92' ]	},	#content : EpRedo {		#entryReferences : OrderedCollection [			OmReference [ '6eipqneyjpoji1sbzjusr879k', '1' ]		]	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '92' ],		#self : OmReference [ '93' ],		#time : DateAndTime [ '2023-12-16T08:18:52.417932+11:00' ],		#trigger : @3	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'ExercismFetchCommand subclass: #ExercismDownloadCommand\r\tinstanceVariableNames: \'exerciseId trackName\'\r\tclassVariableNames: \'\'\r\tpackage: \'ExercismTools-Core\'',				#superclassName : 'ExercismFetchCommand'			},			#name : #ExercismDownloadCommand,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ExercismDownloadCommand,						#isMetaSide : false					},					#name : #exerciseId,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ExercismDownloadCommand,						#isMetaSide : false					},					#name : #trackName,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ExercismDownloadCommand class\r\tinstanceVariableNames: \'\''				},				#name : #'ExercismDownloadCommand class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ExercismDownloadCommand,					#isMetaSide : false				},				#parent : @7,				#content : 'I am the command for dowloading an exercise and installing it in the image',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #ExercismTools-Core,			#package : #ExercismTools-Core,			#sharedPools : OrderedCollection [ ]		},		#oldComment : '',		#newComment : 'I am the command for dowloading an exercise and installing it in the image',		#oldStamp : '',		#newStamp : ''	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:18:56.764191+11:00' ],		#prior : OmReference [ '93' ],		#self : OmReference [ '94' ]	},	#content : EpRedo {		#entryReferences : OrderedCollection [			OmReference [ '6eipqnfs3bmj35spl4frxqdrb', '1' ]		]	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '94' ],		#self : OmReference [ '95' ],		#time : DateAndTime [ '2023-12-16T08:18:56.788096+11:00' ],		#trigger : @3	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'ExercismHttpCommand subclass: #ExercismSubmitCommand\r\tinstanceVariableNames: \'exercise\'\r\tclassVariableNames: \'\'\r\tpackage: \'ExercismTools-Core\'',				#superclassName : 'ExercismHttpCommand'			},			#name : #ExercismSubmitCommand,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ExercismSubmitCommand,						#isMetaSide : false					},					#name : #exercise,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ExercismSubmitCommand class\r\tinstanceVariableNames: \'\''				},				#name : #'ExercismSubmitCommand class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ExercismSubmitCommand,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #ExercismTools-Core,			#package : #ExercismTools-Core,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:19:00.561192+11:00' ],		#prior : OmReference [ '95' ],		#self : OmReference [ '96' ]	},	#content : EpRedo {		#entryReferences : OrderedCollection [			OmReference [ '6eipqn9kmyw9ri3z122k2ur3f', '1' ]		]	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '96' ],		#self : OmReference [ '97' ],		#time : DateAndTime [ '2023-12-16T08:19:00.577486+11:00' ],		#trigger : @3	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'ExercismHttpCommand subclass: #ExercismSubmitCommand\r\tinstanceVariableNames: \'exercise\'\r\tclassVariableNames: \'\'\r\tpackage: \'ExercismTools-Core\'',				#superclassName : 'ExercismHttpCommand'			},			#name : #ExercismSubmitCommand,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ExercismSubmitCommand,						#isMetaSide : false					},					#name : #exercise,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ExercismSubmitCommand class\r\tinstanceVariableNames: \'\''				},				#name : #'ExercismSubmitCommand class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ExercismSubmitCommand,					#isMetaSide : false				},				#parent : @7,				#content : 'I am a command for submitting an exercise. ',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #ExercismTools-Core,			#package : #ExercismTools-Core,			#sharedPools : OrderedCollection [ ]		},		#oldComment : '',		#newComment : 'I am a command for submitting an exercise. ',		#oldStamp : '',		#newStamp : ''	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:19:04.732803+11:00' ],		#prior : OmReference [ '97' ],		#self : OmReference [ '98' ]	},	#content : EpRedo {		#entryReferences : OrderedCollection [			OmReference [ '6eipqnfhxuomvs3c5qf4dlxol', '1' ]		]	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '98' ],		#self : OmReference [ '99' ],		#time : DateAndTime [ '2023-12-16T08:19:04.755988+11:00' ],		#trigger : @3	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #ExercismManager\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'SolutionData\'\r\tpackage: \'ExercismTools-Core\'',				#superclassName : 'Object'			},			#name : #ExercismManager,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ExercismManager class\r\tinstanceVariableNames: \'\''				},				#name : #'ExercismManager class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ExercismManager,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #ExercismManager,						#isMetaSide : false					},					#name : #SolutionData,					#parent : @7				}			],			#category : #ExercismTools-Core,			#package : #ExercismTools-Core,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:19:09.017371+11:00' ],		#prior : OmReference [ '99' ],		#self : OmReference [ '100' ]	},	#content : EpRedo {		#entryReferences : OrderedCollection [			OmReference [ '6eipqncazxehbyzrqj41rwsdd', '1' ]		]	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '100' ],		#self : OmReference [ '101' ],		#time : DateAndTime [ '2023-12-16T08:19:09.023577+11:00' ],		#trigger : @3	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #ExercismManager\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'SolutionData\'\r\tpackage: \'ExercismTools-Core\'',				#superclassName : 'Object'			},			#name : #ExercismManager,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ExercismManager class\r\tinstanceVariableNames: \'\''				},				#name : #'ExercismManager class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ExercismManager,					#isMetaSide : false				},				#parent : @7,				#content : 'I am  responsible for managing the interaction with the lower level Exercism command line tool.',				#stamp : ''			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #ExercismManager,						#isMetaSide : false					},					#name : #SolutionData,					#parent : @7				}			],			#category : #ExercismTools-Core,			#package : #ExercismTools-Core,			#sharedPools : OrderedCollection [ ]		},		#oldComment : '',		#newComment : 'I am  responsible for managing the interaction with the lower level Exercism command line tool.',		#oldStamp : '',		#newStamp : ''	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:19:14.832792+11:00' ],		#prior : OmReference [ '101' ],		#self : OmReference [ '102' ]	},	#content : EpRedo {		#entryReferences : OrderedCollection [			OmReference [ '6eipqnc3contf28vvzh0jq39a', '1' ]		]	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '102' ],		#self : OmReference [ '103' ],		#time : DateAndTime [ '2023-12-16T08:19:14.859175+11:00' ],		#trigger : @3	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #ExercismSubmission\r\tinstanceVariableNames: \'exercismData contentData\'\r\tclassVariableNames: \'\'\r\tpackage: \'ExercismTools-Core\'',				#superclassName : 'Object'			},			#name : #ExercismSubmission,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ExercismSubmission,						#isMetaSide : false					},					#name : #exercismData,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ExercismSubmission,						#isMetaSide : false					},					#name : #contentData,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ExercismSubmission class\r\tinstanceVariableNames: \'\''				},				#name : #'ExercismSubmission class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ExercismSubmission,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #ExercismTools-Core,			#package : #ExercismTools-Core,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:19:19.858592+11:00' ],		#prior : OmReference [ '103' ],		#self : OmReference [ '104' ]	},	#content : EpRedo {		#entryReferences : OrderedCollection [			OmReference [ '6eipqncm1ltjayignm1i1woab', '1' ]		]	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '104' ],		#self : OmReference [ '105' ],		#time : DateAndTime [ '2023-12-16T08:19:19.871819+11:00' ],		#trigger : @3	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #ExercismSubmission\r\tinstanceVariableNames: \'exercismData contentData\'\r\tclassVariableNames: \'\'\r\tpackage: \'ExercismTools-Core\'',				#superclassName : 'Object'			},			#name : #ExercismSubmission,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ExercismSubmission,						#isMetaSide : false					},					#name : #exercismData,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ExercismSubmission,						#isMetaSide : false					},					#name : #contentData,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ExercismSubmission class\r\tinstanceVariableNames: \'\''				},				#name : #'ExercismSubmission class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ExercismSubmission,					#isMetaSide : false				},				#parent : @7,				#content : 'I am a wrapper over the exercism json submission data. Crucially I have a solutionId that is needed when submitting exercises that have been downloaded.',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #ExercismTools-Core,			#package : #ExercismTools-Core,			#sharedPools : OrderedCollection [ ]		},		#oldComment : '',		#newComment : 'I am a wrapper over the exercism json submission data. Crucially I have a solutionId that is needed when submitting exercises that have been downloaded.',		#oldStamp : '',		#newStamp : ''	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:40:53.335834+11:00' ],		#prior : OmReference [ '105' ],		#self : OmReference [ '106' ]	},	#content : EpMonticelloVersionsLoad {		#versionNames : OrderedCollection [			'ExercismTools-CompatibleUserName.1700215054'		]	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '106' ],		#self : OmReference [ '107' ],		#time : DateAndTime [ '2023-12-16T08:40:57.260774+11:00' ],		#trigger : @3	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'CmdMenuGroup subclass: #ClyExercismMenuGroup\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpackage: \'ExercismTools-Menus\'',				#superclassName : 'CmdMenuGroup'			},			#name : #ClyExercismMenuGroup,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ClyExercismMenuGroup class\r\tinstanceVariableNames: \'\''				},				#name : #'ClyExercismMenuGroup class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ClyExercismMenuGroup,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #ExercismTools-Menus,			#package : #ExercismTools,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '107' ],		#self : OmReference [ '108' ],		#time : DateAndTime [ '2023-12-16T08:40:57.262348+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'CmdMenuGroup subclass: #ClyExercismMenuGroup\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpackage: \'ExercismTools-Menus\'',				#superclassName : 'CmdMenuGroup'			},			#name : #ClyExercismMenuGroup,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ClyExercismMenuGroup class\r\tinstanceVariableNames: \'\''				},				#name : #'ClyExercismMenuGroup class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ClyExercismMenuGroup,					#isMetaSide : false				},				#parent : @8,				#content : '# ClyExercismMenuGroup\r\rI am the group of Exercism menu item commands. My class can be used to\rgroup Exercism specific menu items.\r\rI am used in `ClyExercismExerciseCommand class>>#packageContextMenuActivation`\rand `ClyExercismExerciseCommand class >>#tagContextMenuActivation`.\r\r ',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #ExercismTools-Menus,			#package : #ExercismTools,			#sharedPools : OrderedCollection [ ]		},		#oldComment : '',		#newComment : '# ClyExercismMenuGroup\r\rI am the group of Exercism menu item commands. My class can be used to\rgroup Exercism specific menu items.\r\rI am used in `ClyExercismExerciseCommand class>>#packageContextMenuActivation`\rand `ClyExercismExerciseCommand class >>#tagContextMenuActivation`.\r\r ',		#oldStamp : '',		#newStamp : ''	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '108' ],		#self : OmReference [ '109' ],		#time : DateAndTime [ '2023-12-16T08:40:57.265492+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'SycPackageCommand subclass: #ClyExercismCommand\r\tinstanceVariableNames: \'browser selectedItem\'\r\tclassVariableNames: \'\'\r\tpackage: \'ExercismTools-Menus\'',				#superclassName : 'SycPackageCommand'			},			#name : #ClyExercismCommand,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ClyExercismCommand,						#isMetaSide : false					},					#name : #browser,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ClyExercismCommand,						#isMetaSide : false					},					#name : #selectedItem,					#parent : @8				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ClyExercismCommand class\r\tinstanceVariableNames: \'\''				},				#name : #'ClyExercismCommand class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ClyExercismCommand,					#isMetaSide : false				},				#parent : @8,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #ExercismTools-Menus,			#package : #ExercismTools,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '109' ],		#self : OmReference [ '110' ],		#time : DateAndTime [ '2023-12-16T08:40:57.266366+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'SycPackageCommand subclass: #ClyExercismCommand\r\tinstanceVariableNames: \'browser selectedItem\'\r\tclassVariableNames: \'\'\r\tpackage: \'ExercismTools-Menus\'',				#superclassName : 'SycPackageCommand'			},			#name : #ClyExercismCommand,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ClyExercismCommand,						#isMetaSide : false					},					#name : #browser,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ClyExercismCommand,						#isMetaSide : false					},					#name : #selectedItem,					#parent : @8				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ClyExercismCommand class\r\tinstanceVariableNames: \'\''				},				#name : #'ClyExercismCommand class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ClyExercismCommand,					#isMetaSide : false				},				#parent : @8,				#content : '# ClyExercismCommand\r\rI provide menu facilities for Exercism that should only appear in the \rcontext of an Exercism package (and not in other browser packages).\r\rI am an abstract class.\r\r## Design\r\rI follow the Command Pattern of Object Oriented Design. I do one task \ron recieving the `#execute` message, which must be implemented by \rsubclasses. All other methods should be about setting up the state\rrequred for the `#execute` method to carry out its task.\r\rThe `#execute` method is written further up the inheritance hierarchy\rat `CmdCommand>>#execute`.\r\r## Instance Variables\r\r- browser: ClyPackageContextOfFullBrowser, the context of of a browser instance containing packages.\r- selectedItem: RPackage, the selected package in the browser context.',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #ExercismTools-Menus,			#package : #ExercismTools,			#sharedPools : OrderedCollection [ ]		},		#oldComment : '',		#newComment : '# ClyExercismCommand\r\rI provide menu facilities for Exercism that should only appear in the \rcontext of an Exercism package (and not in other browser packages).\r\rI am an abstract class.\r\r## Design\r\rI follow the Command Pattern of Object Oriented Design. I do one task \ron recieving the `#execute` message, which must be implemented by \rsubclasses. All other methods should be about setting up the state\rrequred for the `#execute` method to carry out its task.\r\rThe `#execute` method is written further up the inheritance hierarchy\rat `CmdCommand>>#execute`.\r\r## Instance Variables\r\r- browser: ClyPackageContextOfFullBrowser, the context of of a browser instance containing packages.\r- selectedItem: RPackage, the selected package in the browser context.',		#oldStamp : '',		#newStamp : ''	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '110' ],		#self : OmReference [ '111' ],		#time : DateAndTime [ '2023-12-16T08:40:57.267892+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'ClyExercismCommand subclass: #ClyExercismExerciseCommand\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpackage: \'ExercismTools-Menus\'',				#superclassName : 'ClyExercismCommand'			},			#name : #ClyExercismExerciseCommand,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ClyExercismExerciseCommand class\r\tinstanceVariableNames: \'\''				},				#name : #'ClyExercismExerciseCommand class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ClyExercismExerciseCommand,					#isMetaSide : false				},				#parent : @8,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #ExercismTools-Menus,			#package : #ExercismTools,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '111' ],		#self : OmReference [ '112' ],		#time : DateAndTime [ '2023-12-16T08:40:57.269777+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'ClyExercismCommand subclass: #ClyExercismExerciseCommand\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpackage: \'ExercismTools-Menus\'',				#superclassName : 'ClyExercismCommand'			},			#name : #ClyExercismExerciseCommand,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ClyExercismExerciseCommand class\r\tinstanceVariableNames: \'\''				},				#name : #'ClyExercismExerciseCommand class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ClyExercismExerciseCommand,					#isMetaSide : false				},				#parent : @8,				#content : '# ClyExercismExerciseCommand\r\rI am the Abstract super class of all Exercism exercise menu commands.\rMenu items subclassing me should only appear on exercise package tags\rin the browser.\r\r## GUI Menu \r\rSubclasses of me are grouped into a browser menu under the name \r"Exercism" when activating a menu on a package or tag. This submenu\ris created by the class methods `#packageContextMenuActivation` and\r`#tagContextMenuActivation`.\r\r## Error reporting\r\rSubclasess may use `#reportError:for:` to report errors. \r\rIn one error case the exercise may be missing metadata and will need \rto be upgraded in the users Exercism profile and re-fetched.\r\rIn another error case the exercise may not be found. The likely \rproblem is that the exercise name is misspelled or does not exist in\rthe Pharo-Smalltalk language track. ',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #ExercismTools-Menus,			#package : #ExercismTools,			#sharedPools : OrderedCollection [ ]		},		#oldComment : '',		#newComment : '# ClyExercismExerciseCommand\r\rI am the Abstract super class of all Exercism exercise menu commands.\rMenu items subclassing me should only appear on exercise package tags\rin the browser.\r\r## GUI Menu \r\rSubclasses of me are grouped into a browser menu under the name \r"Exercism" when activating a menu on a package or tag. This submenu\ris created by the class methods `#packageContextMenuActivation` and\r`#tagContextMenuActivation`.\r\r## Error reporting\r\rSubclasess may use `#reportError:for:` to report errors. \r\rIn one error case the exercise may be missing metadata and will need \rto be upgraded in the users Exercism profile and re-fetched.\r\rIn another error case the exercise may not be found. The likely \rproblem is that the exercise name is misspelled or does not exist in\rthe Pharo-Smalltalk language track. ',		#oldStamp : '',		#newStamp : ''	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '112' ],		#self : OmReference [ '113' ],		#time : DateAndTime [ '2023-12-16T08:40:57.27154+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'ClyExercismExerciseCommand subclass: #ClyExercismFetchCommand\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpackage: \'ExercismTools-Menus\'',				#superclassName : 'ClyExercismExerciseCommand'			},			#name : #ClyExercismFetchCommand,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ClyExercismFetchCommand class\r\tinstanceVariableNames: \'\''				},				#name : #'ClyExercismFetchCommand class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ClyExercismFetchCommand,					#isMetaSide : false				},				#parent : @8,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #ExercismTools-Menus,			#package : #ExercismTools,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '113' ],		#self : OmReference [ '114' ],		#time : DateAndTime [ '2023-12-16T08:40:57.272243+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'ClyExercismExerciseCommand subclass: #ClyExercismFetchCommand\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpackage: \'ExercismTools-Menus\'',				#superclassName : 'ClyExercismExerciseCommand'			},			#name : #ClyExercismFetchCommand,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ClyExercismFetchCommand class\r\tinstanceVariableNames: \'\''				},				#name : #'ClyExercismFetchCommand class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ClyExercismFetchCommand,					#isMetaSide : false				},				#parent : @8,				#content : '# ClyExercismFetchCommand\r\rI am a browser menu item command that initiates a fetch operation to \rget a specific exercise from Exercism.io.\r\r## Command Execution\r\rI implement the `#execute` method. On receiving this message I start \rthe fetch operation to get an exercise, and report the success or error\rof the operation via the UI.\r\rI send a message to `ExercismManager default` to fetch the exercise.\rOn successful retrieval of an exercise I will open a browser window on\rthat exercises test case.\r\rI may signal an `ExDomainError` if I could not retrieve an exercise from\rthe `ExercismManager` submission.\r\rIf the `ExercismManager` signals an `ExDomainError` I will report the\rerror with `ClyExercismExerciseCommand>>#reportError:for:`.\r\r## World Menu\r\rOn my class side is `#worldMenuCommandOn:`. This method adds a "Fetch\rnew exercise..." command to the World menu under the "Exercism" section.',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #ExercismTools-Menus,			#package : #ExercismTools,			#sharedPools : OrderedCollection [ ]		},		#oldComment : '',		#newComment : '# ClyExercismFetchCommand\r\rI am a browser menu item command that initiates a fetch operation to \rget a specific exercise from Exercism.io.\r\r## Command Execution\r\rI implement the `#execute` method. On receiving this message I start \rthe fetch operation to get an exercise, and report the success or error\rof the operation via the UI.\r\rI send a message to `ExercismManager default` to fetch the exercise.\rOn successful retrieval of an exercise I will open a browser window on\rthat exercises test case.\r\rI may signal an `ExDomainError` if I could not retrieve an exercise from\rthe `ExercismManager` submission.\r\rIf the `ExercismManager` signals an `ExDomainError` I will report the\rerror with `ClyExercismExerciseCommand>>#reportError:for:`.\r\r## World Menu\r\rOn my class side is `#worldMenuCommandOn:`. This method adds a "Fetch\rnew exercise..." command to the World menu under the "Exercism" section.',		#oldStamp : '',		#newStamp : ''	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '114' ],		#self : OmReference [ '115' ],		#time : DateAndTime [ '2023-12-16T08:40:57.27363+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'ClyExercismExerciseCommand subclass: #ClyExercismProgressCommand\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpackage: \'ExercismTools-Menus\'',				#superclassName : 'ClyExercismExerciseCommand'			},			#name : #ClyExercismProgressCommand,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ClyExercismProgressCommand class\r\tinstanceVariableNames: \'\''				},				#name : #'ClyExercismProgressCommand class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ClyExercismProgressCommand,					#isMetaSide : false				},				#parent : @8,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #ExercismTools-Menus,			#package : #ExercismTools,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '115' ],		#self : OmReference [ '116' ],		#time : DateAndTime [ '2023-12-16T08:40:57.274207+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'ClyExercismExerciseCommand subclass: #ClyExercismProgressCommand\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpackage: \'ExercismTools-Menus\'',				#superclassName : 'ClyExercismExerciseCommand'			},			#name : #ClyExercismProgressCommand,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ClyExercismProgressCommand class\r\tinstanceVariableNames: \'\''				},				#name : #'ClyExercismProgressCommand class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ClyExercismProgressCommand,					#isMetaSide : false				},				#parent : @8,				#content : '# ClyExercisProgressCommand\r\rI am a browser menu item command that initiates an operation to view\rthe users progress of an exercise on the Exercism website.\r\r## Command Execution\r\rIn my `#execute` method I send a message to `ExercismManager default`\rto view the selected exercise in the browser on the Exercism website.\r\r## World Menu\r\rOn my class side `#worldMenuCommandOn:` creates an entry labeled "View\rTrack Progress" for me in the World menu under the "Exercism" section.',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #ExercismTools-Menus,			#package : #ExercismTools,			#sharedPools : OrderedCollection [ ]		},		#oldComment : '',		#newComment : '# ClyExercisProgressCommand\r\rI am a browser menu item command that initiates an operation to view\rthe users progress of an exercise on the Exercism website.\r\r## Command Execution\r\rIn my `#execute` method I send a message to `ExercismManager default`\rto view the selected exercise in the browser on the Exercism website.\r\r## World Menu\r\rOn my class side `#worldMenuCommandOn:` creates an entry labeled "View\rTrack Progress" for me in the World menu under the "Exercism" section.',		#oldStamp : '',		#newStamp : ''	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '116' ],		#self : OmReference [ '117' ],		#time : DateAndTime [ '2023-12-16T08:40:57.276287+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'ClyExercismExerciseCommand subclass: #ClyExercismShareCommand\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'hasConfirmedSharing\'\r\tpackage: \'ExercismTools-Menus\'',				#superclassName : 'ClyExercismExerciseCommand'			},			#name : #ClyExercismShareCommand,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ClyExercismShareCommand class\r\tinstanceVariableNames: \'\''				},				#name : #'ClyExercismShareCommand class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ClyExercismShareCommand,					#isMetaSide : false				},				#parent : @8,				#content : ''			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #ClyExercismShareCommand,						#isMetaSide : false					},					#name : #hasConfirmedSharing,					#parent : @8				}			],			#category : #ExercismTools-Menus,			#package : #ExercismTools,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '117' ],		#self : OmReference [ '118' ],		#time : DateAndTime [ '2023-12-16T08:40:57.276914+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'ClyExercismExerciseCommand subclass: #ClyExercismShareCommand\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'hasConfirmedSharing\'\r\tpackage: \'ExercismTools-Menus\'',				#superclassName : 'ClyExercismExerciseCommand'			},			#name : #ClyExercismShareCommand,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ClyExercismShareCommand class\r\tinstanceVariableNames: \'\''				},				#name : #'ClyExercismShareCommand class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ClyExercismShareCommand,					#isMetaSide : false				},				#parent : @8,				#content : '# ClyExercismShareCommand\r\rI am a browser menu item command. I can be used to share the code of \ran exercise solution by creating an anonymous web link to `dpaste.com`.\r\r## Enabling Sharing\r\rSharing will not be possible unless the class method \r`#hasComfirmedSharing:` is used to set the class variable of the same \rname to `true`.\r\r## Command Execution\r\rIn my `#execute` method I initiate and handle the result of the \rsharing operation. I send a message to `ExercismManager default` to\rstart the sharing.\r\rI may report an `ExercismError` signaled my `ExercismManager` using\r`ClyExercismExerciseCommand>>#reportError:for:`. I may use the same\rmessage to report an error if the exercise name can\'t be found.\r\rOn a successful operation I will copy the dpase.com URL to the\rclipboard and open the webbrowser on the URL.',				#stamp : ''			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #ClyExercismShareCommand,						#isMetaSide : false					},					#name : #hasConfirmedSharing,					#parent : @8				}			],			#category : #ExercismTools-Menus,			#package : #ExercismTools,			#sharedPools : OrderedCollection [ ]		},		#oldComment : '',		#newComment : '# ClyExercismShareCommand\r\rI am a browser menu item command. I can be used to share the code of \ran exercise solution by creating an anonymous web link to `dpaste.com`.\r\r## Enabling Sharing\r\rSharing will not be possible unless the class method \r`#hasComfirmedSharing:` is used to set the class variable of the same \rname to `true`.\r\r## Command Execution\r\rIn my `#execute` method I initiate and handle the result of the \rsharing operation. I send a message to `ExercismManager default` to\rstart the sharing.\r\rI may report an `ExercismError` signaled my `ExercismManager` using\r`ClyExercismExerciseCommand>>#reportError:for:`. I may use the same\rmessage to report an error if the exercise name can\'t be found.\r\rOn a successful operation I will copy the dpase.com URL to the\rclipboard and open the webbrowser on the URL.',		#oldStamp : '',		#newStamp : ''	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '118' ],		#self : OmReference [ '119' ],		#time : DateAndTime [ '2023-12-16T08:40:57.278274+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'ClyExercismExerciseCommand subclass: #ClyExercismSubmitCommand\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpackage: \'ExercismTools-Menus\'',				#superclassName : 'ClyExercismExerciseCommand'			},			#name : #ClyExercismSubmitCommand,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ClyExercismSubmitCommand class\r\tinstanceVariableNames: \'\''				},				#name : #'ClyExercismSubmitCommand class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ClyExercismSubmitCommand,					#isMetaSide : false				},				#parent : @8,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #ExercismTools-Menus,			#package : #ExercismTools,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '119' ],		#self : OmReference [ '120' ],		#time : DateAndTime [ '2023-12-16T08:40:57.278839+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'ClyExercismExerciseCommand subclass: #ClyExercismSubmitCommand\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpackage: \'ExercismTools-Menus\'',				#superclassName : 'ClyExercismExerciseCommand'			},			#name : #ClyExercismSubmitCommand,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ClyExercismSubmitCommand class\r\tinstanceVariableNames: \'\''				},				#name : #'ClyExercismSubmitCommand class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ClyExercismSubmitCommand,					#isMetaSide : false				},				#parent : @8,				#content : '# ClyExercismSubmitCommand\r\rI am a browser menu item command. I initiate submitting the selected\rexercise solution to the Exercism website.\r\r## Command Execution\r\rOn recieving the message `#execute` I initiate the submit operation by\rsending the message `#submitToExercism:` to `ExercismManager default`.\rThis will submit my selected exercise.\r\rIf an `ExercismError` is signaled I will report the error with\r`#reportError:for:`. \r',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #ExercismTools-Menus,			#package : #ExercismTools,			#sharedPools : OrderedCollection [ ]		},		#oldComment : '',		#newComment : '# ClyExercismSubmitCommand\r\rI am a browser menu item command. I initiate submitting the selected\rexercise solution to the Exercism website.\r\r## Command Execution\r\rOn recieving the message `#execute` I initiate the submit operation by\rsending the message `#submitToExercism:` to `ExercismManager default`.\rThis will submit my selected exercise.\r\rIf an `ExercismError` is signaled I will report the error with\r`#reportError:for:`. \r',		#oldStamp : '',		#newStamp : ''	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '120' ],		#self : OmReference [ '121' ],		#time : DateAndTime [ '2023-12-16T08:40:57.280189+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'STONWriter subclass: #STONJSONWriter\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpackage: \'ExercismTools-Core\'',				#superclassName : 'STONWriter'			},			#name : #STONJSONWriter,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'STONJSONWriter class\r\tinstanceVariableNames: \'\''				},				#name : #'STONJSONWriter class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #STONJSONWriter,					#isMetaSide : false				},				#parent : @8,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #ExercismTools-Core,			#package : #ExercismTools-Core,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '121' ],		#self : OmReference [ '122' ],		#time : DateAndTime [ '2023-12-16T08:40:57.280738+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'STONWriter subclass: #STONJSONWriter\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpackage: \'ExercismTools-Core\'',				#superclassName : 'STONWriter'			},			#name : #STONJSONWriter,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'STONJSONWriter class\r\tinstanceVariableNames: \'\''				},				#name : #'STONJSONWriter class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #STONJSONWriter,					#isMetaSide : false				},				#parent : @8,				#content : 'I am a simple JSON writer that lets you specify configuation in JSON like:\r\rdata := { \r\t\'id\'-> 123. \r\t\'language\' -> \'english\'.\r\t\'exercises\' -> {\r\t\t\'name\' -> \'hello\'.\r\t\t\'topics\' -> #(\'a\' \'b\' \'c\') }\r\t}. \r\t\rString streamContents: [ :stream |\r\t(STONJSONWriter on: stream) nextPut: data  ].\r\rIt is assumed that key order is important and so all Dictionaries are converted to OrderedDictionary when writing out the JSON',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #ExercismTools-Core,			#package : #ExercismTools-Core,			#sharedPools : OrderedCollection [ ]		},		#oldComment : '',		#newComment : 'I am a simple JSON writer that lets you specify configuation in JSON like:\r\rdata := { \r\t\'id\'-> 123. \r\t\'language\' -> \'english\'.\r\t\'exercises\' -> {\r\t\t\'name\' -> \'hello\'.\r\t\t\'topics\' -> #(\'a\' \'b\' \'c\') }\r\t}. \r\t\rString streamContents: [ :stream |\r\t(STONJSONWriter on: stream) nextPut: data  ].\r\rIt is assumed that key order is important and so all Dictionaries are converted to OrderedDictionary when writing out the JSON',		#oldStamp : '',		#newStamp : ''	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '122' ],		#self : OmReference [ '123' ],		#time : DateAndTime [ '2023-12-16T08:40:57.525234+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'TExercise classTrait',				#isMetaSide : true			},			#name : #'createExerciseAfter:',			#protocol : #helper,			#sourceCode : 'createExerciseAfter: anotherTestCase\r\t"Helper method to create an exercise meta data object"\r\t\r\t^ (ExercismExercise for: self)\r\t\tunlockedBy: \r\t\t\t((anotherTestCase notNil and: [ anotherTestCase isObsolete not ])\r\t\t\t\tifTrue: [ [ anotherTestCase exercise ] on: SubclassResponsibility do: [ nil ] ]\r\t\t\t\tifFalse: [ nil ]);\r\t\tyourself ',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '123' ],		#self : OmReference [ '124' ],		#time : DateAndTime [ '2023-12-16T08:40:57.525878+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'TExercise classTrait',				#isMetaSide : true			},			#name : #customData,			#protocol : #config,			#sourceCode : 'customData\r\r\t^ customData',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '124' ],		#self : OmReference [ '125' ],		#time : DateAndTime [ '2023-12-16T08:40:57.526322+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'TExercise classTrait',				#isMetaSide : true			},			#name : #exercise,			#protocol : #config,			#sourceCode : 'exercise\r\r\t^ self configuredExerciseMetadata',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '125' ],		#self : OmReference [ '126' ],		#time : DateAndTime [ '2023-12-16T08:40:57.526553+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'TExercise classTrait',				#isMetaSide : true			},			#name : #generator,			#protocol : #generator,			#sourceCode : 'generator\r\r\t^ aliasesAndHints',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '126' ],		#self : OmReference [ '127' ],		#time : DateAndTime [ '2023-12-16T08:40:57.526726+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'TExercise classTrait',				#isMetaSide : true			},			#name : #isActive,			#protocol : #config,			#sourceCode : 'isActive\r\r\t^ isActive',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '127' ],		#self : OmReference [ '128' ],		#time : DateAndTime [ '2023-12-16T08:40:57.526873+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'TExercise classTrait',				#isMetaSide : true			},			#name : #isCustom,			#protocol : #config,			#sourceCode : 'isCustom\r\r\t^ customData notEmpty ',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '128' ],		#self : OmReference [ '129' ],		#time : DateAndTime [ '2023-12-16T08:40:57.527006+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'TExercise classTrait',				#isMetaSide : true			},			#name : #solutionId,			#protocol : #accessing,			#sourceCode : 'solutionId \r\r\t^ solutionId ifNil: [ ExSolutionIdError signal: \'Missing exercise solutionId\' ]',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '129' ],		#self : OmReference [ '130' ],		#time : DateAndTime [ '2023-12-16T08:40:57.527136+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'TExercise classTrait',				#isMetaSide : true			},			#name : #'solutionId:',			#protocol : #accessing,			#sourceCode : 'solutionId: anObject\r\r\tsolutionId := anObject ',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '130' ],		#self : OmReference [ '131' ],		#time : DateAndTime [ '2023-12-16T08:40:57.527272+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'TExercise classTrait',				#isMetaSide : true			},			#name : #uuid,			#protocol : #config,			#sourceCode : 'uuid\r\r\t^ uuid',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '131' ],		#self : OmReference [ '132' ],		#time : DateAndTime [ '2023-12-16T08:40:57.527408+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'TExercise classTrait',				#isMetaSide : true			},			#name : #version,			#protocol : #config,			#sourceCode : 'version\r\r\t^ version',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '132' ],		#self : OmReference [ '133' ],		#time : DateAndTime [ '2023-12-16T08:40:57.528006+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UITheme,				#isMetaSide : false			},			#name : #'newStaticTextIn:text:',			#protocol : #'*ExercismTools',			#sourceCode : 'newStaticTextIn: aThemedMorph text: aStringOrText\r\t"Answer a new text."\r\t"Derived from newTextIn:text: - changed from locked to disabled"    \r\r\t^StaticTextMorph new\r\t\twrapFlag: true;\r\t\tcontents: aStringOrText;\r\t\tfont: self textFont;\r\t\tautoFit: true;\r\t\thResizing: #shrinkWrap;\r\t\tvResizing: #shrinkWrap',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '133' ],		#self : OmReference [ '134' ],		#time : DateAndTime [ '2023-12-16T08:40:57.528502+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UITheme,				#isMetaSide : false			},			#name : #'textEntryIn:formattedText:title:entryText:',			#protocol : #'*ExercismTools',			#sourceCode : 'textEntryIn: aThemedMorph formattedText: formattedText title: aString entryText: defaultEntryText\r\t"Answer the result of a text entry dialog (a string or nil if cancelled)\r\twith the given label and title."\r\t"Derived from textEntryIn:text:title:entryText: but calling #formattedText: not #text:"\r\r\tself questionSound play.\r\t^(aThemedMorph openModal: (\r\t\tTextEntryDialogWindow new\r\t\t\ttextFont: self textFont;\r\t\t\ttitle: aString;\r\t\t\tformattedText: formattedText;\r\t\t\tentryText: defaultEntryText)) entryText',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '134' ],		#self : OmReference [ '135' ],		#time : DateAndTime [ '2023-12-16T08:40:57.528893+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MCClassDefinition,				#isMetaSide : false			},			#name : #exTonelFilename,			#protocol : #'*ExercismTools',			#sourceCode : 'exTonelFilename\r\t^ClassDescription exTonelClassFilenameFor: self className ',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '135' ],		#self : OmReference [ '136' ],		#time : DateAndTime [ '2023-12-16T08:40:57.529213+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestResult,				#isMetaSide : false			},			#name : #'exercismEnvironmentInfoOn:',			#protocol : #'*ExercismTools',			#sourceCode : 'exercismEnvironmentInfoOn: aStream\r\r\taStream \r\t \tnextPutAll: \'Used OS/Platform: \';\r\t\tnextPutAll: Smalltalk os platformName; space;\r\t\tnextPutAll: Smalltalk os version; space;\r\t\tnextPutAll: Smalltalk os subtype;\r\t\tcrlf;\r\t\tnextPutAll: \'Image version: \';\r\t\tnextPutAll: SystemVersion current version; space;\r\t\tnextPutAll: \'build: \';\r\t\tnextPutAll: SystemVersion current build asString;\r\t\tnextPutAll: (Smalltalk vm is32bit \r\t\t\tifTrue: [ \' (32 Bit)\' ]\r\t\t\tifFalse: [ \' (64 Bit)\' ]).\r\taStream \r\t\tcrlf;\r\t\tnextPutAll: \'VM version: \';\r\t\tnextPutAll: Smalltalk vm interpreterSourceVersion\r\t\t ',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '136' ],		#self : OmReference [ '137' ],		#time : DateAndTime [ '2023-12-16T08:40:57.529476+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestResult,				#isMetaSide : false			},			#name : #exercismSummary,			#protocol : #'*ExercismTools',			#sourceCode : 'exercismSummary\r\t^String streamContents: [ :s | s \r\t\tnextPutAll: \'Tested on: \';\r\t\tnextPutAll: self timeStamp asLocalStringYMDHM;\r\t\tcrlf;\r\t\tnextPutAll: self runCount printString;\r\t\tnextPutAll: \' run, \';\r\t\tnextPutAll: self expectedPassCount printString;\r\t\tnextPutAll: \' passes, \';\r\t\tnextPutAll: self skippedCount printString;\r\t\tnextPutAll: \' skipped, \';\r\t\tnextPutAll: self unexpectedFailureCount printString;\r\t\tnextPutAll: \' failures, \';\r\t\tnextPutAll: self unexpectedErrorCount printString;\r\t\tnextPutAll:\' errors.\';\r\t\tcrlf.\r\t\tself exercismEnvironmentInfoOn: s.\r\t]',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '137' ],		#self : OmReference [ '138' ],		#time : DateAndTime [ '2023-12-16T08:40:57.529659+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ExercismHintTwoFerReuseRule class',				#isMetaSide : true			},			#name : #checksMethod,			#protocol : #testing-interest,			#sourceCode : 'checksMethod\r\t^true',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '138' ],		#self : OmReference [ '139' ],		#time : DateAndTime [ '2023-12-16T08:40:57.529837+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismHintTwoFerReuseRule,				#isMetaSide : false			},			#name : #'basicCheck:',			#protocol : #accessing,			#sourceCode : 'basicCheck: compiledMethod\r\tcompiledMethod methodClass name = #TwoFer ifTrue: [ \r\t\t|literals|\r\t\tliterals := compiledMethod sourceCode parseLiterals.\r\t\tliterals first = #who ifTrue: [ ^ (literals includes: #who:) not ].\r\t\t].\r\t^false\r',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '139' ],		#self : OmReference [ '140' ],		#time : DateAndTime [ '2023-12-16T08:40:57.529975+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismHintTwoFerReuseRule,				#isMetaSide : false			},			#name : #name,			#protocol : #accessing,			#sourceCode : 'name\r\t^ \'Exercism: Method #who should reuse method #who: \'',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '140' ],		#self : OmReference [ '141' ],		#time : DateAndTime [ '2023-12-16T08:40:57.530273+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ZnMimePart class',				#isMetaSide : true			},			#name : #'exercismFieldName:fileName:entity:',			#protocol : #'*ExercismTools',			#sourceCode : 'exercismFieldName: fieldName fileName: fileName entity: entity\r\t"Copied from ZnMimePart class >> fieldName:fileName:entity:\r\t with space added after \'form-data;\' as required by Exercism server, \r\t otherwise we get Response(500 INTERNAL SERVER ERROR).\r\t Space added after second semi-colon just for looks."\r\t\r\t"Pathnames are often silenty encoded using UTF-8,\r\tthis is a no-op for ASCII, but will fail on Latin-1 and others"\r\r\t| encodedFileName |\r\tencodedFileName := fileName utf8Encoded asString.\r\t^ self new\r\t\tsetContentDisposition: \'form-data; name="\', fieldName, \'"; filename="\', encodedFileName, \'"\';\r\t\tentity: entity;\r\t\tyourself\r',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '141' ],		#self : OmReference [ '142' ],		#time : DateAndTime [ '2023-12-16T08:40:57.530573+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ClassDescription class',				#isMetaSide : true			},			#name : #'exTonelClassFilenameFor:',			#protocol : #'*ExercismTools',			#sourceCode : 'exTonelClassFilenameFor: aName\r\t^aName, \'.class.st\'',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '142' ],		#self : OmReference [ '143' ],		#time : DateAndTime [ '2023-12-16T08:40:57.530858+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ClassDescription class',				#isMetaSide : true			},			#name : #'exTonelExtensionFilenameFor:',			#protocol : #'*ExercismTools',			#sourceCode : 'exTonelExtensionFilenameFor: aName\r\t^aName, \'.extension.st\'',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '143' ],		#self : OmReference [ '144' ],		#time : DateAndTime [ '2023-12-16T08:40:57.531259+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClassDescription,				#isMetaSide : false			},			#name : #'exPrintOutCategoriesFor:on:',			#protocol : #'*ExercismTools',			#sourceCode : 'exPrintOutCategoriesFor: aClass on: aWriteStream\r\r\taClass methods ifEmpty: [ ^self ].\r\t\r\taWriteStream \r\t\tnextPutAll: (aClass isClassSide ifTrue: [ \'"[class\'] ifFalse: [  \'"[instance\']);\r\t \tnextPutAll: \' methods]"\'; cr.\r\t\r\taClass organization categories asSortedCollection \r\t\tdo: [ :heading | \r\t\t\taWriteStream\r\t\t\t\tnextPutAll: \'"category: \';\r\t\t\t\tnextPutAll: heading;\r\t\t\t\tnextPutAll: \'"\';\r\t\t\t\tcr.\r\t\t\t\t\r\t\t\taClass exPrintOutLocalMethodsInCategory: heading on: aWriteStream ]',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '144' ],		#self : OmReference [ '145' ],		#time : DateAndTime [ '2023-12-16T08:40:57.531626+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClassDescription,				#isMetaSide : false			},			#name : #'exPrintOutExtensionsFor:on:',			#protocol : #'*ExercismTools',			#sourceCode : 'exPrintOutExtensionsFor: aRPackage on: aWriteStream\r\r\taRPackage exPrintOutExtensionsFor: self on: aWriteStream. ',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '145' ],		#self : OmReference [ '146' ],		#time : DateAndTime [ '2023-12-16T08:40:57.531956+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClassDescription,				#isMetaSide : false			},			#name : #'exPrintOutLocalMethodsInCategory:on:',			#protocol : #'*ExercismTools',			#sourceCode : 'exPrintOutLocalMethodsInCategory: aSymbol on: aWriteStream\r\t"Print out methods for this category."\r\r\taWriteStream cr.\r\t\r\t(self selectorsToFileOutCategory: aSymbol)\r\t\tdo: [ :sel | self exPrintOutMethod: sel on: aWriteStream ]\r\t',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '146' ],		#self : OmReference [ '147' ],		#time : DateAndTime [ '2023-12-16T08:40:57.532299+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClassDescription,				#isMetaSide : false			},			#name : #'exPrintOutMethod:on:',			#protocol : #'*ExercismTools',			#sourceCode : 'exPrintOutMethod: selector on: aWriteStream\r\t"Print the source code for selector onto the WriteStream."\r\r\t| method source |\r\tmethod := self\r\t\tcompiledMethodAt: selector\r\t\tifAbsent: [ ^ aWriteStream\r\t\t\t\tnextPutAll: selector;\r\t\t\t\tcr;\r\t\t\t\ttab;\r\t\t\t\tnextPutAll: \'"** ERROR: SOURCE IS MISSING ** ".\';\r\t\t\t\tcr;\r\t\t\t\tcr ].\r\t\t\t\r\tsource := method sourceCode trimBoth.\r\t\r\taWriteStream nextPutAll: source.\r\t\r\tsource last = $.\r\t\tifFalse: [ aWriteStream nextPut: $. ].\r\t\t\r\taWriteStream\r\t\tcr;\r\t\tcr',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '147' ],		#self : OmReference [ '148' ],		#time : DateAndTime [ '2023-12-16T08:40:57.532649+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClassDescription,				#isMetaSide : false			},			#name : #'exPrintOutOn:',			#protocol : #'*ExercismTools',			#sourceCode : 'exPrintOutOn: aWriteStream\r\t"Print a description of the receiver on aWriteStream."\r\r\taWriteStream\r\t\tnextPutAll: \'"-- #\', self name, \' (class) --"\'; cr; cr;\r\t\tnextPutAll: self definition; \r\t\tnextPut: $.; cr; cr.\r\t\r\tself hasComment ifTrue: [ \r\t\taWriteStream nextPut: $".\r\t\tself comment trimBoth encodeDoublingDoubleQuotesOn: aWriteStream.\r\t\taWriteStream nextPut: $"; cr; cr ].\r\t\r\tself exPrintOutCategoriesFor: self class on: aWriteStream.\r\tself exPrintOutCategoriesFor: self on: aWriteStream',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '148' ],		#self : OmReference [ '149' ],		#time : DateAndTime [ '2023-12-16T08:40:57.53293+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MCMethodDefinition,				#isMetaSide : false			},			#name : #exTonelFilename,			#protocol : #'*ExercismTools',			#sourceCode : 'exTonelFilename\r\t^ClassDescription exTonelExtensionFilenameFor: self className ',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '149' ],		#self : OmReference [ '150' ],		#time : DateAndTime [ '2023-12-16T08:40:57.533087+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ExercismTest class',				#isMetaSide : true			},			#name : #'createExerciseAfter:',			#protocol : #helper,			#sourceCode : 'createExerciseAfter: anotherTestCase\r\t"protocol: #helper"\r\r\t"Helper method to create an exercise meta data object"\r\r\t^ (ExercismExercise for: self)\r\t\tunlockedBy:\r\t\t\t((anotherTestCase notNil and: [ anotherTestCase isObsolete not ])\r\t\t\t\tifTrue: [ [anotherTestCase exercise] on: SubclassResponsibility do: [ nil ] ]\r\t\t\t\tifFalse: [ nil ]);\r\t\tyourself',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '150' ],		#self : OmReference [ '151' ],		#time : DateAndTime [ '2023-12-16T08:40:57.533213+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ExercismTest class',				#isMetaSide : true			},			#name : #customData,			#protocol : #config,			#sourceCode : 'customData\r\t^{}',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '151' ],		#self : OmReference [ '152' ],		#time : DateAndTime [ '2023-12-16T08:40:57.533343+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ExercismTest class',				#isMetaSide : true			},			#name : #exercise,			#protocol : #config,			#sourceCode : 'exercise\r\t"Answer the configured exercise meta data for this exercise, an ExercismExercise\r\te.g.\r\t\r\t^(self createExerciseAfter: HelloWorldTest)\r\t\tisCore: false;\r\t\tdifficulty: 1;\r\t\ttopics: #(\'strings\' \'iteration\' \'parsing\');\r\t\tyourself\r\t"\r\t\r\tself subclassResponsibility \r\t\t\t\t',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '152' ],		#self : OmReference [ '153' ],		#time : DateAndTime [ '2023-12-16T08:40:57.533459+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ExercismTest class',				#isMetaSide : true			},			#name : #generator,			#protocol : #generator,			#sourceCode : 'generator\r\t"Answer code generator aliases/hints"\r\t\r\t^{}',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '153' ],		#self : OmReference [ '154' ],		#time : DateAndTime [ '2023-12-16T08:40:57.533581+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ExercismTest class',				#isMetaSide : true			},			#name : #isActive,			#protocol : #config,			#sourceCode : 'isActive\r\t"Answer true if an exercise is active (not deprecated or for testing)"\r\t\r\t^true',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '154' ],		#self : OmReference [ '155' ],		#time : DateAndTime [ '2023-12-16T08:40:57.533694+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ExercismTest class',				#isMetaSide : true			},			#name : #isCustom,			#protocol : #config,			#sourceCode : 'isCustom\r\t^self customData notEmpty',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '155' ],		#self : OmReference [ '156' ],		#time : DateAndTime [ '2023-12-16T08:40:57.533813+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ExercismTest class',				#isMetaSide : true			},			#name : #solutionId,			#protocol : #accessing,			#sourceCode : 'solutionId\r\t^ solutionId ifNil: [ ExSolutionIdError signal: \'Missing exercise solutionId\' ]',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '156' ],		#self : OmReference [ '157' ],		#time : DateAndTime [ '2023-12-16T08:40:57.53393+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ExercismTest class',				#isMetaSide : true			},			#name : #'solutionId:',			#protocol : #accessing,			#sourceCode : 'solutionId: anObject\r\tsolutionId := anObject',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '157' ],		#self : OmReference [ '158' ],		#time : DateAndTime [ '2023-12-16T08:40:57.534052+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ExercismTest class',				#isMetaSide : true			},			#name : #uuid,			#protocol : #config,			#sourceCode : 'uuid\r\t"Answer a fixed String, the unique UUID for this exercise so the Exercism platform can identify it.\r\tThe id should be like: \'b5812b5e-2788-4ea6-b948-bfe54edeb0da\' "\r\t\r\t^self subclassResponsibility ',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '158' ],		#self : OmReference [ '159' ],		#time : DateAndTime [ '2023-12-16T08:40:57.534174+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ExercismTest class',				#isMetaSide : true			},			#name : #version,			#protocol : #config,			#sourceCode : 'version\r\t"Answer the exercise version number string this test was derived from"\r\t\r\t^self subclassResponsibility  ',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '159' ],		#self : OmReference [ '160' ],		#time : DateAndTime [ '2023-12-16T08:40:57.534307+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismTest,				#isMetaSide : false			},			#name : #'assert:closeEnoughTo:by:',			#protocol : #assertions,			#sourceCode : 'assert: aNumber closeEnoughTo: aNumber2 by: decimalPlaces\r\t"Assert that two numbers are the same when rounded to decimalPlaces places"\r\r\tself\r\t\tassert: (aNumber asFloat round: decimalPlaces)\r\t\tequals: (aNumber2 asFloat round: decimalPlaces)',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '160' ],		#self : OmReference [ '161' ],		#time : DateAndTime [ '2023-12-16T08:40:57.534518+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismTest,				#isMetaSide : false			},			#name : #'verifySolution:avoidsSelector:',			#protocol : #verify,			#sourceCode : 'verifySolution: aClass avoidsSelector: aSelector\r\t| badSelector |\r \r\tbadSelector := aClass methods detect: [ :m | m ast sentMessages includes: aSelector ] ifNone: [ ^self ].\r\t\r\tself fail: \'Your code in \', badSelector name, \' uses the library method #\', aSelector, \' - try writing a different solution that avoids it\'',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '161' ],		#self : OmReference [ '162' ],		#time : DateAndTime [ '2023-12-16T08:40:57.534833+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TextEntryDialogWindow,				#isMetaSide : false			},			#name : #'formattedText:',			#protocol : #'*ExercismTools',			#sourceCode : 'formattedText: formattedText\r\t"Set the text."\r\t"Derived from MessageDialogWindow>>text: but dont\' clear any formating"\r\tformattedText\r\t\taddAttribute: TextAlignment centered.\r\tself textMorph newContents: formattedText',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '162' ],		#self : OmReference [ '163' ],		#time : DateAndTime [ '2023-12-16T08:40:57.535177+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TextEntryDialogWindow,				#isMetaSide : false			},			#name : #'newText:',			#protocol : #'*ExercismTools',			#sourceCode : 'newText: aStringOrText\r\t"Answer a new text."\r\t"Overrides MessageDialog>>newText, but change from locked to disabled"\r\r\t^self theme\r\t\tnewStaticTextIn: self\r\t\ttext: aStringOrText',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '163' ],		#self : OmReference [ '164' ],		#time : DateAndTime [ '2023-12-16T08:40:57.535451+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RPackageTag,				#isMetaSide : false			},			#name : #definedClasses,			#protocol : #'*ExercismTools',			#sourceCode : 'definedClasses\r\t^ self classes',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '164' ],		#self : OmReference [ '165' ],		#time : DateAndTime [ '2023-12-16T08:40:57.535698+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RPackageTag,				#isMetaSide : false			},			#name : #exerciseName,			#protocol : #'*ExercismTools',			#sourceCode : 'exerciseName\r\t"Provided for legacy compatibility"\r\t^self name asString',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '165' ],		#self : OmReference [ '166' ],		#time : DateAndTime [ '2023-12-16T08:40:57.535952+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RPackageTag,				#isMetaSide : false			},			#name : #promoteAsExercismRPackage,			#protocol : #'*ExercismTools',			#sourceCode : 'promoteAsExercismRPackage\r\t"This method converts this rpackage tag into an rpackage compatible with exercism"\r\t|  tagName pkgName promotedName pkg |\r\t\r\ttagName := self name.\r\tpkgName := self packageName.\r\tpromotedName := self categoryName.\r\t\r\tself promoteAsRPackage.\r\t\r\tpkg := RPackageOrganizer default packageNamed: promotedName.\r\tpkg renameTo: pkgName, \'@\', tagName',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '166' ],		#self : OmReference [ '167' ],		#time : DateAndTime [ '2023-12-16T08:40:57.536188+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RPackageTag,				#isMetaSide : false			},			#name : #root,			#protocol : #'*ExercismTools',			#sourceCode : 'root\r\t^self package',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '167' ],		#self : OmReference [ '168' ],		#time : DateAndTime [ '2023-12-16T08:40:57.536435+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RPackageTag,				#isMetaSide : false			},			#name : #snapshot,			#protocol : #'*ExercismTools',			#sourceCode : 'snapshot\r\t| parentSnapshot |\r\t\r\tparentSnapshot := (MCPackage named: self package name) snapshot.\r\t\r\t^ MCSnapshot\r\t\tfromDefinitions:\r\t\t\t(parentSnapshot definitions\r\t\t\t\tselect:\r\t\t\t\t\t[ :mc | mc className isNil or: [ mc actualClass category endsWith: self name ] ])',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '168' ],		#self : OmReference [ '169' ],		#time : DateAndTime [ '2023-12-16T08:40:57.5368+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RPackage,				#isMetaSide : false			},			#name : #'exPrintOutExtensionsFor:on:',			#protocol : #'*ExercismTools',			#sourceCode : 'exPrintOutExtensionsFor: aClass on: aWriteStream\r\r\t| selectors |\r\t(selectors := self extensionSelectorsForClass: aClass) ifEmpty: [  ^self ].\r\t\r\taWriteStream \r\t\tnextPutAll: \'"-- #\'; \r\t\tnextPutAll: aClass name; \r\t\tnextPutAll: \' (extension) --"\'; \r\t\tcr; cr.\r\t\r\tselectors do: [ :sel |  \r\t\taClass exPrintOutMethod: sel on: aWriteStream ]',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '169' ],		#self : OmReference [ '170' ],		#time : DateAndTime [ '2023-12-16T08:40:57.537123+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RPackage,				#isMetaSide : false			},			#name : #exerciseName,			#protocol : #'*ExercismTools',			#sourceCode : 'exerciseName\r\t^ (self name allRegexMatches: \'\\w+\') last',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '170' ],		#self : OmReference [ '171' ],		#time : DateAndTime [ '2023-12-16T08:40:57.537437+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RPackage,				#isMetaSide : false			},			#name : #root,			#protocol : #'*ExercismTools',			#sourceCode : 'root\r\t^self',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '171' ],		#self : OmReference [ '172' ],		#time : DateAndTime [ '2023-12-16T08:40:57.537786+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RPackage,				#isMetaSide : false			},			#name : #snapshot,			#protocol : #'*ExercismTools',			#sourceCode : 'snapshot\r\t| pkgSnapshot extensions |\r\tpkgSnapshot := (MCPackage named: self name) snapshot.\r\t\r\textensions := self extensionMethods\r\t\tcollect: [ :extension | extension asRingDefinition asMCMethodDefinition  ].\r\t\t\r\t^ MCSnapshot fromDefinitions: pkgSnapshot definitions , extensions',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '172' ],		#self : OmReference [ '173' ],		#time : DateAndTime [ '2023-12-16T08:40:57.538122+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MorphicUIManager,				#isMetaSide : false			},			#name : #'requestText:initialAnswer:title:',			#protocol : #'*ExercismTools',			#sourceCode : 'requestText: formattedText initialAnswer: defaultAnswer title: aTitle\r\t"Derived from #request:initialAnswer:title: but only for formatted text not strings\r\tto avoid overriding formatting."\r\t\r\t"Create an instance of me whose question is queryString with the given \r\tinitial answer. Answer the string the user accepts.\r\tThe title serves for the window that is opened\r\tAnswer the empty string if the user cancels.\r\tAllow for interception with a ProvideAnswerNotification handler."\r\t\r\t|modalMorph|\r\t(ProvideAnswerNotification signal: formattedText) ifNotNil: [:answer |\r\t\t^answer == #default ifTrue: [defaultAnswer] ifFalse: [answer]].\r\tmodalMorph := self modalMorph.\r\t^(modalMorph theme \r\t\ttextEntryIn: modalMorph\r\t\tformattedText: formattedText\r\t\ttitle: aTitle\r\t\tentryText: defaultAnswer)',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '173' ],		#self : OmReference [ '174' ],		#time : DateAndTime [ '2023-12-16T08:40:57.538274+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClyExercismMenuGroup,				#isMetaSide : false			},			#name : #name,			#protocol : #accessing,			#sourceCode : 'name\r\t^\'Exercism\'',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '174' ],		#self : OmReference [ '175' ],		#time : DateAndTime [ '2023-12-16T08:40:57.538406+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClyExercismMenuGroup,				#isMetaSide : false			},			#name : #order,			#protocol : #accessing,			#sourceCode : 'order\r\t^1',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '175' ],		#self : OmReference [ '176' ],		#time : DateAndTime [ '2023-12-16T08:40:57.538551+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'MockExercismExercise class',				#isMetaSide : true			},			#name : #allExercises,			#protocol : #'instance creation',			#sourceCode : 'allExercises \r\r\t^ { TwoFerTest exercise } asOrderedCollection ',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '176' ],		#self : OmReference [ '177' ],		#time : DateAndTime [ '2023-12-16T08:40:57.538698+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ClyExercismCommand class',				#isMetaSide : true			},			#name : #'canBeExecutedInContext:',			#protocol : #activation,			#sourceCode : 'canBeExecutedInContext: aToolContext\r\t^ (super canBeExecutedInContext: aToolContext)\r\t\tand: [ self isExercismTagIn: aToolContext ]',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '177' ],		#self : OmReference [ '178' ],		#time : DateAndTime [ '2023-12-16T08:40:57.538833+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ClyExercismCommand class',				#isMetaSide : true			},			#name : #isAbstract,			#protocol : #testing,			#sourceCode : 'isAbstract\r\t\r\t^self == ClyExercismCommand',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '178' ],		#self : OmReference [ '179' ],		#time : DateAndTime [ '2023-12-16T08:40:57.538969+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ClyExercismCommand class',				#isMetaSide : true			},			#name : #'isExercismTagIn:',			#protocol : #testing,			#sourceCode : 'isExercismTagIn: aToolContext\r\t\r\t^false',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '179' ],		#self : OmReference [ '180' ],		#time : DateAndTime [ '2023-12-16T08:40:57.539103+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClyExercismCommand,				#isMetaSide : false			},			#name : #browser,			#protocol : #accessing,			#sourceCode : 'browser\r\t^ browser',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '180' ],		#self : OmReference [ '181' ],		#time : DateAndTime [ '2023-12-16T08:40:57.539229+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClyExercismCommand,				#isMetaSide : false			},			#name : #'browser:',			#protocol : #accessing,			#sourceCode : 'browser: anObject\r\tbrowser := anObject',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '181' ],		#self : OmReference [ '182' ],		#time : DateAndTime [ '2023-12-16T08:40:57.539364+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClyExercismCommand,				#isMetaSide : false			},			#name : #'prepareFullExecutionInContext:',			#protocol : #execution,			#sourceCode : 'prepareFullExecutionInContext: aToolContext\r\tsuper prepareFullExecutionInContext: aToolContext.\r\r\tself selectedItem: (self selectedItemIn: aToolContext).\r\tself browser: aToolContext tool',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '182' ],		#self : OmReference [ '183' ],		#time : DateAndTime [ '2023-12-16T08:40:57.539488+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClyExercismCommand,				#isMetaSide : false			},			#name : #selectedItem,			#protocol : #accessing,			#sourceCode : 'selectedItem\r\t^ selectedItem',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '183' ],		#self : OmReference [ '184' ],		#time : DateAndTime [ '2023-12-16T08:40:57.539614+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClyExercismCommand,				#isMetaSide : false			},			#name : #'selectedItem:',			#protocol : #accessing,			#sourceCode : 'selectedItem: anObject\r\tselectedItem := anObject',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '184' ],		#self : OmReference [ '185' ],		#time : DateAndTime [ '2023-12-16T08:40:57.539739+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClyExercismCommand,				#isMetaSide : false			},			#name : #'selectedItemIn:',			#protocol : #accessing,			#sourceCode : 'selectedItemIn: aToolContext\r\t^ aToolContext lastSelectedClassGroup',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '185' ],		#self : OmReference [ '186' ],		#time : DateAndTime [ '2023-12-16T08:40:57.539939+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ClyExercismExerciseCommand class',				#isMetaSide : true			},			#name : #contextMenuOrder,			#protocol : #activation,			#sourceCode : 'contextMenuOrder\r\t<classAnnotationDependency>\r\t\r\t\t^1',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '186' ],		#self : OmReference [ '187' ],		#time : DateAndTime [ '2023-12-16T08:40:57.540084+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ClyExercismExerciseCommand class',				#isMetaSide : true			},			#name : #isAbstract,			#protocol : #testing,			#sourceCode : 'isAbstract\r\t\r\t^self == ClyExercismExerciseCommand',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '187' ],		#self : OmReference [ '188' ],		#time : DateAndTime [ '2023-12-16T08:40:57.540231+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ClyExercismExerciseCommand class',				#isMetaSide : true			},			#name : #'isExercismTagIn:',			#protocol : #activation,			#sourceCode : 'isExercismTagIn: aToolContext\r\t^ aToolContext lastSelectedClassGroup name ~= ExercismManager legacyPackagePrefix\r\t\tand: [ aToolContext lastSelectedClassGroup classes\r\t\t\t\tdetect: [ :any | \r\t\t\t\t\t(any package name beginsWith: ExercismManager exercisePrefix , \'@\')\r\t\t\t\t\t\tor: [ (any package name beginsWith: ExercismManager legacyPackagePrefix , \'-\')\r\t\t\t\t\t\t\tor: [ any package name = ExercismManager legacyPackagePrefix ] ] ]\r\t\t\t\tifFound: [ true ]\r\t\t\t\tifNone: [ false ] ]',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '188' ],		#self : OmReference [ '189' ],		#time : DateAndTime [ '2023-12-16T08:40:57.540371+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ClyExercismExerciseCommand class',				#isMetaSide : true			},			#name : #packageContextMenuActivation,			#protocol : #activation,			#sourceCode : 'packageContextMenuActivation\r\t"We can use a second annotation to give a similar menu to the Package item"\r\t<classAnnotation>\r\t\r\t^ CmdContextMenuActivation\r\t\tbyItemOf: ClyExercismMenuGroup\r\t\torder: self contextMenuOrder\r\t\tfor: RPackage asCalypsoItemContext',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '189' ],		#self : OmReference [ '190' ],		#time : DateAndTime [ '2023-12-16T08:40:57.540504+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ClyExercismExerciseCommand class',				#isMetaSide : true			},			#name : #tagContextMenuActivation,			#protocol : #activation,			#sourceCode : 'tagContextMenuActivation\r\t<classAnnotation>\r\t\r\t^ CmdContextMenuActivation\r\t\tbyItemOf: ClyExercismMenuGroup\r\t\torder: self contextMenuOrder\r\t\tfor: ClyTaggedClassGroup asCalypsoItemContext',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '190' ],		#self : OmReference [ '191' ],		#time : DateAndTime [ '2023-12-16T08:40:57.540662+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClyExercismExerciseCommand,				#isMetaSide : false			},			#name : #'reportError:for:',			#protocol : #execution,			#sourceCode : 'reportError: anError for: exerciseId\r\t| msg |\r\r\tmsg := exerciseId\r\t\tifNil: [ anError messageText, \'!\' ]\r\t\tifNotNil: [ \r\t\t\t((Smalltalk hasClassNamed: exerciseId kebabAsCamelCase)\r\t\t\t\tifTrue:\r\t\t\t\t\t[ \'Exercise "{1}" is missing metadata! You need to upgrade it in Exercism and re-fetch!\' ]\r\t\t\t\tifFalse:\r\t\t\t\t\t[ \'Exercise "{1}" not found! Please check the Exercism website for valid exercises!\' ])\r\t\t\t\tformat: {exerciseId} ].\r\r\t^ UIManager default abort: msg',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '191' ],		#self : OmReference [ '192' ],		#time : DateAndTime [ '2023-12-16T08:40:57.540795+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ClyExercismFetchCommand class',				#isMetaSide : true			},			#name : #contextMenuOrder,			#protocol : #activation,			#sourceCode : 'contextMenuOrder\r\t\t^5',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '192' ],		#self : OmReference [ '193' ],		#time : DateAndTime [ '2023-12-16T08:40:57.593788+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ClyExercismFetchCommand class',				#isMetaSide : true			},			#name : #'worldMenuCommandOn:',			#protocol : #'world menu',			#sourceCode : 'worldMenuCommandOn: aBuilder\r\t<worldMenu>\r\t\r\t| templateCommand browser |\r\t\r\ttemplateCommand := self new \r\t\tpackages: { self package }; \r\t\tyourself.\r\t\r\t(aBuilder item: templateCommand defaultMenuItemName)\r\t\tparent: #Exercism;\r\t\torder: 1;\r\t\taction: [ \r\t\t\tbrowser := Smalltalk tools browser openOnPackage: ExercismManager.\r\t\t\ttemplateCommand browser: browser.\r\t\t\ttemplateCommand execute ];\r\t\ticonName: templateCommand defaultMenuIconName;\r\t\thelp: templateCommand description\r\t\t"withSeparatorAfter"',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '193' ],		#self : OmReference [ '194' ],		#time : DateAndTime [ '2023-12-16T08:40:57.594186+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClyExercismFetchCommand,				#isMetaSide : false			},			#name : #defaultMenuIconName,			#protocol : #accessing,			#sourceCode : 'defaultMenuIconName\r\t^#book',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '194' ],		#self : OmReference [ '195' ],		#time : DateAndTime [ '2023-12-16T08:40:57.5944+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClyExercismFetchCommand,				#isMetaSide : false			},			#name : #defaultMenuItemName,			#protocol : #accessing,			#sourceCode : 'defaultMenuItemName\r\t^\'Fetch new exercise...\'',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '195' ],		#self : OmReference [ '196' ],		#time : DateAndTime [ '2023-12-16T08:40:57.594553+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClyExercismFetchCommand,				#isMetaSide : false			},			#name : #description,			#protocol : #accessing,			#sourceCode : 'description \r\t^\'Fetch a named Exercism exercise to begin solving it\'',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '196' ],		#self : OmReference [ '197' ],		#time : DateAndTime [ '2023-12-16T08:40:57.594716+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClyExercismFetchCommand,				#isMetaSide : false			},			#name : #execute,			#protocol : #execution,			#sourceCode : 'execute\r\t| submission |\r\r\t[\r\t\tsubmission := ExercismManager default\r\t\t\tfetchFromExercismTo: self packages first.\r\t\t\t\r\t\tsubmission ifNotNil: [\r\t\t\tUIManager default inform: \'Success, Happy Coding\'.\r\t\t\tsubmission exercise \r\t\t\t\tifNil: [ \r\t\t\t\t\tExDomainError signal: \'Missing exercise meta-data\' ]\r\t\t\t\tifNotNil: [ :exercise |\r\t\t\t\t\tself browser selectClass: exercise testCase ]]\r\t ] \r\t\ton: ExDomainError do: [ :ex | \r\t\t\tself reportError: ex for: (submission ifNotNil: [ :s | s exerciseId ]) ]',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '197' ],		#self : OmReference [ '198' ],		#time : DateAndTime [ '2023-12-16T08:40:57.594865+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ClyExercismProgressCommand class',				#isMetaSide : true			},			#name : #contextMenuOrder,			#protocol : #activation,			#sourceCode : 'contextMenuOrder\r\t\t^15',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '198' ],		#self : OmReference [ '199' ],		#time : DateAndTime [ '2023-12-16T08:40:57.617465+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ClyExercismProgressCommand class',				#isMetaSide : true			},			#name : #'worldMenuCommandOn:',			#protocol : #'world menu',			#sourceCode : 'worldMenuCommandOn: aBuilder\r\t<worldMenu>\r\t\r\t| templateCommand |\r\t\r\ttemplateCommand := self new.\r\t(aBuilder item: templateCommand defaultMenuItemName)\r\t\tparent: #Exercism;\r\t\torder: 1;\r\t\taction: [ templateCommand execute ];\r\t\ticonName: templateCommand defaultMenuIconName;\r\t\thelp: templateCommand description;\r\t\twithSeparatorAfter',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '199' ],		#self : OmReference [ '200' ],		#time : DateAndTime [ '2023-12-16T08:40:57.617687+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClyExercismProgressCommand,				#isMetaSide : false			},			#name : #defaultMenuIconName,			#protocol : #accessing,			#sourceCode : 'defaultMenuIconName\r\t^#home',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '200' ],		#self : OmReference [ '201' ],		#time : DateAndTime [ '2023-12-16T08:40:57.617849+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClyExercismProgressCommand,				#isMetaSide : false			},			#name : #defaultMenuItemName,			#protocol : #accessing,			#sourceCode : 'defaultMenuItemName\r\t^\'View Track Progress\'',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '201' ],		#self : OmReference [ '202' ],		#time : DateAndTime [ '2023-12-16T08:40:57.617985+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClyExercismProgressCommand,				#isMetaSide : false			},			#name : #description,			#protocol : #accessing,			#sourceCode : 'description \r\t^\'Open your Exercism track progress in a web browser\'',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '202' ],		#self : OmReference [ '203' ],		#time : DateAndTime [ '2023-12-16T08:40:57.618116+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClyExercismProgressCommand,				#isMetaSide : false			},			#name : #execute,			#protocol : #execution,			#sourceCode : 'execute\r\tExercismManager default viewOnExercism: self selectedItem',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '203' ],		#self : OmReference [ '204' ],		#time : DateAndTime [ '2023-12-16T08:40:57.61826+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ClyExercismShareCommand class',				#isMetaSide : true			},			#name : #contextMenuOrder,			#protocol : #activation,			#sourceCode : 'contextMenuOrder\r\t\t^15',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '204' ],		#self : OmReference [ '205' ],		#time : DateAndTime [ '2023-12-16T08:40:57.618401+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ClyExercismShareCommand class',				#isMetaSide : true			},			#name : #hasConfirmedSharing,			#protocol : #accessing,			#sourceCode : 'hasConfirmedSharing\r\t^ hasConfirmedSharing ifNil: [ false ]',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '205' ],		#self : OmReference [ '206' ],		#time : DateAndTime [ '2023-12-16T08:40:57.618522+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ClyExercismShareCommand class',				#isMetaSide : true			},			#name : #'hasConfirmedSharing:',			#protocol : #accessing,			#sourceCode : 'hasConfirmedSharing: aBoolean\r\t^hasConfirmedSharing := aBoolean',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '206' ],		#self : OmReference [ '207' ],		#time : DateAndTime [ '2023-12-16T08:40:57.618668+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClyExercismShareCommand,				#isMetaSide : false			},			#name : #confirmSharing,			#protocol : #internal,			#sourceCode : 'confirmSharing\r\tself class hasConfirmedSharing\r\t\tifTrue: [ ^ true ].\r\t\t\r\t^ (UIManager default\r\t\tproceed:\r\t\t\t\'Please confirm you are happy to anonymously store your exercise code, on a temporary (7 day) random url at dpaste.com.\\Exercism and Pharo.org are not associated with this service, it is provided as a convenience to help users\\more easily discuss ideas with a wider community.\' withCRs)\r\t\tifTrue: [ self class hasConfirmedSharing: true ]\r\t\tifFalse: [ false ]',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '207' ],		#self : OmReference [ '208' ],		#time : DateAndTime [ '2023-12-16T08:40:57.618798+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClyExercismShareCommand,				#isMetaSide : false			},			#name : #defaultMenuIconName,			#protocol : #accessing,			#sourceCode : 'defaultMenuIconName\r\t^#publish',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '208' ],		#self : OmReference [ '209' ],		#time : DateAndTime [ '2023-12-16T08:40:57.618923+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClyExercismShareCommand,				#isMetaSide : false			},			#name : #defaultMenuItemName,			#protocol : #accessing,			#sourceCode : 'defaultMenuItemName\r\t^\'Share on web...\'',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '209' ],		#self : OmReference [ '210' ],		#time : DateAndTime [ '2023-12-16T08:40:57.619049+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClyExercismShareCommand,				#isMetaSide : false			},			#name : #description,			#protocol : #accessing,			#sourceCode : 'description \r\t^\'Create a web link to anonymously share your proposed solution on dpaste.com to discuss with others\'',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '210' ],		#self : OmReference [ '211' ],		#time : DateAndTime [ '2023-12-16T08:40:57.619202+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClyExercismShareCommand,				#isMetaSide : false			},			#name : #execute,			#protocol : #execution,			#sourceCode : 'execute\r\t| exerciseName result url |\r\r\texerciseName := self selectedItem exerciseName.\r\tself confirmSharing ifTrue: [ \r\t[ UIManager default \r\t\tinformUser: \'Sharing...\'\r\t\tduring: [\r\t\t\tresult := ExercismManager default\r\t\t\t\tshareExerciseDPaste: \r\t\t\t\t\t(ExercismExercise\r\t\t\t\t\t\tfind: exerciseName\r\t\t\t\t\t\tifAbsent: [ :name | ^ self reportError: nil for: name asKebabCase ])].\r\r\tresult\r\t\tifNotNil: [ \r\t\t\turl := result.\r\t\t\tUIManager default\r\t\t\t\tinform: (\'Successfully shared to: "{1}"!\' format: {url}).\r\t\t\tClipboard clipboardText: url.\r\t\t\tWebBrowser openOn: url.\r\t\t\t ] \r\t]\r\t\ton: ExercismError \r\t\tdo: [ :ex | self reportError: ex for: nil ] ]',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '211' ],		#self : OmReference [ '212' ],		#time : DateAndTime [ '2023-12-16T08:40:57.61933+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ClyExercismSubmitCommand class',				#isMetaSide : true			},			#name : #contextMenuOrder,			#protocol : #activation,			#sourceCode : 'contextMenuOrder\r\t\t^10',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '212' ],		#self : OmReference [ '213' ],		#time : DateAndTime [ '2023-12-16T08:40:57.619462+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClyExercismSubmitCommand,				#isMetaSide : false			},			#name : #defaultMenuIconName,			#protocol : #accessing,			#sourceCode : 'defaultMenuIconName\r\t^#smallExport',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '213' ],		#self : OmReference [ '214' ],		#time : DateAndTime [ '2023-12-16T08:40:57.619586+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClyExercismSubmitCommand,				#isMetaSide : false			},			#name : #defaultMenuItemName,			#protocol : #accessing,			#sourceCode : 'defaultMenuItemName\r\t^\'Submit exercise...\'',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '214' ],		#self : OmReference [ '215' ],		#time : DateAndTime [ '2023-12-16T08:40:57.619708+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClyExercismSubmitCommand,				#isMetaSide : false			},			#name : #description,			#protocol : #accessing,			#sourceCode : 'description \r\t^\'Sumbit your proposed solution to Exercism for mentor review\'',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '215' ],		#self : OmReference [ '216' ],		#time : DateAndTime [ '2023-12-16T08:40:57.619848+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClyExercismSubmitCommand,				#isMetaSide : false			},			#name : #execute,			#protocol : #execution,			#sourceCode : 'execute\r\t| exerciseName result |\r\r\texerciseName := self selectedItem exerciseName.\r\r\t[ result := ExercismManager default\r\t\tsubmitToExercism:\r\t\t\t(ExercismExercise\r\t\t\t\tfind: exerciseName\r\t\t\t\tifAbsent: [ :name | ^ self reportError: nil for: name asKebabCase ]).\r\r\tresult\r\t\tifNotNil: [ UIManager default\r\t\t\t\tinform: (\'Successfully submitted "{1}"!\' format: {exerciseName}) ] \r\t]\r\t\ton: ExercismError \r\t\tdo: [ :ex | self reportError: ex for: nil ]',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '216' ],		#self : OmReference [ '217' ],		#time : DateAndTime [ '2023-12-16T08:40:57.620018+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ExercismExercise class',				#isMetaSide : true			},			#name : #allExercises,			#protocol : #'instance creation',			#sourceCode : 'allExercises\r\t^ ExercismTest allSubclasses\r\t\tselect: [ :class | class class includesSelector: #exercise ]\r\t\tthenCollect: [ :class | class exercise ]',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '217' ],		#self : OmReference [ '218' ],		#time : DateAndTime [ '2023-12-16T08:40:57.620157+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ExercismExercise class',				#isMetaSide : true			},			#name : #bonusExercises,			#protocol : #'instance creation',			#sourceCode : 'bonusExercises\r\t"self bonusExercises"\r\r\t^ (self allExercises\r\t\treject:\r\t\t\t[ :exercise | exercise isCore or: [ exercise isActive not ] ])\r\t\tasSortedCollection: [ :a :b | a name < b name ]',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '218' ],		#self : OmReference [ '219' ],		#time : DateAndTime [ '2023-12-16T08:40:57.620287+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ExercismExercise class',				#isMetaSide : true			},			#name : #coreExercises,			#protocol : #'instance creation',			#sourceCode : 'coreExercises\r\t^(self allExercises select: [:e | e isCore and: [e isActive]])\r\t\tasSortedCollection: [ :a :b | a isFirst or: [a isFollowedBy: b ]]',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '219' ],		#self : OmReference [ '220' ],		#time : DateAndTime [ '2023-12-16T08:40:57.620414+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ExercismExercise class',				#isMetaSide : true			},			#name : #'exerciseNameFrom:',			#protocol : #'instance creation',			#sourceCode : 'exerciseNameFrom: packageOrTag\r\t"Answer the name of the exercise given its storage RPackage or tag"\t\r\t\t\r\t^($@ split: packageOrTag name) last asKebabCase.\r',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '220' ],		#self : OmReference [ '221' ],		#time : DateAndTime [ '2023-12-16T08:40:57.62055+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ExercismExercise class',				#isMetaSide : true			},			#name : #'find:ifAbsent:',			#protocol : #'instance creation',			#sourceCode : 'find: exercismName ifAbsent: aBlock\r\t| kebabedName |\r\r\tkebabedName := exercismName asKebabCase.\r\t^ self allExercises\r\t\tdetect: [ :ex | ex name = kebabedName ]\r\t\tifNone: [ aBlock cull: exercismName ]',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '221' ],		#self : OmReference [ '222' ],		#time : DateAndTime [ '2023-12-16T08:40:57.62068+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ExercismExercise class',				#isMetaSide : true			},			#name : #'for:',			#protocol : #'instance creation',			#sourceCode : 'for: anExercismTestCase\r\t^self new\r\t\ttestCase: anExercismTestCase;\r\t\tyourself',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '222' ],		#self : OmReference [ '223' ],		#time : DateAndTime [ '2023-12-16T08:40:57.620899+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismExercise,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= anObject\r\t"Answer whether the receiver and anObject represent the same object."\r\r\tself == anObject\r\t\tifTrue: [ ^ true ].\r\tself class = anObject class\r\t\tifFalse: [ ^ false ].\r\t^ self uuid = anObject uuid',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '223' ],		#self : OmReference [ '224' ],		#time : DateAndTime [ '2023-12-16T08:40:57.621071+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismExercise,				#isMetaSide : false			},			#name : #asJsonData,			#protocol : #converting,			#sourceCode : 'asJsonData\r\t"Answer a collection of attributes"\r\t\r\t^{ \'slug\' -> self name.\r\t\t\'uuid\' -> self uuid.\r\t\t\'core\' -> self isCore.\r\t\t\'auto_approve\' -> self isAutoApproved.\r\t\t\'unlocked_by\' -> self unlockReference.\r\t\t\'difficulty\' -> self difficulty.\r\t\t\'topics\' -> self topics } asOrderedDictionary ',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '224' ],		#self : OmReference [ '225' ],		#time : DateAndTime [ '2023-12-16T08:40:57.621213+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismExercise,				#isMetaSide : false			},			#name : #descriptionText,			#protocol : #accessing,			#sourceCode : 'descriptionText\r\t"Answer the String, that is the hint text for exerciems (this is the text afer the markdown heading ## Hint"\r\r\t| text offset |\r\ttext := self testCase comment.\r\t(offset := text findString: self hintMarker) = 0 ifTrue: [ ^ text ].\r\t\r\t^(text truncateTo: offset - 1) trimBoth\r\t',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '225' ],		#self : OmReference [ '226' ],		#time : DateAndTime [ '2023-12-16T08:40:57.621338+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismExercise,				#isMetaSide : false			},			#name : #difficulty,			#protocol : #accessing,			#sourceCode : 'difficulty\r\t^ difficulty',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '226' ],		#self : OmReference [ '227' ],		#time : DateAndTime [ '2023-12-16T08:40:57.621463+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismExercise,				#isMetaSide : false			},			#name : #'difficulty:',			#protocol : #accessing,			#sourceCode : 'difficulty: anInteger\r\tdifficulty := anInteger',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '227' ],		#self : OmReference [ '228' ],		#time : DateAndTime [ '2023-12-16T08:40:57.621593+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismExercise,				#isMetaSide : false			},			#name : #exerciseClass,			#protocol : #accessing,			#sourceCode : 'exerciseClass\r\t"Answer the main solution class, by convention this is the name of the exercise"\r\t\r\t^ self testCase\r\t\tifNil: [ nil ]\r\t\tifNotNil:\r\t\t\t[ :test | Smalltalk classNamed: self exerciseClassName ]',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '228' ],		#self : OmReference [ '229' ],		#time : DateAndTime [ '2023-12-16T08:40:57.621716+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismExercise,				#isMetaSide : false			},			#name : #exerciseClassName,			#protocol : #accessing,			#sourceCode : 'exerciseClassName \r\t^self testCase name withoutSuffix: \'Test\'',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '229' ],		#self : OmReference [ '230' ],		#time : DateAndTime [ '2023-12-16T08:40:57.62184+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismExercise,				#isMetaSide : false			},			#name : #exercisePackage,			#protocol : #accessing,			#sourceCode : 'exercisePackage\r\t^self testCase package',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '230' ],		#self : OmReference [ '231' ],		#time : DateAndTime [ '2023-12-16T08:40:57.621974+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismExercise,				#isMetaSide : false			},			#name : #exercisePackageContainer,			#protocol : #internal,			#sourceCode : 'exercisePackageContainer\r\t"Answer the package or legacy tag, that containts the exercise - must conform to #classes, #snapshot protocols"\r\t\r\t| pkg |\r\t\r\t^ (pkg := self exercisePackage) = ExercismManager legacyExercismPackage\r\t\tifTrue: [ pkg classTagForClass: self testCase ]\r\t\tifFalse: [ pkg ]',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '231' ],		#self : OmReference [ '232' ],		#time : DateAndTime [ '2023-12-16T08:40:57.62211+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismExercise,				#isMetaSide : false			},			#name : #followedBy,			#protocol : #navigating,			#sourceCode : 'followedBy\r"testcase : ^self unlockedBy ifNil: [\'\' ] ifNotNil: [ :parent | parent followedBy ]"\r\t^ self class coreExercises detect: [ :ex | ex isUnlockedBy: self ] ifNone: [  nil ]',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '232' ],		#self : OmReference [ '233' ],		#time : DateAndTime [ '2023-12-16T08:40:57.622264+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismExercise,				#isMetaSide : false			},			#name : #'gtInspectorDetailsIn:',			#protocol : #gt-inspector,			#sourceCode : 'gtInspectorDetailsIn: composite\r\t<gtInspectorPresentationOrder: 30>\r\t^ composite table\r\t\ttitle: \'Exercism\';\r\t\tdisplay: [ \r\t\t\t\t\t{\'exercise\' -> self name.\r\t\t\t\t\t\'core\' -> true.\r\t\t\t\t\t\'difficulty\' -> self difficulty.\r\t\t\t\t\t\'unlocks\' -> self unlockedExercises.\r\t\t\t\t\t\'topics\' -> self topics.\r\t\t\t\t\t\'tests\' -> self testCase.\r\t\t\t\t\t\'solution\' -> self exerciseClass.\r\t\t\t\t\t\'uuid\' -> self uuid.\r\t\t\t\t\t\'followed by\' -> self followedBy.\r\t\t\t\t\t\'hint\' -> self hintText.\r\t\t\t\t\t } ];\r\t\tcolumn: \'Property\' evaluated: #key;\r\t\tcolumn: \'Value\' evaluated: [:v | \r\t\t\tv key = \'unlocks\' ifTrue: [v value asCommaString ] ifFalse: [ v value ]];\r\t\tsend: #value',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '233' ],		#self : OmReference [ '234' ],		#time : DateAndTime [ '2023-12-16T08:40:57.622454+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismExercise,				#isMetaSide : false			},			#name : #hash,			#protocol : #comparing,			#sourceCode : 'hash\r\t"Answer an integer value that is related to the identity of the receiver."\r\r\t^ self class hash bitXor: self uuid hash',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '234' ],		#self : OmReference [ '235' ],		#time : DateAndTime [ '2023-12-16T08:40:57.622581+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismExercise,				#isMetaSide : false			},			#name : #hintMarker,			#protocol : #accessing,			#sourceCode : 'hintMarker\r\t^ \'## Hint\'',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '235' ],		#self : OmReference [ '236' ],		#time : DateAndTime [ '2023-12-16T08:40:57.622722+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismExercise,				#isMetaSide : false			},			#name : #hintText,			#protocol : #accessing,			#sourceCode : 'hintText\r\t"Answer the String, that is the hint text for exerciems (this is the text afer the markdown heading ## Hint"\r\r\t| hintIndex |\r\tself testCase comment\r\t\tifNotNil: [ :comment | \r\t\t\t| hintMarker |\r\t\t\thintMarker := self hintMarker.\r\t\t\thintIndex := comment findString: hintMarker.\r\t\t\thintIndex > 0\r\t\t\t\tifTrue: [ ^ (comment allButFirst: hintIndex + hintMarker size) trimBoth ] ].\r\t^ \'\'',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '236' ],		#self : OmReference [ '237' ],		#time : DateAndTime [ '2023-12-16T08:40:57.622847+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismExercise,				#isMetaSide : false			},			#name : #id,			#protocol : #accessing,			#sourceCode : 'id \r\t^self name',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '237' ],		#self : OmReference [ '238' ],		#time : DateAndTime [ '2023-12-16T08:40:57.622988+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismExercise,				#isMetaSide : false			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tsuper initialize.\r\tself\r\t\tisCore: false;\r\t\tisDeprecated: false;\r\t\tisAutoApproved: false;\r\t\ttopics: #()',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '238' ],		#self : OmReference [ '239' ],		#time : DateAndTime [ '2023-12-16T08:40:57.623122+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismExercise,				#isMetaSide : false			},			#name : #isActive,			#protocol : #accessing,			#sourceCode : 'isActive\r\t^self testCase isActive ',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '239' ],		#self : OmReference [ '240' ],		#time : DateAndTime [ '2023-12-16T08:40:57.62325+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismExercise,				#isMetaSide : false			},			#name : #isAutoApproved,			#protocol : #accessing,			#sourceCode : 'isAutoApproved\r\t^ isAutoApproved',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '240' ],		#self : OmReference [ '241' ],		#time : DateAndTime [ '2023-12-16T08:40:57.623383+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismExercise,				#isMetaSide : false			},			#name : #'isAutoApproved:',			#protocol : #accessing,			#sourceCode : 'isAutoApproved: anObject\r\tisAutoApproved := anObject',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '241' ],		#self : OmReference [ '242' ],		#time : DateAndTime [ '2023-12-16T08:40:57.623507+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismExercise,				#isMetaSide : false			},			#name : #isCore,			#protocol : #accessing,			#sourceCode : 'isCore\r\t^ isCore',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '242' ],		#self : OmReference [ '243' ],		#time : DateAndTime [ '2023-12-16T08:40:57.623633+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismExercise,				#isMetaSide : false			},			#name : #'isCore:',			#protocol : #accessing,			#sourceCode : 'isCore: aBoolean\r\tisCore := aBoolean',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '243' ],		#self : OmReference [ '244' ],		#time : DateAndTime [ '2023-12-16T08:40:57.623758+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismExercise,				#isMetaSide : false			},			#name : #isDefined,			#protocol : #accessing,			#sourceCode : 'isDefined\r\t^self exerciseClass notNil',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '244' ],		#self : OmReference [ '245' ],		#time : DateAndTime [ '2023-12-16T08:40:57.623882+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismExercise,				#isMetaSide : false			},			#name : #isDeprecated,			#protocol : #accessing,			#sourceCode : 'isDeprecated\r\t^ isDeprecated',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '245' ],		#self : OmReference [ '246' ],		#time : DateAndTime [ '2023-12-16T08:40:57.62401+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismExercise,				#isMetaSide : false			},			#name : #'isDeprecated:',			#protocol : #accessing,			#sourceCode : 'isDeprecated: anObject\r\tisDeprecated := anObject',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '246' ],		#self : OmReference [ '247' ],		#time : DateAndTime [ '2023-12-16T08:40:57.624134+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismExercise,				#isMetaSide : false			},			#name : #isEmpty,			#protocol : #accessing,			#sourceCode : 'isEmpty\r\t^self solutionClasses isEmpty',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '247' ],		#self : OmReference [ '248' ],		#time : DateAndTime [ '2023-12-16T08:40:57.624259+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismExercise,				#isMetaSide : false			},			#name : #isFirst,			#protocol : #comparing,			#sourceCode : 'isFirst\r\t^ self unlockedBy isNil',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '248' ],		#self : OmReference [ '249' ],		#time : DateAndTime [ '2023-12-16T08:40:57.624397+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismExercise,				#isMetaSide : false			},			#name : #'isFollowedBy:',			#protocol : #comparing,			#sourceCode : 'isFollowedBy: anExercismExercise\r\r\tself isFirst ifTrue: [ ^ self ~= anExercismExercise ].\r\tanExercismExercise isFirst ifTrue: [ ^ false ].\r\t\t\r\t^ (anExercismExercise isUnlockedBy: self)\r\t\tifTrue: [ true ]\r\t\tifFalse: [ self isFollowedBy: anExercismExercise unlockedBy ]',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '249' ],		#self : OmReference [ '250' ],		#time : DateAndTime [ '2023-12-16T08:40:57.624527+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismExercise,				#isMetaSide : false			},			#name : #'isUnlockedBy:',			#protocol : #comparing,			#sourceCode : 'isUnlockedBy: anExercise\r\t^ self unlockedBy\r\t\tifNil: [ false ]\r\t\tifNotNil: [ :exercise | exercise = anExercise ]',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '250' ],		#self : OmReference [ '251' ],		#time : DateAndTime [ '2023-12-16T08:40:57.62466+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismExercise,				#isMetaSide : false			},			#name : #name,			#protocol : #accessing,			#sourceCode : 'name \r\t^self exerciseClassName asKebabCase ',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '251' ],		#self : OmReference [ '252' ],		#time : DateAndTime [ '2023-12-16T08:40:57.624846+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismExercise,				#isMetaSide : false			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'printOn: aStream\r\t\r\taStream\r\t\tnextPutAll: \'Exercise(\';\r\t\tnextPutAll: self name.\r\tself isCore\r\t\tifTrue: [ aStream nextPut: $* ].\r\tself isDefined\r\t\tifTrue: [ aStream\r\t\t\t\tspace;\r\t\t\t\tprint: self difficulty ]\r\t\tifFalse: [ aStream nextPut: $? ].\r\taStream nextPut: $)',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '252' ],		#self : OmReference [ '253' ],		#time : DateAndTime [ '2023-12-16T08:40:57.624986+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismExercise,				#isMetaSide : false			},			#name : #removeSolutionClasses,			#protocol : #removing,			#sourceCode : 'removeSolutionClasses\r\t"Solution classes with implemented solution to be removed - utilized by TestRunner before importing student solution"\r\t\r\t^self solutionClasses do: [:solutionClass | solutionClass  removeFromSystem]',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '253' ],		#self : OmReference [ '254' ],		#time : DateAndTime [ '2023-12-16T08:40:57.625118+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismExercise,				#isMetaSide : false			},			#name : #snapshot,			#protocol : #accessing,			#sourceCode : 'snapshot\r\t"Answer the MCSnapshot for the exercise"\r\t\r\t^self exercisePackageContainer snapshot',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '254' ],		#self : OmReference [ '255' ],		#time : DateAndTime [ '2023-12-16T08:40:57.625254+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismExercise,				#isMetaSide : false			},			#name : #solutionClasses,			#protocol : #accessing,			#sourceCode : 'solutionClasses\r\t"Answer the classes that are submitted to Exercism"\r\t\r\t^self exercisePackageContainer classes reject: [ :c | c isKindOf: ExercismTest class ]',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '255' ],		#self : OmReference [ '256' ],		#time : DateAndTime [ '2023-12-16T08:40:57.625381+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismExercise,				#isMetaSide : false			},			#name : #solutionId,			#protocol : #accessing,			#sourceCode : 'solutionId\r\t^self testCase solutionId',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '256' ],		#self : OmReference [ '257' ],		#time : DateAndTime [ '2023-12-16T08:40:57.625569+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismExercise,				#isMetaSide : false			},			#name : #solutionSources,			#protocol : #accessing,			#sourceCode : 'solutionSources\r\t"Answer a Dictionary of filename to source code mappings for the solution that will be saved on Exercism. Exercism web interface displays files in order of upload."\r\t\r\t| packageFileMap testResult resultDictionary solutionClassNames solutionFileNames |\r\t\r\tpackageFileMap := ExTonelWriter new mappedSnapshot: self snapshot.\r\t\r\t"Exclude non-solution classes, i.e. filter out tests"\r\tsolutionClassNames := self solutionClasses collect: [ :c | c name ].\r\tsolutionFileNames := packageFileMap keys select: [ :filename | \r\t\tsolutionClassNames includes: (filename findTokens: \'.\') first ]. \r\r\t"Sort classes before extensions, then sort by class name"\r\tsolutionFileNames sort: [ :filenameA :filenameB | |tokensA tokensB|\r\t\ttokensA := filenameA findTokens: \'.\'.\r\t\ttokensB := filenameB findTokens: \'.\'.\r\t\t(tokensA second, tokensA first) < (tokensB second, tokensB first) ].\r\r\t"Summarise test results to show with solution"\r\ttestResult := [ self testCase suite run] on: Error do: [ TestResult new ].\r\t\r\t"Build result in the order we want files displayed by Exercism web interface"\r\tresultDictionary := OrderedDictionary new.\r\tsolutionFileNames do: [ :filename | \r\t\tresultDictionary at: filename put: ( packageFileMap at: filename) contents ].\r\tresultDictionary at: \'TestResults.txt\' put: testResult exercismSummary.\r\t^ resultDictionary\r',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '257' ],		#self : OmReference [ '258' ],		#time : DateAndTime [ '2023-12-16T08:40:57.625701+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismExercise,				#isMetaSide : false			},			#name : #'storeSolutionId:',			#protocol : #storing,			#sourceCode : 'storeSolutionId: anId\r\t^self testCase solutionId: anId',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '258' ],		#self : OmReference [ '259' ],		#time : DateAndTime [ '2023-12-16T08:40:57.62584+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismExercise,				#isMetaSide : false			},			#name : #testCase,			#protocol : #accessing,			#sourceCode : 'testCase\r\t^ testCase',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '259' ],		#self : OmReference [ '260' ],		#time : DateAndTime [ '2023-12-16T08:40:57.625969+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismExercise,				#isMetaSide : false			},			#name : #'testCase:',			#protocol : #accessing,			#sourceCode : 'testCase: anExercismTest\r\ttestCase := anExercismTest',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '260' ],		#self : OmReference [ '261' ],		#time : DateAndTime [ '2023-12-16T08:40:57.626095+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismExercise,				#isMetaSide : false			},			#name : #topics,			#protocol : #accessing,			#sourceCode : 'topics\r\t^ topics',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '261' ],		#self : OmReference [ '262' ],		#time : DateAndTime [ '2023-12-16T08:40:57.626223+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismExercise,				#isMetaSide : false			},			#name : #'topics:',			#protocol : #accessing,			#sourceCode : 'topics: aStringArray\r\ttopics := aStringArray',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '262' ],		#self : OmReference [ '263' ],		#time : DateAndTime [ '2023-12-16T08:40:57.626349+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismExercise,				#isMetaSide : false			},			#name : #trackId,			#protocol : #accessing,			#sourceCode : 'trackId\r\t^ExercismManager trackId',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '263' ],		#self : OmReference [ '264' ],		#time : DateAndTime [ '2023-12-16T08:40:57.626484+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismExercise,				#isMetaSide : false			},			#name : #unlockReference,			#protocol : #accessing,			#sourceCode : 'unlockReference\r\t"Answer the String unlock reference for a non-core exercise, otherwise nil"\r\r\t^ self isCore\r\t\tifTrue: [ nil ]\r\t\tifFalse: [ self unlockedBy ifNotNil: [:parent | parent name ]]',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '264' ],		#self : OmReference [ '265' ],		#time : DateAndTime [ '2023-12-16T08:40:57.62661+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismExercise,				#isMetaSide : false			},			#name : #unlockedBy,			#protocol : #accessing,			#sourceCode : 'unlockedBy\r\t^ unlockedBy ',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '265' ],		#self : OmReference [ '266' ],		#time : DateAndTime [ '2023-12-16T08:40:57.626739+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismExercise,				#isMetaSide : false			},			#name : #'unlockedBy:',			#protocol : #accessing,			#sourceCode : 'unlockedBy: anExercismExercise\r\tunlockedBy := anExercismExercise',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '266' ],		#self : OmReference [ '267' ],		#time : DateAndTime [ '2023-12-16T08:40:57.626869+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismExercise,				#isMetaSide : false			},			#name : #unlockedExercises,			#protocol : #accessing,			#sourceCode : 'unlockedExercises\r\t^self class bonusExercises select: [ :e | e isUnlockedBy: self ]',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '267' ],		#self : OmReference [ '268' ],		#time : DateAndTime [ '2023-12-16T08:40:57.626996+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismExercise,				#isMetaSide : false			},			#name : #uuid,			#protocol : #accessing,			#sourceCode : 'uuid\r\t^self testCase uuid',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '268' ],		#self : OmReference [ '269' ],		#time : DateAndTime [ '2023-12-16T08:40:57.627125+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismExercise,				#isMetaSide : false			},			#name : #verifySolutionForSubmission,			#protocol : #verifying,			#sourceCode : 'verifySolutionForSubmission\r\t<todo>',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '269' ],		#self : OmReference [ '270' ],		#time : DateAndTime [ '2023-12-16T08:40:57.627274+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismExercise,				#isMetaSide : false			},			#name : #version,			#protocol : #accessing,			#sourceCode : 'version\r\t^self testCase version',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '270' ],		#self : OmReference [ '271' ],		#time : DateAndTime [ '2023-12-16T08:40:57.627415+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismExercise,				#isMetaSide : false			},			#name : #wordifiedName,			#protocol : #accessing,			#sourceCode : 'wordifiedName\r\t"Answer the english readable name of the exercise"\r\r\t^ String\r\t\tstreamContents: [ :aStream | \r\t\t\tself exerciseClassName \r\t\t\t\tdoWithIndex: [ :char :i | \r\t\t\t\t\t(char isUppercase and: [ i > 1 ])\r\t\t\t\t\t\tifTrue: [ aStream space ].\r\t\t\t\t\taStream nextPut: char ] ]',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '271' ],		#self : OmReference [ '272' ],		#time : DateAndTime [ '2023-12-16T08:40:57.627551+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'STONJSONWriter class',				#isMetaSide : true			},			#name : #'on:',			#protocol : #'instance creation',			#sourceCode : 'on: writeStream\r\t^ (super on: writeStream)\r\t\t\tjsonMode: true;\r\t\t\tprettyPrint: true;\r\t\t\tnewLine: String lf;\r\t\t\tyourself',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '272' ],		#self : OmReference [ '273' ],		#time : DateAndTime [ '2023-12-16T08:40:57.627674+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'STONJSONWriter class',				#isMetaSide : true			},			#name : #'streamContentsOf:',			#protocol : #'instance creation',			#sourceCode : 'streamContentsOf: anObject\r\t"Answer a String, the results of streaming the writer contents for anObject (simple conveniance method)"\r\t\r\t^String streamContents: [ :stream |\r\t\t\t(self on: stream) nextPut: anObject ]',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '273' ],		#self : OmReference [ '274' ],		#time : DateAndTime [ '2023-12-16T08:40:57.627822+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #STONJSONWriter,				#isMetaSide : false			},			#name : #newlineIndent,			#protocol : #writing,			#sourceCode : 'newlineIndent\r\t"Override to adopt a json space identation convention"\r\r\tprettyPrint\r\t\tifTrue: [ writeStream nextPutAll: newLine.\r\t\t\tlevel timesRepeat: [ writeStream space: 2 ] ]',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '274' ],		#self : OmReference [ '275' ],		#time : DateAndTime [ '2023-12-16T08:40:57.627947+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #STONJSONWriter,				#isMetaSide : false			},			#name : #'writeAssociation:',			#protocol : #writing,			#sourceCode : 'writeAssociation: association\r\t"Overriden to support associations"\r\t\r\tself \r\t\tencodeKey: association key \r\t\tvalue: association value',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '275' ],		#self : OmReference [ '276' ],		#time : DateAndTime [ '2023-12-16T08:40:57.628079+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #STONJSONWriter,				#isMetaSide : false			},			#name : #'writeObject:do:',			#protocol : #writing,			#sourceCode : 'writeObject: anObject do: block\r\t"Overridden to support Collections and Dictionaries"\r\t\r\tjsonMode ifTrue: [ \r\t\t(anObject isKindOf: OrderedCollection)\r\t\t\tifTrue: [ ^self writeList: anObject ].\r\t\t(anObject isKindOf: OrderedDictionary)\r\t\t\tifTrue: [ ^self writeMap: anObject ].\r\t\t(anObject isKindOf: Dictionary)\r\t\t\tifTrue: [ ^self writeMap: anObject asOrderedDictionary ]].\r\t\t\r\tsuper writeObject: anObject do: block ',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '276' ],		#self : OmReference [ '277' ],		#time : DateAndTime [ '2023-12-16T08:40:57.628216+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ExUnauthorized class',				#isMetaSide : true			},			#name : #'signalBadToken:',			#protocol : #instance-creation,			#sourceCode : 'signalBadToken: tokenStringOrNil\r\t^ self new\r\t\ttoken: tokenStringOrNil;\r\t\tsignal',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '277' ],		#self : OmReference [ '278' ],		#time : DateAndTime [ '2023-12-16T08:40:57.628345+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExUnauthorized,				#isMetaSide : false			},			#name : #token,			#protocol : #accessing,			#sourceCode : 'token\r\t^ token',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '278' ],		#self : OmReference [ '279' ],		#time : DateAndTime [ '2023-12-16T08:40:57.628453+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExUnauthorized,				#isMetaSide : false			},			#name : #'token:',			#protocol : #accessing,			#sourceCode : 'token: anObject\r\ttoken := anObject',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '279' ],		#self : OmReference [ '280' ],		#time : DateAndTime [ '2023-12-16T08:40:57.628596+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismHintRule,				#isMetaSide : false			},			#name : #group,			#protocol : #accessing,			#sourceCode : 'group\r\t^\'Exercism Hint\'',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '280' ],		#self : OmReference [ '281' ],		#time : DateAndTime [ '2023-12-16T08:40:57.628725+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismHintRule,				#isMetaSide : false			},			#name : #severity,			#protocol : #accessing,			#sourceCode : 'severity\r\t^ #warning\r',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '281' ],		#self : OmReference [ '282' ],		#time : DateAndTime [ '2023-12-16T08:40:57.629024+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'TonelReader class',				#isMetaSide : true			},			#name : #'fromExerciseDirectory:',			#protocol : #'*ExercismTools',			#sourceCode : 'fromExerciseDirectory: aDirectory\r\r\t"set exercise directory where all source files of exercise occur"\r\r\t^ self new\r\t\texerciseDirectory: aDirectory;\r\t\tyourself ',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '282' ],		#self : OmReference [ '283' ],		#time : DateAndTime [ '2023-12-16T08:40:57.629277+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TonelReader,				#isMetaSide : false			},			#name : #'exerciseDirectory:',			#protocol : #'*ExercismTools',			#sourceCode : 'exerciseDirectory: aDirReference\r\r\tpackageDirectory := aDirReference',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '283' ],		#self : OmReference [ '284' ],		#time : DateAndTime [ '2023-12-16T08:40:57.629561+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExTonelWriter,				#isMetaSide : false			},			#name : #'mappedSnapshot:',			#protocol : #'*ExercismTools',			#sourceCode : 'mappedSnapshot: aSnapshot\r\t"extracted from #writeSnapshot: to customise behavior"\r\t\r\t|tonelMap extensionDefinitions|\r\tsnapshot := aSnapshot.\r\ttonelMap := Dictionary new.\r\t\t\r\t"Tonel export classes with their methods, mapped from their filename to content streams"\r\t(snapshot definitions select: #isClassDefinition)\r\t\tdo: [ :classDef |  |filename tonelStream|\r\t\t\tfilename := classDef exTonelFilename.\r\t\t\ttonelStream := WriteStream on: String new.\r\t \t\tself writeClass: classDef on: tonelStream.\r\t  \t\ttonelMap at: filename put: tonelStream ].\r\t\r\t"... and method extensions"\r\textensionDefinitions := (snapshot definitions select: [ :each | \r\t\teach isMethodDefinition and: [ each isExtensionMethod ] ]) removeDuplicates.\r\r\textensionDefinitions do: [ :methodDef | |filename|\r\t\tfilename := methodDef exTonelFilename.\r\t\ttonelMap at: filename ifAbsentPut: [ \r\t\t\t(WriteStream on: String new) nextPutAll: \'Extension { #name : #\', methodDef className, \' }\' ; lf; yourself ].\r\t\tself writeMethodDefinition: methodDef on: (tonelMap at: filename). \r\t\t].\r\t^tonelMap\r',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '284' ],		#self : OmReference [ '285' ],		#time : DateAndTime [ '2023-12-16T08:40:57.6297+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExTonelWriter,				#isMetaSide : false			},			#name : #'obtainPackageDir:',			#protocol : #private,			#sourceCode : 'obtainPackageDir: aDefinition\r\t"Overridden to allow a specific directory to be supplied"\r\t\r\t^self sourceDirectory ifNil: [ super obtainPackageDir: aDefinition ]',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '285' ],		#self : OmReference [ '286' ],		#time : DateAndTime [ '2023-12-16T08:40:57.629812+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExTonelWriter,				#isMetaSide : false			},			#name : #sourceDirectory,			#protocol : #accessing,			#sourceCode : 'sourceDirectory\r\t^ sourceDirectory',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '286' ],		#self : OmReference [ '287' ],		#time : DateAndTime [ '2023-12-16T08:40:57.629921+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExTonelWriter,				#isMetaSide : false			},			#name : #'sourceDirectory:',			#protocol : #accessing,			#sourceCode : 'sourceDirectory: anObject\r\tsourceDirectory := anObject',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '287' ],		#self : OmReference [ '288' ],		#time : DateAndTime [ '2023-12-16T08:40:57.630159+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExTonelWriter,				#isMetaSide : false			},			#name : #'writeClass:on:',			#protocol : #'*ExercismTools',			#sourceCode : 'writeClass: aClassDefinition on: aStream\r\t"Not clear on whether this is an override and still needed? ~tma~"\r\t\r\tself writeClassDefinition: aClassDefinition on: aStream.\r\tself writeClassSideMethodDefinitions: aClassDefinition on: aStream.\r\tself writeInstanceSideMethodDefinitions: aClassDefinition on: aStream ',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '288' ],		#self : OmReference [ '289' ],		#time : DateAndTime [ '2023-12-16T08:40:57.63039+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TonelParser,				#isMetaSide : false			},			#name : #'documentFrom:',			#protocol : #'*ExercismTools',			#sourceCode : 'documentFrom: aString\r\tself stream: aString readStream.\r\t^self document',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '289' ],		#self : OmReference [ '290' ],		#time : DateAndTime [ '2023-12-16T08:40:57.630609+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #StaticTextMorph,				#isMetaSide : false			},			#name : #enabled,			#protocol : #testing,			#sourceCode : 'enabled\r\t^false',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '290' ],		#self : OmReference [ '291' ],		#time : DateAndTime [ '2023-12-16T08:40:57.630747+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ExercismHttpClient class',				#isMetaSide : true			},			#name : #'configureToken:',			#protocol : #accessing,			#sourceCode : 'configureToken: your_CLI_token\r    "Get your_CLI_token at https://exercism.io/my/settings"\r    ApiToken := your_CLI_token',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '291' ],		#self : OmReference [ '292' ],		#time : DateAndTime [ '2023-12-16T08:40:57.630863+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ExercismHttpClient class',				#isMetaSide : true			},			#name : #hasToken,			#protocol : #testing,			#sourceCode : 'hasToken\r    ^ApiToken notNil ',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '292' ],		#self : OmReference [ '293' ],		#time : DateAndTime [ '2023-12-16T08:40:57.630971+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ExercismHttpClient class',				#isMetaSide : true			},			#name : #hostName,			#protocol : #accessing,			#sourceCode : 'hostName\r\t^ \'api.exercism.io\'',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '293' ],		#self : OmReference [ '294' ],		#time : DateAndTime [ '2023-12-16T08:40:57.631126+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ExercismHttpClient class',				#isMetaSide : true			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'new\r\t^self newHost: self hostName',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '294' ],		#self : OmReference [ '295' ],		#time : DateAndTime [ '2023-12-16T08:40:57.631243+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ExercismHttpClient class',				#isMetaSide : true			},			#name : #'newHost:',			#protocol : #'instance creation',			#sourceCode : 'newHost: hostName\r\r\t^self basicNew\r\t\tinitialize;\r\t\thostName: hostName;\r\t\tyourself\r',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '295' ],		#self : OmReference [ '296' ],		#time : DateAndTime [ '2023-12-16T08:40:57.63139+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ExercismHttpClient class',				#isMetaSide : true			},			#name : #promptForToken,			#protocol : #caching,			#sourceCode : 'promptForToken\r\t| url linkText requestText initialAnswer title newToken  |\r\turl := \'https://exercism.org/settings/api_cli\'.\r\t\r\tlinkText := url asText\r\t\taddAttribute: (TextAction new actOnClickBlock: [WebBrowser openOn: url]);\r\t\taddAttribute: TextColor blue;\r\t\taddAttribute: TextEmphasis underlined.\r\t\t\r  \trequestText := \'CLI token available at  \' asText, linkText.\r\tinitialAnswer := ApiToken ifNil: [ \'\' ]. \r\ttitle := (initialAnswer ifEmpty: [ \'\' ] ifNotEmpty: [ \'Unauthorized or Invalid token. \' ]) , \r\t\t\'Please enter your Exercism student token\'.\r\t\t\r\tnewToken := MorphicUIManager default requestText: requestText initialAnswer: initialAnswer title: title.\r\tnewToken ifNil: [ ^false ].\r\t(newToken = ApiToken)  ifTrue: [ ^false ].\r\t\r\tExercismHttpClient configureToken: newToken.\r\t^true "retry"',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '296' ],		#self : OmReference [ '297' ],		#time : DateAndTime [ '2023-12-16T08:40:57.631499+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ExercismHttpClient class',				#isMetaSide : true			},			#name : #reset,			#protocol : #caching,			#sourceCode : 'reset\r\tApiToken := nil\r\t',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '297' ],		#self : OmReference [ '298' ],		#time : DateAndTime [ '2023-12-16T08:40:57.631607+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ExercismHttpClient class',				#isMetaSide : true			},			#name : #solutionPath,			#protocol : #accessing,			#sourceCode : 'solutionPath\r    ^\'/v1/solutions\'',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '298' ],		#self : OmReference [ '299' ],		#time : DateAndTime [ '2023-12-16T08:40:57.631715+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ExercismHttpClient class',				#isMetaSide : true			},			#name : #token,			#protocol : #accessing,			#sourceCode : 'token\r\t^ ApiToken ifNil: [  \'not-configured\' ]',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '299' ],		#self : OmReference [ '300' ],		#time : DateAndTime [ '2023-12-16T08:40:57.631828+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ExercismHttpClient class',				#isMetaSide : true			},			#name : #verifyToken,			#protocol : #testing,			#sourceCode : 'verifyToken\r\tself hasToken ifFalse: [ ExUnauthorized signal ].\r\t^ true',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '300' ],		#self : OmReference [ '301' ],		#time : DateAndTime [ '2023-12-16T08:40:57.631965+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismHttpClient,				#isMetaSide : false			},			#name : #'addFormEntity:data:',			#protocol : #internal,			#sourceCode : 'addFormEntity: fieldName data: dataDictionary \r\t| multiPartFormDataEntity solutionEntity solutionPart |\r\t\r\tmultiPartFormDataEntity := ZnMultiPartFormDataEntity new.\r\r\tdataDictionary keysAndValuesDo: [ :key :value| \r\t\tsolutionEntity := ZnByteArrayEntity bytes: value.\r\t\tsolutionPart := ZnMimePart exercismFieldName: fieldName \r\t\t\t\tfileName: key entity: solutionEntity.\r\t\t\t\t\r\t\tmultiPartFormDataEntity addPart: solutionPart ].\r\t\t\r\tself zincClient entity: multiPartFormDataEntity \r',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '301' ],		#self : OmReference [ '302' ],		#time : DateAndTime [ '2023-12-16T08:40:57.632078+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismHttpClient,				#isMetaSide : false			},			#name : #createZnClient,			#protocol : #internal,			#sourceCode : 'createZnClient\r\t^ ZnClient new\r\t\thttps;\r\t\thost: self hostName;\r\t\tyourself',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '302' ],		#self : OmReference [ '303' ],		#time : DateAndTime [ '2023-12-16T08:40:57.632191+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismHttpClient,				#isMetaSide : false			},			#name : #get,			#protocol : #internal,			#sourceCode : 'get\r\t"Answer the result of an HTTP GET command, thows an Exception if 401 response"\r\r\t| result |\r\r\tresult := self zincClient get.\r\r\tself responseCode = 401\r\t\tifTrue: [ self signalUnauthorized ].\r\r\t^ result',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '303' ],		#self : OmReference [ '304' ],		#time : DateAndTime [ '2023-12-16T08:40:57.632305+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismHttpClient,				#isMetaSide : false			},			#name : #'getLatestExercise:for:',			#protocol : #public,			#sourceCode : 'getLatestExercise: exerciseId for: trackName\r\r\t^self getResource: (self solutionPathFor: \'/latest\') with: {\r\t\t\'track_id\'-> trackName.\r\t\t\'exercise_id\' -> exerciseId }',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '304' ],		#self : OmReference [ '305' ],		#time : DateAndTime [ '2023-12-16T08:40:57.632414+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismHttpClient,				#isMetaSide : false			},			#name : #'getResource:',			#protocol : #public,			#sourceCode : 'getResource: filePath\r\r\t^ self getResource: filePath with: #()',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '305' ],		#self : OmReference [ '306' ],		#time : DateAndTime [ '2023-12-16T08:40:57.632525+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismHttpClient,				#isMetaSide : false			},			#name : #'getResource:with:',			#protocol : #public,			#sourceCode : 'getResource: filePath with: queryMap\r\r\tself path: filePath.\r\t\r\tqueryMap asDictionary keysAndValuesDo: [ :key :value |\r\t\tself queryAt: key put: value  ].\r\t\r\t^ self get',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '306' ],		#self : OmReference [ '307' ],		#time : DateAndTime [ '2023-12-16T08:40:57.632633+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismHttpClient,				#isMetaSide : false			},			#name : #'getSpecifiedExercise:',			#protocol : #public,			#sourceCode : 'getSpecifiedExercise: uuid\r\r\t^self getResource: (self solutionPathFor: uuid) ',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '307' ],		#self : OmReference [ '308' ],		#time : DateAndTime [ '2023-12-16T08:40:57.632745+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismHttpClient,				#isMetaSide : false			},			#name : #hostName,			#protocol : #accessing,			#sourceCode : 'hostName\r\t^ hostName',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '308' ],		#self : OmReference [ '309' ],		#time : DateAndTime [ '2023-12-16T08:40:57.634926+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismHttpClient,				#isMetaSide : false			},			#name : #'hostName:',			#protocol : #accessing,			#sourceCode : 'hostName: hostNameString\r\thostName := hostNameString',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '309' ],		#self : OmReference [ '310' ],		#time : DateAndTime [ '2023-12-16T08:40:57.635087+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismHttpClient,				#isMetaSide : false			},			#name : #parameterString,			#protocol : #internal,			#sourceCode : 'parameterString\r\t^ String\r\t\tstreamContents: [ :s | \r\t\t\tself zincClient request requestLine uri query \r\t\t\tifNotNil: [ :q |\r\t\t\t\tq associations do: [ :params | \r\t\t\t\t\ts\r\t\t\t\t\t\tnextPutAll: params key asString;\r\t\t\t\t\t\tnextPutAll: \': \';\r\t\t\t\t\t\tnextPutAll: params value ] \r\t\t\t\tseparatedBy: [ s nextPutAll: \', \' ]]]',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '310' ],		#self : OmReference [ '311' ],		#time : DateAndTime [ '2023-12-16T08:40:57.635233+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismHttpClient,				#isMetaSide : false			},			#name : #patch,			#protocol : #internal,			#sourceCode : 'patch\r\t| response status statusCode successCodes |\r\t\r\tresponse := self zincClient patch.\r\t\r\tstatus := self zincClient response statusLine.\r\tstatusCode := self responseCode.\r\t\r\tsuccessCodes := {201 -> \'SUCCESS\'. 400 -> \'NO CHANGES\'} asDictionary.\r\t\r\t(successCodes includesKey: statusCode)\r\t\tifTrue: [ \r\t\t\t\tself inform: \'Exercism Submit - \' , (successCodes at: statusCode) value. \r\t\t\t\t^response ].\r\t\t\r\tstatusCode = 401 ifTrue: [ \r\t\tExUnauthorized signalBadToken: ApiToken ].\r\t\r\tself error:\r\t\t\t\'Exercism Submit - UNKNOWN ERROR (\' , \r\t\t\tstatusCode printString, \' \' , status reason , \')\'',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '311' ],		#self : OmReference [ '312' ],		#time : DateAndTime [ '2023-12-16T08:40:57.635356+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismHttpClient,				#isMetaSide : false			},			#name : #'patchSolution:with:',			#protocol : #public,			#sourceCode : 'patchSolution: solutionIdString with: solutionDataMap\r\t\r\t^self\r\t\tpath: (self solutionPathFor: solutionIdString);\r\t\taddFormEntity: \'files[]\' data: solutionDataMap;\r\t\tpatch',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '312' ],		#self : OmReference [ '313' ],		#time : DateAndTime [ '2023-12-16T08:40:57.635472+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismHttpClient,				#isMetaSide : false			},			#name : #'path:',			#protocol : #internal,			#sourceCode : 'path: aString\r\tself zincClient path: aString\r',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '313' ],		#self : OmReference [ '314' ],		#time : DateAndTime [ '2023-12-16T08:40:57.635598+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismHttpClient,				#isMetaSide : false			},			#name : #post,			#protocol : #internal,			#sourceCode : 'post\r\t"Answer the result of an HTTP GET command, thows an Exception if 401 response"\r\r\t| result |\r\r\tresult := self zincClient post.\r\r\tself responseCode = 401\r\t\tifTrue: [ self signalUnauthorized ].\r\r\t^ result',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '314' ],		#self : OmReference [ '315' ],		#time : DateAndTime [ '2023-12-16T08:40:57.635713+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismHttpClient,				#isMetaSide : false			},			#name : #promptForToken,			#protocol : #internal,			#sourceCode : 'promptForToken \r\t^self class promptForToken',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '315' ],		#self : OmReference [ '316' ],		#time : DateAndTime [ '2023-12-16T08:40:57.635831+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismHttpClient,				#isMetaSide : false			},			#name : #'queryAt:put:',			#protocol : #internal,			#sourceCode : 'queryAt: stringId put: stringValue\r\tself zincClient queryAt: stringId put: stringValue\r\t\t',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '316' ],		#self : OmReference [ '317' ],		#time : DateAndTime [ '2023-12-16T08:40:57.635947+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismHttpClient,				#isMetaSide : false			},			#name : #responseCode,			#protocol : #public,			#sourceCode : 'responseCode\r\t^ self zincClient response code',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '317' ],		#self : OmReference [ '318' ],		#time : DateAndTime [ '2023-12-16T08:40:57.636062+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismHttpClient,				#isMetaSide : false			},			#name : #signalUnauthorized,			#protocol : #internal,			#sourceCode : 'signalUnauthorized\r\tExUnauthorized signalBadToken: ApiToken',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '318' ],		#self : OmReference [ '319' ],		#time : DateAndTime [ '2023-12-16T08:40:57.636196+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismHttpClient,				#isMetaSide : false			},			#name : #'solutionPathFor:',			#protocol : #internal,			#sourceCode : 'solutionPathFor: aString\r\t"Answer a path string that accounts for missing or extra / path characters"\r\t\r\t^ String\r\t\tstreamContents: [ :s | \r\t\t\ts\r\t\t\t\tnextPutAll: self class solutionPath exPathString;\r\t\t\t\tnextPutAll:\r\t\t\t\t\t(aString first = Path delimiter\r\t\t\t\t\t\tifTrue: [ aString allButFirst ]\r\t\t\t\t\t\tifFalse: [ aString ]) ]',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '319' ],		#self : OmReference [ '320' ],		#time : DateAndTime [ '2023-12-16T08:40:57.636313+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismHttpClient,				#isMetaSide : false			},			#name : #'username:password:',			#protocol : #internal,			#sourceCode : 'username: nameString password: pwdString\r\tself zincClient username: nameString password: pwdString\r',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '320' ],		#self : OmReference [ '321' ],		#time : DateAndTime [ '2023-12-16T08:40:57.636425+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismHttpClient,				#isMetaSide : false			},			#name : #verifyToken,			#protocol : #public,			#sourceCode : 'verifyToken\r\t^ self class verifyToken',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '321' ],		#self : OmReference [ '322' ],		#time : DateAndTime [ '2023-12-16T08:40:57.636544+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismHttpClient,				#isMetaSide : false			},			#name : #zincClient,			#protocol : #accessing,			#sourceCode : 'zincClient\r\t^ (zincClient ifNil: [ zincClient := self createZnClient ])\r\t\theaderAt: \'Authorization\' put: \'Bearer \' , self class token;\r\t\tyourself',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '322' ],		#self : OmReference [ '323' ],		#time : DateAndTime [ '2023-12-16T08:40:57.63668+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ExercismDownloadCommand class',				#isMetaSide : true			},			#name : #'from:track:exercise:',			#protocol : #command,			#sourceCode : 'from: aClient track: trackId exercise: exerciseId\r\t^(self client: aClient)\r\t\ttrack: trackId exercise: exerciseId;\r\t\tyourself',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '323' ],		#self : OmReference [ '324' ],		#time : DateAndTime [ '2023-12-16T08:40:57.636803+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ExercismDownloadCommand class',				#isMetaSide : true			},			#name : #'track:exercise:',			#protocol : #command,			#sourceCode : 'track: trackId exercise: exerciseId\r\t^ self from: ExercismHttpClient new track: trackId exercise: exerciseId',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '324' ],		#self : OmReference [ '325' ],		#time : DateAndTime [ '2023-12-16T08:40:57.636954+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismDownloadCommand,				#isMetaSide : false			},			#name : #execute,			#protocol : #execution,			#sourceCode : 'execute\r\t^ self\r\t\texecuteCheckingToken: [ | submission |\r\t\t\t\r\t\t\tsubmission := self fetchLatestSubmission.\r\t\t\tself fetchExerciseFilesFor: submission. \r\t\t\tself installExerciseFor: submission.\r\t\t\tsubmission storeSolutionId.\r\r\t\t\tsubmission ]',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '325' ],		#self : OmReference [ '326' ],		#time : DateAndTime [ '2023-12-16T08:40:57.637084+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismDownloadCommand,				#isMetaSide : false			},			#name : #'installExerciseFor:',			#protocol : #internal,			#sourceCode : 'installExerciseFor: submission\r\t\r\t"submission will put sources to memory directory and load definitions from snapshot"\r\tsubmission installDefinitionsFromSnapshot.\r\r\tSystemAnnouncer uniqueInstance\r\t\tannounce: (RPackageRegistered to: submission exercise exercisePackage).\r\t',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '326' ],		#self : OmReference [ '327' ],		#time : DateAndTime [ '2023-12-16T08:40:57.637221+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismDownloadCommand,				#isMetaSide : false			},			#name : #retrieveLatestData,			#protocol : #internal,			#sourceCode : 'retrieveLatestData\r\t| responseString |\r\t\t\r\tresponseString := self httpClient getLatestExercise: exerciseId for: trackName.\r\t^ STON fromString: responseString',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '327' ],		#self : OmReference [ '328' ],		#time : DateAndTime [ '2023-12-16T08:40:57.63734+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismDownloadCommand,				#isMetaSide : false			},			#name : #'track:exercise:',			#protocol : #accessing,			#sourceCode : 'track: aStringTrackName exercise: aStringExerciseId\r\ttrackName := aStringTrackName.\r\texerciseId := aStringExerciseId asKebabCase.',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '328' ],		#self : OmReference [ '329' ],		#time : DateAndTime [ '2023-12-16T08:40:57.63747+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismFetchCommand,				#isMetaSide : false			},			#name : #'fetchExerciseFilesFor:',			#protocol : #internal,			#sourceCode : 'fetchExerciseFilesFor: submission\r\r\tsubmission\r\t\tpopulateFileContentsWith: [ :filename | self httpClient getResource: filename ]',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '329' ],		#self : OmReference [ '330' ],		#time : DateAndTime [ '2023-12-16T08:40:57.637601+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismFetchCommand,				#isMetaSide : false			},			#name : #fetchLatestSubmission,			#protocol : #internal,			#sourceCode : 'fetchLatestSubmission\r\t| response |\r\t\r\tresponse := self retrieveLatestData.\r\t\r\tresponse\r\t\tat: \'error\'\r\t\tifPresent: [ :error | ExDomainError signal: (error at: \'message\'), (\' ({1})\' format: {self httpClient parameterString} ) ].\r\t\t\r\t^ExercismSubmission data: response',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '330' ],		#self : OmReference [ '331' ],		#time : DateAndTime [ '2023-12-16T08:40:57.637721+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismFetchCommand,				#isMetaSide : false			},			#name : #retrieveLatestData,			#protocol : #internal,			#sourceCode : 'retrieveLatestData\r\t^self subclassResponsibility ',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '331' ],		#self : OmReference [ '332' ],		#time : DateAndTime [ '2023-12-16T08:40:57.637853+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ExercismHttpCommand class',				#isMetaSide : true			},			#name : #'client:',			#protocol : #private,			#sourceCode : 'client: anHttpClient\r\t^self new\r\t\thttpClient: anHttpClient;\r\t\tyourself',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '332' ],		#self : OmReference [ '333' ],		#time : DateAndTime [ '2023-12-16T08:40:57.637983+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismHttpCommand,				#isMetaSide : false			},			#name : #execute,			#protocol : #execution,			#sourceCode : 'execute\r\t"Execute the command, answers true if successful"\r\t\r\t^self subclassResponsibility ',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '333' ],		#self : OmReference [ '334' ],		#time : DateAndTime [ '2023-12-16T08:40:57.638117+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismHttpCommand,				#isMetaSide : false			},			#name : #'executeCheckingToken:',			#protocol : #execution,			#sourceCode : 'executeCheckingToken: aBlock\r\t"Evaluate aBlock, after verifying the api token"\r\r\t^ [ \r\t\tself httpClient verifyToken.\r\t\taBlock value \r\t]\r\t\ton: ExUnauthorized  \r\t\tdo: [ :error | \r\t\t\tself httpClient promptForToken\r\t\t\t\tifTrue: [ error retry ]\r\t\t\t\tifFalse: [ self inform: \'Operation Aborted!\'.\r\t\t\t\t\tnil ] ]',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '334' ],		#self : OmReference [ '335' ],		#time : DateAndTime [ '2023-12-16T08:40:57.638239+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismHttpCommand,				#isMetaSide : false			},			#name : #httpClient,			#protocol : #accessing,			#sourceCode : 'httpClient\r\t"Anser the HttpRetriever used to marshal http requests"\r\t\r\t^ httpClient',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '335' ],		#self : OmReference [ '336' ],		#time : DateAndTime [ '2023-12-16T08:40:57.638364+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismHttpCommand,				#isMetaSide : false			},			#name : #'httpClient:',			#protocol : #accessing,			#sourceCode : 'httpClient: anHttpClient\r\t"Set the HttpRetriever used to marshal http requests"\r\t\r\thttpClient := anHttpClient',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '336' ],		#self : OmReference [ '337' ],		#time : DateAndTime [ '2023-12-16T08:40:57.638489+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ExercismSubmitCommand class',				#isMetaSide : true			},			#name : #'exercise:',			#protocol : #command,			#sourceCode : 'exercise: anExercismExercise\r\t"Submit an exercism package"\r\r\t^ self from: ExercismHttpClient new exercise: anExercismExercise \r\t\t',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '337' ],		#self : OmReference [ '338' ],		#time : DateAndTime [ '2023-12-16T08:40:57.638616+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ExercismSubmitCommand class',				#isMetaSide : true			},			#name : #'from:exercise:',			#protocol : #command,			#sourceCode : 'from: anHttpClient exercise: exercise\r\t"Submit an exercism package"\r\r\t"By default, don\'t submit TestCases with the solution"\r\texercise verifySolutionForSubmission.\r\t\t\r\t^(self client: anHttpClient)\r\t\texercise: exercise;\r\t\tyourself',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '338' ],		#self : OmReference [ '339' ],		#time : DateAndTime [ '2023-12-16T08:40:57.638765+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismSubmitCommand,				#isMetaSide : false			},			#name : #execute,			#protocol : #execution,			#sourceCode : 'execute\r\t^ [ self\r\t\texecuteCheckingToken: [ self httpClient\r\t\t\t\tpatchSolution: self exercise solutionId\r\t\t\t\twith: self exercise solutionSources ] ]\r\t\ton: ExSolutionIdError\r\t\tdo: [ :error | \r\t\t\t| submission |\r\r\t\t\tsubmission := (ExercismDownloadCommand\r\t\t\t\ttrack: self exercise trackId\r\t\t\t\texercise: self exercise name) fetchLatestSubmission.\r\t\t\tsubmission storeSolutionId.\r\t\t\terror retry ]',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '339' ],		#self : OmReference [ '340' ],		#time : DateAndTime [ '2023-12-16T08:40:57.638876+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismSubmitCommand,				#isMetaSide : false			},			#name : #exercise,			#protocol : #accessing,			#sourceCode : 'exercise\r\t^ exercise',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '340' ],		#self : OmReference [ '341' ],		#time : DateAndTime [ '2023-12-16T08:40:57.638987+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismSubmitCommand,				#isMetaSide : false			},			#name : #'exercise:',			#protocol : #accessing,			#sourceCode : 'exercise: anExercismExercise\r\texercise := anExercismExercise',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '341' ],		#self : OmReference [ '342' ],		#time : DateAndTime [ '2023-12-16T08:40:57.639107+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ExercismManager class',				#isMetaSide : true			},			#name : #default,			#protocol : #'instance creation',			#sourceCode : 'default\r\t"answer a defulat manager"\r\t\r\t^self new',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '342' ],		#self : OmReference [ '343' ],		#time : DateAndTime [ '2023-12-16T08:40:57.639227+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ExercismManager class',				#isMetaSide : true			},			#name : #disableStudentCritics,			#protocol : #exercism,			#sourceCode : 'disableStudentCritics\r\r\tReUtilityMethodsRule enabled: false.\r\tReTestClassNotInPackageWithTestEndingNameRule enabled: false\r\t',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '343' ],		#self : OmReference [ '344' ],		#time : DateAndTime [ '2023-12-16T08:40:57.63934+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ExercismManager class',				#isMetaSide : true			},			#name : #exercisePrefix,			#protocol : #config,			#sourceCode : 'exercisePrefix\r\t^ \'Exercise\'',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '344' ],		#self : OmReference [ '345' ],		#time : DateAndTime [ '2023-12-16T08:40:57.639467+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ExercismManager class',				#isMetaSide : true			},			#name : #isUserMode,			#protocol : #exercism,			#sourceCode : 'isUserMode\r\t"Answer true if exercism is loaded in a clean image with no dev tools"\r\t\r\t^ ((IceRepository registry collect: [ :repo | repo name ])) asArray\r\t\t= #(\'iceberg\' \'pharo\' \'pharo-smalltalk\')\r\t\tand: [ (RPackageOrganizer default\r\t\t\t\tpackageNamed: \'ExercismDev\'\r\t\t\t\tifAbsent: [ nil ]) isNil ]',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '345' ],		#self : OmReference [ '346' ],		#time : DateAndTime [ '2023-12-16T08:40:57.639593+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ExercismManager class',				#isMetaSide : true			},			#name : #legacyExercismPackage,			#protocol : #config,			#sourceCode : 'legacyExercismPackage\r\t"Answer the default exercism package, or nil if missing"\r\t| packageOrganiser |\r\t\r\tpackageOrganiser := RPackageOrganizer default.\r\t^ packageOrganiser\r\t\tpackageNamed: self legacyPackagePrefix \r\t\tifAbsent: [ nil ]',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '346' ],		#self : OmReference [ '347' ],		#time : DateAndTime [ '2023-12-16T08:40:57.639707+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ExercismManager class',				#isMetaSide : true			},			#name : #legacyPackagePrefix,			#protocol : #config,			#sourceCode : 'legacyPackagePrefix\r\t^ \'Exercism\'',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '347' ],		#self : OmReference [ '348' ],		#time : DateAndTime [ '2023-12-16T08:40:57.639827+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ExercismManager class',				#isMetaSide : true			},			#name : #solutionData,			#protocol : #cache,			#sourceCode : 'solutionData\r\t^ SolutionData ifNil: [ SolutionData := Dictionary new ]',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '348' ],		#self : OmReference [ '349' ],		#time : DateAndTime [ '2023-12-16T08:40:57.639941+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ExercismManager class',				#isMetaSide : true			},			#name : #trackId,			#protocol : #config,			#sourceCode : 'trackId\r\t^\'pharo-smalltalk\'',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '349' ],		#self : OmReference [ '350' ],		#time : DateAndTime [ '2023-12-16T08:40:57.640132+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ExercismManager class',				#isMetaSide : true			},			#name : #trackVersionString,			#protocol : #config,			#sourceCode : 'trackVersionString\r\r\t^ 2 asString',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '350' ],		#self : OmReference [ '351' ],		#time : DateAndTime [ '2023-12-16T08:40:57.64026+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ExercismManager class',				#isMetaSide : true			},			#name : #upgrade,			#protocol : #exercism,			#sourceCode : 'upgrade\r\t"upgrade an environment (called from ugrade instructions)"\r\r\tself disableStudentCritics.\r\tWorld closeUnchangedWindows.',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '351' ],		#self : OmReference [ '352' ],		#time : DateAndTime [ '2023-12-16T08:40:57.640397+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ExercismManager class',				#isMetaSide : true			},			#name : #welcome,			#protocol : #exercism,			#sourceCode : 'welcome\r\t"Setup the initial environment for a new user"\r\r\t| browser |\r\t\t\r\t"If in usermode, hide the repositories so solutions aren\'t easily visible with a git compare"\r\tself isUserMode\r\t\tifTrue: [ \r\t\t\tIceRepository reset.\r\t\t\tself disableStudentCritics ].\r\r\t"Select, package and then method so it scrolls nicely into view"\r\tbrowser := Smalltalk tools browser openOnPackage: WelcomeTest package.\r\tbrowser\r\t\t"selectPackage: Welcome package;"\r\t\tselectMethod: (WelcomeTest methodNamed: #testWelcome)',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '352' ],		#self : OmReference [ '353' ],		#time : DateAndTime [ '2023-12-16T08:40:57.663385+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ExercismManager class',				#isMetaSide : true			},			#name : #'worldMenuCommandOn:',			#protocol : #'world menu',			#sourceCode : 'worldMenuCommandOn: aBuilder\r\t<worldMenu>\r\t(aBuilder item: #Exercism)\r\t\torder: 4.0;\r\t\ttarget: self;\r\t\thelp: \'Tools to support Exercism\'',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '353' ],		#self : OmReference [ '354' ],		#time : DateAndTime [ '2023-12-16T08:40:57.663603+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismManager,				#isMetaSide : false			},			#name : #'fetchFromExercismTo:',			#protocol : #exercism,			#sourceCode : 'fetchFromExercismTo: package\r\t"Prompt the user for an exercise to fetch, install it, and if successful, answer the loaded exercise"\r\r\t| exerciseName result |\r\r\texerciseName := (UIManager default\r\t\trequest: \'Enter a valid exercism exercise (e.g. hello-world):\')\r\t\tifNil: [ ^ nil ]\r\t\tifNotNil: [ :value | self parseTokenNamed: \'exercise\' from: value ].\r\r\tUIManager default inform: \'Loading: \' , exerciseName.\r\tresult := (ExercismDownloadCommand\r\t\ttrack: self class trackId\r\t\texercise: exerciseName) execute.\r\r\t^ result',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '354' ],		#self : OmReference [ '355' ],		#time : DateAndTime [ '2023-12-16T08:40:57.663742+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismManager,				#isMetaSide : false			},			#name : #'parseTokenNamed:from:',			#protocol : #helpers,			#sourceCode : 'parseTokenNamed: tokenName from: aString \r\t| parsedTokens exerciseOffset |\r\tparsedTokens := aString findTokens: \'= \'.\r\tparsedTokens size = 1 ifTrue: [ ^parsedTokens first ].\r\t\r\t(exerciseOffset := parsedTokens indexOf: \'--\',tokenName ) > 1 ifTrue: [ \r\t\t^parsedTokens at: exerciseOffset + 1 ].\r\t\r\t^nil',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '355' ],		#self : OmReference [ '356' ],		#time : DateAndTime [ '2023-12-16T08:40:57.663901+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismManager,				#isMetaSide : false			},			#name : #'shareExerciseDPaste:',			#protocol : #exercism,			#sourceCode : 'shareExerciseDPaste: exercise\r\t| source |\r\t\r\tsource := String\r\t\tstreamContents: [ :s | \r\t\t\ts nextPutAll: \'"This is a sample Pharo Exercism solution (see: https://exercism.io/my/tracks/pharo-smalltalk)\'; \r\t\t\tcr; \r\t\t\tnextPutAll: \'For the reference exercise, refer to: https://github.com/exercism/pharo-smalltalk/tree/master/exercises/\', exercise name, \'"\'; \r\t\t\tcr; cr.\r\t\t\t\r\t\t\t(exercise solutionClasses asSortedCollection: [ :a :b | a name <= b name ]) do: [ :class |\r\t\t\t\t\t(exercise exercisePackage extendsClass: class)\r\t\t\t\t\t\tifTrue: [ \r\t\t\t\t\t\t\tclass exPrintOutExtensionsFor: exercise exercisePackage on: s ] \r\t\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\t\tclass exPrintOutOn: s ] ] ].\r\t^ ZnClient new\r\t\tsystemPolicy;\r\t\tbeOneShot;\r\t\turl: \'http://dpaste.com/api/v2/\';\r\t\taddPart: (ZnMimePart fieldName: \'title\' value: \'Pharo Exercism for: \', exercise name);\r\t\taddPart: (ZnMimePart fieldName: \'syntax\' value: \'smalltalk\');\r\t\taddPart: (ZnMimePart fieldName: \'expiry_days\' value: \'7\');\r\t\taddPart: (ZnMimePart fieldName: \'content\' value: source);\r\t\tpost',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '356' ],		#self : OmReference [ '357' ],		#time : DateAndTime [ '2023-12-16T08:40:57.66403+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismManager,				#isMetaSide : false			},			#name : #'shareExerciseStfx:',			#protocol : #exercism,			#sourceCode : 'shareExerciseStfx: package\r\t| source |\r\tpackage = self class legacyExercismPackage\r\t\tifTrue: [ self error: \'Select the sub-package with your solution!\' ].\r\t\t\r\tsource := String\r\t\tstreamContents: [ :s | \r\t\t\tpackage solutionSources\r\t\t\t\tkeysAndValuesDo: [ :filename :code | \r\t\t\t\t\ts << $" << filename << $".\r\t\t\t\t\ts cr; cr;\r\t\t\t\t\t\tnextPutAll: code;\r\t\t\t\t\t\tcr; cr ] ].\r\t\t\t\t\r\t^ ZnClient new\r\t\tsystemPolicy;\r\t\tbeOneShot;\r\t\turl: \'http://ws.stfx.eu\';\r\t\tcontents: source;\r\t\tpost',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '357' ],		#self : OmReference [ '358' ],		#time : DateAndTime [ '2023-12-16T08:40:57.66415+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismManager,				#isMetaSide : false			},			#name : #'submitToExercism:',			#protocol : #exercism,			#sourceCode : 'submitToExercism: packageOrTag\r\t\t\r\t(packageOrTag  = self class legacyExercismPackage) \r\t\tifTrue: [ self error: \'Select the sub-package with your solution!\' ].\r\t\t\t\t\r\t^(ExercismSubmitCommand exercise: packageOrTag) execute.\r\t',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '358' ],		#self : OmReference [ '359' ],		#time : DateAndTime [ '2023-12-16T08:40:57.66426+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismManager,				#isMetaSide : false			},			#name : #'viewOnExercism:',			#protocol : #exercism,			#sourceCode : 'viewOnExercism: packageOrTag\r\tWebBrowser openOn: \'https://exercism.org/tracks/pharo\'',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '359' ],		#self : OmReference [ '360' ],		#time : DateAndTime [ '2023-12-16T08:40:57.664392+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ExercismSubmission class',				#isMetaSide : true			},			#name : #baseUrlKey,			#protocol : #accessing,			#sourceCode : 'baseUrlKey\r\t^ \'file_download_base_url\'',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '360' ],		#self : OmReference [ '361' ],		#time : DateAndTime [ '2023-12-16T08:40:57.664517+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ExercismSubmission class',				#isMetaSide : true			},			#name : #'data:',			#protocol : #accessing,			#sourceCode : 'data: exercismDataDictionary\r\t^ self new\r\t\texercismData:\r\t\t\t(exercismDataDictionary\r\t\t\t\tat: \'solution\'\r\t\t\t\tifAbsent: [ exercismDataDictionary ]);\r\t\tyourself',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '361' ],		#self : OmReference [ '362' ],		#time : DateAndTime [ '2023-12-16T08:40:57.664737+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ExercismSubmission class',				#isMetaSide : true			},			#name : #'error:',			#protocol : #accessing,			#sourceCode : 'error: aString\r\t^self new \r\t\texercismData: { \'exercise\' ->> {\'id\' -> \'\' }} asDictionary;\r\t\terrorMessage: aString;\r\t\tyourself',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '362' ],		#self : OmReference [ '363' ],		#time : DateAndTime [ '2023-12-16T08:40:57.664863+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismSubmission,				#isMetaSide : false			},			#name : #baseUrl,			#protocol : #accessing,			#sourceCode : 'baseUrl \r\t^(self exercismData at: self class baseUrlKey) exPathString.',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '363' ],		#self : OmReference [ '364' ],		#time : DateAndTime [ '2023-12-16T08:40:57.664976+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismSubmission,				#isMetaSide : false			},			#name : #contentData,			#protocol : #accessing,			#sourceCode : 'contentData\r\t^ contentData',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '364' ],		#self : OmReference [ '365' ],		#time : DateAndTime [ '2023-12-16T08:40:57.665083+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismSubmission,				#isMetaSide : false			},			#name : #'contentData:',			#protocol : #accessing,			#sourceCode : 'contentData: anObject\r\tcontentData := anObject',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '365' ],		#self : OmReference [ '366' ],		#time : DateAndTime [ '2023-12-16T08:40:57.665191+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismSubmission,				#isMetaSide : false			},			#name : #'contentsFor:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'contentsFor: aString ifAbsent: anObject \r\t^self contentData at: aString',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '366' ],		#self : OmReference [ '367' ],		#time : DateAndTime [ '2023-12-16T08:40:57.66531+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismSubmission,				#isMetaSide : false			},			#name : #createSnapshotFromDefinitions,			#protocol : #internal,			#sourceCode : 'createSnapshotFromDefinitions\r\r\t"return MC snapshot from definitions that can be loaded or submitted"\r\t^ MCSnapshot fromDefinitions: self definitionsToLoadFromDirectory\r',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '367' ],		#self : OmReference [ '368' ],		#time : DateAndTime [ '2023-12-16T08:40:57.665431+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismSubmission,				#isMetaSide : false			},			#name : #definitionsToLoadFromDirectory,			#protocol : #internal,			#sourceCode : 'definitionsToLoadFromDirectory\r\t\r\t"reader will return definitions to be loaded from directory containing package directory and .st files with classes"\r\t| tonelReader | \r\ttonelReader := TonelReader on: self latestExercisePackageSourceDir fileName: self exercisePackageName.\r\ttonelReader loadDefinitions.\r\t^ tonelReader definitions.\r',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '368' ],		#self : OmReference [ '369' ],		#time : DateAndTime [ '2023-12-16T08:40:57.665541+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismSubmission,				#isMetaSide : false			},			#name : #errorMessage,			#protocol : #accessing,			#sourceCode : 'errorMessage \r\r\t^self exercismData at: \'error\' ifAbsent: [ \'\' ]\r',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '369' ],		#self : OmReference [ '370' ],		#time : DateAndTime [ '2023-12-16T08:40:57.665649+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismSubmission,				#isMetaSide : false			},			#name : #'errorMessage:',			#protocol : #accessing,			#sourceCode : 'errorMessage: aString \r\r\tself exercismData at: \'error\' put: aString\r',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '370' ],		#self : OmReference [ '371' ],		#time : DateAndTime [ '2023-12-16T08:40:57.665761+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismSubmission,				#isMetaSide : false			},			#name : #exercise,			#protocol : #storing,			#sourceCode : 'exercise\r\t"Answer the ExercismExercise associated with this submission"\r\t\r\t^ExercismExercise find: self exerciseId ifAbsent: [nil]',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '371' ],		#self : OmReference [ '372' ],		#time : DateAndTime [ '2023-12-16T08:40:57.665872+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismSubmission,				#isMetaSide : false			},			#name : #exerciseClassName,			#protocol : #accessing,			#sourceCode : 'exerciseClassName \r\t^self exerciseId kebabAsCamelCase ',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '372' ],		#self : OmReference [ '373' ],		#time : DateAndTime [ '2023-12-16T08:40:57.665979+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismSubmission,				#isMetaSide : false			},			#name : #exerciseId,			#protocol : #accessing,			#sourceCode : 'exerciseId\r\t^(self exercismData at: \'exercise\') at: \'id\'',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '373' ],		#self : OmReference [ '374' ],		#time : DateAndTime [ '2023-12-16T08:40:57.666088+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismSubmission,				#isMetaSide : false			},			#name : #exercisePackageName,			#protocol : #internal,			#sourceCode : 'exercisePackageName\r\r\t^ ExercismManager exercisePrefix, \'@\', self exerciseClassName ',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '374' ],		#self : OmReference [ '375' ],		#time : DateAndTime [ '2023-12-16T08:40:57.666194+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismSubmission,				#isMetaSide : false			},			#name : #exercismData,			#protocol : #accessing,			#sourceCode : 'exercismData\r\t^ exercismData',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '375' ],		#self : OmReference [ '376' ],		#time : DateAndTime [ '2023-12-16T08:40:57.666302+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismSubmission,				#isMetaSide : false			},			#name : #'exercismData:',			#protocol : #accessing,			#sourceCode : 'exercismData: anObject\r\texercismData := anObject',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '376' ],		#self : OmReference [ '377' ],		#time : DateAndTime [ '2023-12-16T08:40:57.666409+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismSubmission,				#isMetaSide : false			},			#name : #filenames,			#protocol : #accessing,			#sourceCode : 'filenames\r\t^self exercismData at: \'files\'',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '377' ],		#self : OmReference [ '378' ],		#time : DateAndTime [ '2023-12-16T08:40:57.666541+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismSubmission,				#isMetaSide : false			},			#name : #initialize,			#protocol : #accessing,			#sourceCode : 'initialize \r\r\tsuper initialize.\r\tself contentData: Dictionary new.',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '378' ],		#self : OmReference [ '379' ],		#time : DateAndTime [ '2023-12-16T08:40:57.666661+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismSubmission,				#isMetaSide : false			},			#name : #installDefinitionsFromSnapshot,			#protocol : #internal,			#sourceCode : 'installDefinitionsFromSnapshot\r\r\t"tonel reader will load definitions from directory containing package directory and .st files with classes, creates MC snapshot and install package with exercise to default package organizer"\r\t\r\tself createSnapshotFromDefinitions install',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '379' ],		#self : OmReference [ '380' ],		#time : DateAndTime [ '2023-12-16T08:40:57.666797+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismSubmission,				#isMetaSide : false			},			#name : #isValid,			#protocol : #storing,			#sourceCode : 'isValid\r\t"Answer true if the submission resulted in a valid exercise"\r\t\r\t^(self exercismData includesKey: \'error\') not and: [ self exercise notNil ]',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '380' ],		#self : OmReference [ '381' ],		#time : DateAndTime [ '2023-12-16T08:40:57.666935+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismSubmission,				#isMetaSide : false			},			#name : #latestExercisePackageSourceDir,			#protocol : #internal,			#sourceCode : 'latestExercisePackageSourceDir\r\r\t"return memory file reference with retreived latest exercise souuces - needed for tonel reader"\r\t|memFileRef packageDir|\r\tmemFileRef := FileSystem memory root.\r\tpackageDir := (memFileRef / self exercisePackageName) ensureCreateDirectory.\r\tself sourceFilenamesWithContentsDo: [:fileName :sourceString |\r\t\t"do write files here"\r\t\t|sourceFile|\r\t\tsourceFile := packageDir / fileName.\r\t\tsourceFile writeStreamDo: [:aStream | aStream nextPutAll: sourceString ]\r\t].\r\t^ memFileRef ',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '381' ],		#self : OmReference [ '382' ],		#time : DateAndTime [ '2023-12-16T08:40:57.667052+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismSubmission,				#isMetaSide : false			},			#name : #'populateFileContentsWith:',			#protocol : #retrieving,			#sourceCode : 'populateFileContentsWith: aBlockClosure\r\tself sourceFilenames\r\t\tdo: [ :filename | \r\t\t\t| fileContent |\r\t\t\tfileContent := aBlockClosure value:\r\t\t\t\tself baseUrl , filename.\r\t\t\tfileContent\r\t\t\t\tifNotNil: [ self contentData at: filename put: fileContent ] ]',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '382' ],		#self : OmReference [ '383' ],		#time : DateAndTime [ '2023-12-16T08:40:57.667157+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismSubmission,				#isMetaSide : false			},			#name : #solutionId,			#protocol : #accessing,			#sourceCode : 'solutionId\r\t^self exercismData at: \'id\'',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '383' ],		#self : OmReference [ '384' ],		#time : DateAndTime [ '2023-12-16T08:40:57.667266+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismSubmission,				#isMetaSide : false			},			#name : #sourceFilenames,			#protocol : #accessing,			#sourceCode : 'sourceFilenames\r\t\r\t^self filenames select: [:filename | filename endsWith: \'.st\' ]',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '384' ],		#self : OmReference [ '385' ],		#time : DateAndTime [ '2023-12-16T08:40:57.667376+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismSubmission,				#isMetaSide : false			},			#name : #'sourceFilenamesWithContentsDo:',			#protocol : #retrieving,			#sourceCode : 'sourceFilenamesWithContentsDo: aBlockClosure\r\tself contentData\r\t\tkeysAndValuesDo:\r\t\t\t[ :filename :contents | aBlockClosure value: filename value: contents ]',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '385' ],		#self : OmReference [ '386' ],		#time : DateAndTime [ '2023-12-16T08:40:57.667486+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismSubmission,				#isMetaSide : false			},			#name : #storeSolutionId,			#protocol : #storing,			#sourceCode : 'storeSolutionId\r\tself exercise ifNotNil: [:exercise | exercise storeSolutionId: self solutionId]',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '386' ],		#self : OmReference [ '387' ],		#time : DateAndTime [ '2023-12-16T08:40:57.667591+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ExercismSubmission,				#isMetaSide : false			},			#name : #user,			#protocol : #accessing,			#sourceCode : 'user\r\t^(self exercismData at: \'user\') at: \'handle\'',			#stamp : '',			#package : #ExercismTools-Core		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '387' ],		#self : OmReference [ '388' ],		#time : DateAndTime [ '2023-12-16T08:40:57.667915+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #WorldMorph,				#isMetaSide : false			},			#name : #'openModal:',			#protocol : #'*ExercismTools',			#sourceCode : 'openModal: aSystemWindow\r\r\t|modalMorph|\r\tmodalMorph := self submorphs detect: #isSystemWindow ifNone: [ self error: \'Could not find a system window to open a modal dialog.\' ].\r\r\t^ modalMorph openModal: aSystemWindow\r',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '388' ],		#self : OmReference [ '389' ],		#time : DateAndTime [ '2023-12-16T08:40:57.668371+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #String,				#isMetaSide : false			},			#name : #'->>',			#protocol : #'*ExercismTools',			#sourceCode : '->> aCollectionOfAssociations\r\t"Similar to -> but converts aCollection to anOrderedDictionary, useful when building JSON structures"\r\r\t^self -> aCollectionOfAssociations asOrderedDictionary ',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '389' ],		#self : OmReference [ '390' ],		#time : DateAndTime [ '2023-12-16T08:40:57.668793+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #String,				#isMetaSide : false			},			#name : #asKebabCase,			#protocol : #'*ExercismTools',			#sourceCode : 'asKebabCase\r\t"Answer a String that converts the CamelCase input to camel-case kebab output \r\tused by exercism"\r\r\t^ self class\r\t\tstreamContents: [ :kebabStream |\r\t\t\tself uncapitalized\r\t\t\t\tdo: [ :char |\r\t\t\t\t\tchar isUppercase\r\t\t\t\t\t\tifTrue: [ kebabStream nextPut: $- ].\r\t\t\t\t\tkebabStream nextPut: char asLowercase ] ]',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '390' ],		#self : OmReference [ '391' ],		#time : DateAndTime [ '2023-12-16T08:40:57.669197+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #String,				#isMetaSide : false			},			#name : #asSentenceCase,			#protocol : #'*ExercismTools',			#sourceCode : 'asSentenceCase\r\t"Converts string of selector name to human readable sentence."\r\r\t^ self class\r\t\tstreamContents: [ :aStream |\r\t\t\tself do: [ :char |\r\t\t\t\t\tchar isUppercase\r\t\t\t\t\t\tifTrue: [ aStream nextPut: Character space ].\r\t\t\t\t\taStream nextPut: char asLowercase ] ]',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '391' ],		#self : OmReference [ '392' ],		#time : DateAndTime [ '2023-12-16T08:40:57.669591+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #String,				#isMetaSide : false			},			#name : #'encodeDoublingDoubleQuotesOn:',			#protocol : #'*ExercismTools',			#sourceCode : 'encodeDoublingDoubleQuotesOn: s\r\t"Print inside string quotes, doubling inbedded quotes."\r\r\tself\r\t\tdo: [ :c | \r\t\t\tc = $"\r\t\t\t\tifTrue: [ s << $" ].\r\t\t\ts << c ]',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '392' ],		#self : OmReference [ '393' ],		#time : DateAndTime [ '2023-12-16T08:40:57.669996+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #String,				#isMetaSide : false			},			#name : #exPathString,			#protocol : #'*ExercismTools',			#sourceCode : 'exPathString\r\t"Answer the receiver as a valid path, with a trailing /"\r\r\t^ String\r\t\tstreamContents: [ :s | \r\t\t\ts nextPutAll: self.\r\t\t\tself last = $/\r\t\t\t\tifFalse: [ s nextPut: $/ ] ]',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '393' ],		#self : OmReference [ '394' ],		#time : DateAndTime [ '2023-12-16T08:40:57.670392+11:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #String,				#isMetaSide : false			},			#name : #kebabAsCamelCase,			#protocol : #'*ExercismTools',			#sourceCode : 'kebabAsCamelCase\r\t"Answer a String that converts the CamelCase input to camel-case kebab output \r\tused by exercism"\r\r\t^ (self copyReplaceAll: {$-} with: {Character space}) asCamelCase.',			#stamp : '',			#package : #ExercismTools		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:40:57.875301+11:00' ],		#prior : OmReference [ '394' ],		#self : OmReference [ '395' ]	},	#content : EpMonticelloVersionsLoad {		#versionNames : OrderedCollection [			'Exercise@Welcome-CompatibleUserName.1700215054'		]	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '395' ],		#self : OmReference [ '396' ],		#time : DateAndTime [ '2023-12-16T08:40:57.902007+11:00' ],		#trigger : @3	},	#content : EpCategoryAddition {		#classCategoryName : #'Exercise@Welcome',		#affectedPackageName : #'Exercise@Welcome'	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '396' ],		#self : OmReference [ '397' ],		#time : DateAndTime [ '2023-12-16T08:40:57.903917+11:00' ],		#trigger : OmReference [ '395' ]	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'TestCase subclass: #WelcomeTest\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpackage: \'Exercise@Welcome\'',				#superclassName : 'TestCase'			},			#name : #WelcomeTest,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'WelcomeTest class\r\tinstanceVariableNames: \'\''				},				#name : #'WelcomeTest class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #WelcomeTest,					#isMetaSide : false				},				#parent : @8,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #'Exercise@Welcome',			#package : #'Exercise@Welcome',			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '397' ],		#self : OmReference [ '398' ],		#time : DateAndTime [ '2023-12-16T08:40:57.905053+11:00' ],		#trigger : OmReference [ '395' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'TestCase subclass: #WelcomeTest\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpackage: \'Exercise@Welcome\'',				#superclassName : 'TestCase'			},			#name : #WelcomeTest,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'WelcomeTest class\r\tinstanceVariableNames: \'\''				},				#name : #'WelcomeTest class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #WelcomeTest,					#isMetaSide : false				},				#parent : @8,				#content : 'To start your Exercism journey, right click on the Exercise@Welcome package (or use the top level Exercism menu) and select \'Exercism | Fetch new exercise\', and then type: hello-world.\r\rNote: Each exercise will have some instructions in its test Comment tab, so be sure to read them when starting a new challenge.',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #'Exercise@Welcome',			#package : #'Exercise@Welcome',			#sharedPools : OrderedCollection [ ]		},		#oldComment : '',		#newComment : 'To start your Exercism journey, right click on the Exercise@Welcome package (or use the top level Exercism menu) and select \'Exercism | Fetch new exercise\', and then type: hello-world.\r\rNote: Each exercise will have some instructions in its test Comment tab, so be sure to read them when starting a new challenge.',		#oldStamp : '',		#newStamp : ''	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '398' ],		#self : OmReference [ '399' ],		#time : DateAndTime [ '2023-12-16T08:40:57.936192+11:00' ],		#trigger : OmReference [ '395' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'WelcomeTest class',				#isMetaSide : true			},			#name : #followedBy,			#protocol : #config,			#sourceCode : 'followedBy \r\t^\'HelloWorld\'',			#stamp : '',			#package : #'Exercise@Welcome'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '399' ],		#self : OmReference [ '400' ],		#time : DateAndTime [ '2023-12-16T08:40:57.936775+11:00' ],		#trigger : OmReference [ '395' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #WelcomeTest,				#isMetaSide : false			},			#name : #testWelcome,			#protocol : #tests,			#sourceCode : 'testWelcome\r\t"This is a sample Pharo test fixture. \r\t\r\tTIP 1: Try running this test by clicking on the gray orb next to the method name above.\r\tTIP 2: Click to the class Comment tab for more information on getting started."\r\t\r\tself assert: #(\'Welcome\' \'to\' \'Pharo\') size equals: 3',			#stamp : '',			#package : #'Exercise@Welcome'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:59:20.354055+11:00' ],		#prior : OmReference [ '400' ],		#self : OmReference [ '401' ]	},	#content : EpCategoryAddition {		#classCategoryName : #'Exercise@Matrix',		#affectedPackageName : #'Exercise@Matrix'	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:59:20.356179+11:00' ],		#prior : OmReference [ '401' ],		#self : OmReference [ '402' ]	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'ExercismTest subclass: #MatrixTest\r\tinstanceVariableNames: \'matrixCalculator\'\r\tclassVariableNames: \'\'\r\tpackage: \'Exercise@Matrix\'',				#superclassName : 'ExercismTest'			},			#name : #MatrixTest,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #MatrixTest,						#isMetaSide : false					},					#name : #matrixCalculator,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'MatrixTest class\r\tinstanceVariableNames: \'\''				},				#name : #'MatrixTest class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #MatrixTest,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #'Exercise@Matrix',			#package : #'Exercise@Matrix',			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:59:20.357603+11:00' ],		#prior : OmReference [ '402' ],		#self : OmReference [ '403' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'ExercismTest subclass: #MatrixTest\r\tinstanceVariableNames: \'matrixCalculator\'\r\tclassVariableNames: \'\'\r\tpackage: \'Exercise@Matrix\'',				#superclassName : 'ExercismTest'			},			#name : #MatrixTest,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #MatrixTest,						#isMetaSide : false					},					#name : #matrixCalculator,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'MatrixTest class\r\tinstanceVariableNames: \'\''				},				#name : #'MatrixTest class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #MatrixTest,					#isMetaSide : false				},				#parent : @7,				#content : '# Matrix\r\rGiven a string representing a matrix of numbers, return the rows and columns of\rthat matrix.\r\rSo given a string with embedded newlines like:\r\r```text\r9 8 7\r5 3 2\r6 6 7\r```\r\rrepresenting this matrix:\r\r```text\r    1  2  3\r  |---------\r1 | 9  8  7\r2 | 5  3  2\r3 | 6  6  7\r```\r\ryour code should be able to spit out:\r\r- A list of the rows, reading each row left-to-right while moving\r  top-to-bottom across the rows,\r- A list of the columns, reading each column top-to-bottom while moving\r  from left-to-right.\r\rThe rows for our example matrix:\r\r- 9, 8, 7\r- 5, 3, 2\r- 6, 6, 7\r\rAnd its columns:\r\r- 9, 5, 6\r- 8, 3, 6\r- 7, 2, 7\r\r## Hint\r\rTry using the Finder - Examples searcher, to see if there is a useful method for parsing.\r',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #'Exercise@Matrix',			#package : #'Exercise@Matrix',			#sharedPools : OrderedCollection [ ]		},		#oldComment : '',		#newComment : '# Matrix\r\rGiven a string representing a matrix of numbers, return the rows and columns of\rthat matrix.\r\rSo given a string with embedded newlines like:\r\r```text\r9 8 7\r5 3 2\r6 6 7\r```\r\rrepresenting this matrix:\r\r```text\r    1  2  3\r  |---------\r1 | 9  8  7\r2 | 5  3  2\r3 | 6  6  7\r```\r\ryour code should be able to spit out:\r\r- A list of the rows, reading each row left-to-right while moving\r  top-to-bottom across the rows,\r- A list of the columns, reading each column top-to-bottom while moving\r  from left-to-right.\r\rThe rows for our example matrix:\r\r- 9, 8, 7\r- 5, 3, 2\r- 6, 6, 7\r\rAnd its columns:\r\r- 9, 5, 6\r- 8, 3, 6\r- 7, 2, 7\r\r## Hint\r\rTry using the Finder - Examples searcher, to see if there is a useful method for parsing.\r',		#oldStamp : '',		#newStamp : ''	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:59:20.39255+11:00' ],		#prior : OmReference [ '403' ],		#self : OmReference [ '404' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'MatrixTest class',				#isMetaSide : true			},			#name : #exercise,			#protocol : #config,			#sourceCode : 'exercise\r\t"Answer the configured exercise meta data for this exercise, an ExercismExercise"\r\t\r\t^(self createExerciseAfter: AllergiesTest)\r\t\tisCore: true;\r\t\tdifficulty: 4;\r\t\ttopics: #(\'matrices\' \'parsing\');\r\t\tyourself\r\t',			#stamp : '',			#package : #'Exercise@Matrix'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:59:20.393904+11:00' ],		#prior : OmReference [ '404' ],		#self : OmReference [ '405' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'MatrixTest class',				#isMetaSide : true			},			#name : #uuid,			#protocol : #config,			#sourceCode : 'uuid\r\t"Answer a unique id for this exercise"\r\t^\'bea80017-9d41-0d00-900d-a13308866539\'',			#stamp : '',			#package : #'Exercise@Matrix'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:59:20.394648+11:00' ],		#prior : OmReference [ '405' ],		#self : OmReference [ '406' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'MatrixTest class',				#isMetaSide : true			},			#name : #version,			#protocol : #config,			#sourceCode : 'version\r\t"Generated from specification: 29 March 2019"\r\t^\'1.1.0\'',			#stamp : '',			#package : #'Exercise@Matrix'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:59:20.394974+11:00' ],		#prior : OmReference [ '406' ],		#self : OmReference [ '407' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixTest,				#isMetaSide : false			},			#name : #setUp,			#protocol : #running,			#sourceCode : 'setUp\r\tsuper setUp.\r\tmatrixCalculator := Matrix new',			#stamp : '',			#package : #'Exercise@Matrix'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:59:20.395195+11:00' ],		#prior : OmReference [ '407' ],		#self : OmReference [ '408' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixTest,				#isMetaSide : false			},			#name : #test01_ExtractRowFromOneNumberMatrix,			#protocol : #tests,			#sourceCode : 'test01_ExtractRowFromOneNumberMatrix\r\t| result |\r\r\tresult := matrixCalculator input: \'1\' atRow: 1 .\r\tself assert: result equals: #(1 )',			#stamp : '',			#package : #'Exercise@Matrix'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:59:20.395403+11:00' ],		#prior : OmReference [ '408' ],		#self : OmReference [ '409' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixTest,				#isMetaSide : false			},			#name : #test02_CanExtractRow,			#protocol : #tests,			#sourceCode : 'test02_CanExtractRow\r\t| result |\r\r\tresult := matrixCalculator input: \'1 2\r3 4\' atRow: 2 .\r\tself assert: result equals: #(3 4 )',			#stamp : '',			#package : #'Exercise@Matrix'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:59:20.395574+11:00' ],		#prior : OmReference [ '409' ],		#self : OmReference [ '410' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixTest,				#isMetaSide : false			},			#name : #test03_ExtractRowWhereNumbersHaveDifferentWidths,			#protocol : #tests,			#sourceCode : 'test03_ExtractRowWhereNumbersHaveDifferentWidths\r\t| result |\r\r\tresult := matrixCalculator input: \'1 2\r10 20\' atRow: 2 .\r\tself assert: result equals: #(10 20 )',			#stamp : '',			#package : #'Exercise@Matrix'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:59:20.39573+11:00' ],		#prior : OmReference [ '410' ],		#self : OmReference [ '411' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixTest,				#isMetaSide : false			},			#name : #test04_CanExtractRowFromNonsquareMatrix,			#protocol : #tests,			#sourceCode : 'test04_CanExtractRowFromNonsquareMatrix\r\t| result |\r\r\tresult := matrixCalculator input: \'1 2 3\r4 5 6\r7 8 9\r8 7 6\' atRow: 3 .\r\tself assert: result equals: #(7 8 9 )',			#stamp : '',			#package : #'Exercise@Matrix'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:59:20.395867+11:00' ],		#prior : OmReference [ '411' ],		#self : OmReference [ '412' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixTest,				#isMetaSide : false			},			#name : #test05_ExtractColumnFromOneNumberMatrix,			#protocol : #tests,			#sourceCode : 'test05_ExtractColumnFromOneNumberMatrix\r\t| result |\r\r\tresult := matrixCalculator input: \'1\' atColumn: 1 .\r\tself assert: result equals: #(1 )',			#stamp : '',			#package : #'Exercise@Matrix'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:59:20.395994+11:00' ],		#prior : OmReference [ '412' ],		#self : OmReference [ '413' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixTest,				#isMetaSide : false			},			#name : #test06_CanExtractColumn,			#protocol : #tests,			#sourceCode : 'test06_CanExtractColumn\r\t| result |\r\r\tresult := matrixCalculator input: \'1 2 3\r4 5 6\r7 8 9\' atColumn: 3 .\r\tself assert: result equals: #(3 6 9 )',			#stamp : '',			#package : #'Exercise@Matrix'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:59:20.396119+11:00' ],		#prior : OmReference [ '413' ],		#self : OmReference [ '414' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixTest,				#isMetaSide : false			},			#name : #test07_CanExtractColumnFromNonsquareMatrix,			#protocol : #tests,			#sourceCode : 'test07_CanExtractColumnFromNonsquareMatrix\r\t| result |\r\r\tresult := matrixCalculator input: \'1 2 3\r4 5 6\r7 8 9\r8 7 6\' atColumn: 3 .\r\tself assert: result equals: #(3 6 9 6 )',			#stamp : '',			#package : #'Exercise@Matrix'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T08:59:20.396422+11:00' ],		#prior : OmReference [ '414' ],		#self : OmReference [ '415' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixTest,				#isMetaSide : false			},			#name : #test08_ExtractColumnWhereNumbersHaveDifferentWidths,			#protocol : #tests,			#sourceCode : 'test08_ExtractColumnWhereNumbersHaveDifferentWidths\r\t| result |\r\r\tresult := matrixCalculator input: \'89 1903 3\r18 3 1\r9 4 800\' atColumn: 2 .\r\tself assert: result equals: #(1903 3 4 )',			#stamp : '',			#package : #'Exercise@Matrix'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T09:00:30.394367+11:00' ],		#prior : OmReference [ '415' ],		#self : OmReference [ '416' ]	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Matrix\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpackage: \'Exercise@Matrix\'',				#superclassName : 'Object'			},			#name : #Matrix,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Matrix class\r\tinstanceVariableNames: \'\''				},				#name : #'Matrix class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Matrix,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #'Exercise@Matrix',			#package : #'Exercise@Matrix',			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T09:02:08.373417+11:00' ],		#prior : OmReference [ '416' ],		#self : OmReference [ '417' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Matrix,				#isMetaSide : false			},			#name : #'input:atRow:',			#protocol : #'as yet unclassified',			#sourceCode : 'input: aMatrix atRow: aRow\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temporary variable names |\r',			#stamp : 'AndyMarks 12/16/2023 09:02',			#package : #'Exercise@Matrix'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T09:02:15.115879+11:00' ],		#prior : OmReference [ '417' ],		#self : OmReference [ '418' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Matrix,				#isMetaSide : false			},			#name : #'input:atRow:',			#protocol : #'as yet unclassified',			#sourceCode : 'input: aMatrix atRow: aRow\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temporary variable names |\r',			#stamp : 'AndyMarks 12/16/2023 09:02',			#package : #'Exercise@Matrix'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Matrix,				#isMetaSide : false			},			#name : #'input:atRow:',			#protocol : #'as yet unclassified',			#sourceCode : 'input: aMatrix atRow: aRow\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r',			#stamp : 'AndyMarks 12/16/2023 09:02',			#package : #'Exercise@Matrix'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T09:03:18.244083+11:00' ],		#prior : OmReference [ '418' ],		#self : OmReference [ '419' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Matrix,				#isMetaSide : false			},			#name : #'input:atRow:',			#protocol : #'as yet unclassified',			#sourceCode : 'input: aMatrix atRow: aRow\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r',			#stamp : 'AndyMarks 12/16/2023 09:02',			#package : #'Exercise@Matrix'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Matrix,				#isMetaSide : false			},			#name : #'input:atRow:',			#protocol : #querying,			#sourceCode : 'input: aMatrix atRow: aRow\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r',			#stamp : 'AndyMarks 12/16/2023 09:02',			#package : #'Exercise@Matrix'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T09:04:20.929914+11:00' ],		#prior : OmReference [ '419' ],		#self : OmReference [ '420' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Matrix,				#isMetaSide : false			},			#name : #'input:atColumn:',			#protocol : #'as yet unclassified',			#sourceCode : 'input: aMatrix atColumn: aColumn\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r',			#stamp : 'AndyMarks 12/16/2023 09:04',			#package : #'Exercise@Matrix'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T09:04:30.104772+11:00' ],		#prior : OmReference [ '420' ],		#self : OmReference [ '421' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Matrix,				#isMetaSide : false			},			#name : #'input:atColumn:',			#protocol : #'as yet unclassified',			#sourceCode : 'input: aMatrix atColumn: aColumn\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r',			#stamp : 'AndyMarks 12/16/2023 09:04',			#package : #'Exercise@Matrix'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Matrix,				#isMetaSide : false			},			#name : #'input:atColumn:',			#protocol : #querying,			#sourceCode : 'input: aMatrix atColumn: aColumn\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r',			#stamp : 'AndyMarks 12/16/2023 09:04',			#package : #'Exercise@Matrix'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T09:04:57.116368+11:00' ],		#prior : OmReference [ '421' ],		#self : OmReference [ '422' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Matrix,				#isMetaSide : false			},			#name : #'input:atRow:',			#protocol : #querying,			#sourceCode : 'input: aMatrix atRow: aRow\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r',			#stamp : 'AndyMarks 12/16/2023 09:02',			#package : #'Exercise@Matrix'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Matrix,				#isMetaSide : false			},			#name : #'input:atRow:',			#protocol : #querying,			#sourceCode : 'input: aMatrix atRow: aRow\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t^aMatrix.\r\t\t\t\r',			#stamp : 'AndyMarks 12/16/2023 09:04',			#package : #'Exercise@Matrix'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T10:01:24.745805+11:00' ],		#prior : OmReference [ '422' ],		#self : OmReference [ '423' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Matrix,				#isMetaSide : false			},			#name : #'input:atRow:',			#protocol : #querying,			#sourceCode : 'input: aMatrix atRow: aRow\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t^aMatrix.\r\t\t\t\r',			#stamp : 'AndyMarks 12/16/2023 09:04',			#package : #'Exercise@Matrix'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Matrix,				#isMetaSide : false			},			#name : #'input:atRow:',			#protocol : #querying,			#sourceCode : 'input: aMatrix atRow: aRow\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| rows |\r\t\r\trows := aMatrix split: \'\\n\'.\r\t^rows.\r\t\t\t\r',			#stamp : 'AndyMarks 12/16/2023 10:01',			#package : #'Exercise@Matrix'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T10:03:20.315376+11:00' ],		#prior : OmReference [ '423' ],		#self : OmReference [ '424' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Matrix,				#isMetaSide : false			},			#name : #'input:atRow:',			#protocol : #querying,			#sourceCode : 'input: aMatrix atRow: aRow\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| rows |\r\t\r\trows := aMatrix split: \'\\n\'.\r\t^rows.\r\t\t\t\r',			#stamp : 'AndyMarks 12/16/2023 10:01',			#package : #'Exercise@Matrix'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Matrix,				#isMetaSide : false			},			#name : #'input:atRow:',			#protocol : #querying,			#sourceCode : 'input: aMatrix atRow: aRow\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| rows |\r\t\r\trows := \'\\n\' split: aMatrix.\r\t^rows.\r\t\t\t\r',			#stamp : 'AndyMarks 12/16/2023 10:03',			#package : #'Exercise@Matrix'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T10:04:00.3945+11:00' ],		#prior : OmReference [ '424' ],		#self : OmReference [ '425' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Matrix,				#isMetaSide : false			},			#name : #'input:atRow:',			#protocol : #querying,			#sourceCode : 'input: aMatrix atRow: aRow\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| rows |\r\t\r\trows := \'\\n\' split: aMatrix.\r\t^rows.\r\t\t\t\r',			#stamp : 'AndyMarks 12/16/2023 10:03',			#package : #'Exercise@Matrix'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Matrix,				#isMetaSide : false			},			#name : #'input:atRow:',			#protocol : #querying,			#sourceCode : 'input: aMatrix atRow: aRow\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| rows |\r\t\r\trows := \'\\n\' split: aMatrix.\r\t^rows at: aRow.\r\t\t\t\r',			#stamp : 'AndyMarks 12/16/2023 10:04',			#package : #'Exercise@Matrix'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T10:04:39.348691+11:00' ],		#prior : OmReference [ '425' ],		#self : OmReference [ '426' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Matrix,				#isMetaSide : false			},			#name : #'input:atRow:',			#protocol : #querying,			#sourceCode : 'input: aMatrix atRow: aRow\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| rows |\r\t\r\trows := \'\\n\' split: aMatrix.\r\t^rows at: aRow.\r\t\t\t\r',			#stamp : 'AndyMarks 12/16/2023 10:04',			#package : #'Exercise@Matrix'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Matrix,				#isMetaSide : false			},			#name : #'input:atRow:',			#protocol : #querying,			#sourceCode : 'input: aMatrix atRow: aRow\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| rows |\r\t\r\trows := \'\\n\' split: aMatrix.\r\t^rows at: (aRow - 1).\r\t\t\t\r',			#stamp : 'AndyMarks 12/16/2023 10:04',			#package : #'Exercise@Matrix'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T10:07:07.049651+11:00' ],		#prior : OmReference [ '426' ],		#self : OmReference [ '427' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Matrix,				#isMetaSide : false			},			#name : #'input:atRow:',			#protocol : #querying,			#sourceCode : 'input: aMatrix atRow: aRow\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| rows |\r\t\r\trows := \'\\n\' split: aMatrix.\r\t^rows at: (aRow - 1).\r\t\t\t\r',			#stamp : 'AndyMarks 12/16/2023 10:04',			#package : #'Exercise@Matrix'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Matrix,				#isMetaSide : false			},			#name : #'input:atRow:',			#protocol : #querying,			#sourceCode : 'input: aMatrix atRow: aRow\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| rows |\r\t\r\trows := \'\\n\' split: aMatrix.\r\t^rows at: aRow.\r\t\t\t\r',			#stamp : 'AndyMarks 12/16/2023 10:07',			#package : #'Exercise@Matrix'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T10:10:18.509375+11:00' ],		#prior : OmReference [ '427' ],		#self : OmReference [ '428' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Matrix,				#isMetaSide : false			},			#name : #'input:atRow:',			#protocol : #querying,			#sourceCode : 'input: aMatrix atRow: aRow\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| rows |\r\t\r\trows := \'\\n\' split: aMatrix.\r\t^rows at: aRow.\r\t\t\t\r',			#stamp : 'AndyMarks 12/16/2023 10:07',			#package : #'Exercise@Matrix'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Matrix,				#isMetaSide : false			},			#name : #'input:atRow:',			#protocol : #querying,			#sourceCode : 'input: aMatrix atRow: aRow\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| rows |\r\t\r\t"rows := \'\\n\' split: aMatrix."\r\trows := aMatrix findTokens: String cr, String lf.\r\t^rows at: aRow.\r\t\t\t\r',			#stamp : 'AndyMarks 12/16/2023 10:10',			#package : #'Exercise@Matrix'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T10:13:41.716313+11:00' ],		#prior : OmReference [ '428' ],		#self : OmReference [ '429' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Matrix,				#isMetaSide : false			},			#name : #'input:atRow:',			#protocol : #querying,			#sourceCode : 'input: aMatrix atRow: aRow\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| rows |\r\t\r\t"rows := \'\\n\' split: aMatrix."\r\trows := aMatrix findTokens: String cr, String lf.\r\t^rows at: aRow.\r\t\t\t\r',			#stamp : 'AndyMarks 12/16/2023 10:10',			#package : #'Exercise@Matrix'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Matrix,				#isMetaSide : false			},			#name : #'input:atRow:',			#protocol : #querying,			#sourceCode : 'input: aMatrix atRow: aRow\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| rows row |\r\t\r\t"rows := \'\\n\' split: aMatrix."\r\trows := aMatrix findTokens: String cr, String lf.\r\trow := rows at: aRow.\r\t^row findTokens: String space.\r\t\t\t\r',			#stamp : 'AndyMarks 12/16/2023 10:13',			#package : #'Exercise@Matrix'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T10:18:03.973092+11:00' ],		#prior : OmReference [ '429' ],		#self : OmReference [ '430' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Matrix,				#isMetaSide : false			},			#name : #'input:atRow:',			#protocol : #querying,			#sourceCode : 'input: aMatrix atRow: aRow\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| rows row |\r\t\r\t"rows := \'\\n\' split: aMatrix."\r\trows := aMatrix findTokens: String cr, String lf.\r\trow := rows at: aRow.\r\t^row findTokens: String space.\r\t\t\t\r',			#stamp : 'AndyMarks 12/16/2023 10:13',			#package : #'Exercise@Matrix'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Matrix,				#isMetaSide : false			},			#name : #'input:atRow:',			#protocol : #querying,			#sourceCode : 'input: aMatrix atRow: aRow\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| rows row |\r\t\r\t"rows := \'\\n\' split: aMatrix."\r\trows := aMatrix findTokens: String cr, String lf.\r\trow := (rows at: aRow) findTokens: String space.\r\t^row \r\t\t\t\r',			#stamp : 'AndyMarks 12/16/2023 10:18',			#package : #'Exercise@Matrix'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T10:18:06.44087+11:00' ],		#prior : OmReference [ '430' ],		#self : OmReference [ '431' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Matrix,				#isMetaSide : false			},			#name : #'input:atRow:',			#protocol : #querying,			#sourceCode : 'input: aMatrix atRow: aRow\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| rows row |\r\t\r\t"rows := \'\\n\' split: aMatrix."\r\trows := aMatrix findTokens: String cr, String lf.\r\trow := (rows at: aRow) findTokens: String space.\r\t^row \r\t\t\t\r',			#stamp : 'AndyMarks 12/16/2023 10:18',			#package : #'Exercise@Matrix'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Matrix,				#isMetaSide : false			},			#name : #'input:atRow:',			#protocol : #querying,			#sourceCode : 'input: aMatrix atRow: aRow\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| rows row |\r\t\r\t"rows := \'\\n\' split: aMatrix."\r\trows := aMatrix findTokens: String cr, String lf.\r\trow := (rows at: aRow) findTokens: String space.\r\t^row. \r\t\t\t\r',			#stamp : 'AndyMarks 12/16/2023 10:18',			#package : #'Exercise@Matrix'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T10:20:35.763596+11:00' ],		#prior : OmReference [ '431' ],		#self : OmReference [ '432' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Matrix,				#isMetaSide : false			},			#name : #'input:atRow:',			#protocol : #querying,			#sourceCode : 'input: aMatrix atRow: aRow\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| rows row |\r\t\r\t"rows := \'\\n\' split: aMatrix."\r\trows := aMatrix findTokens: String cr, String lf.\r\trow := (rows at: aRow) findTokens: String space.\r\t^row. \r\t\t\t\r',			#stamp : 'AndyMarks 12/16/2023 10:18',			#package : #'Exercise@Matrix'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Matrix,				#isMetaSide : false			},			#name : #'input:atRow:',			#protocol : #querying,			#sourceCode : 'input: aMatrix atRow: aRow\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| rows row |\r\t\r\t"rows := \'\\n\' split: aMatrix."\r\trows := aMatrix findTokens: String cr, String lf.\r\trow := (rows at: aRow) findTokens: String space.\r\t\r\trow doWithIndex: [ :value :index | row at: index update: value].\r\t\r\t^row. \r\t\t\t\r',			#stamp : 'AndyMarks 12/16/2023 10:20',			#package : #'Exercise@Matrix'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T10:22:03.229484+11:00' ],		#prior : OmReference [ '432' ],		#self : OmReference [ '433' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Matrix,				#isMetaSide : false			},			#name : #'input:atRow:',			#protocol : #querying,			#sourceCode : 'input: aMatrix atRow: aRow\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| rows row |\r\t\r\t"rows := \'\\n\' split: aMatrix."\r\trows := aMatrix findTokens: String cr, String lf.\r\trow := (rows at: aRow) findTokens: String space.\r\t\r\trow doWithIndex: [ :value :index | row at: index update: value].\r\t\r\t^row. \r\t\t\t\r',			#stamp : 'AndyMarks 12/16/2023 10:20',			#package : #'Exercise@Matrix'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Matrix,				#isMetaSide : false			},			#name : #'input:atRow:',			#protocol : #querying,			#sourceCode : 'input: aMatrix atRow: aRow\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| rows row |\r\t\r\t"rows := \'\\n\' split: aMatrix."\r\trows := aMatrix findTokens: String cr, String lf.\r\trow := (rows at: aRow) findTokens: String space.\r\t\r\trow doWithIndex: [ :value :index | row at: index put: value].\r\t\r\t^row. \r\t\t\t\r',			#stamp : 'AndyMarks 12/16/2023 10:22',			#package : #'Exercise@Matrix'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T10:22:28.331038+11:00' ],		#prior : OmReference [ '433' ],		#self : OmReference [ '434' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Matrix,				#isMetaSide : false			},			#name : #'input:atRow:',			#protocol : #querying,			#sourceCode : 'input: aMatrix atRow: aRow\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| rows row |\r\t\r\t"rows := \'\\n\' split: aMatrix."\r\trows := aMatrix findTokens: String cr, String lf.\r\trow := (rows at: aRow) findTokens: String space.\r\t\r\trow doWithIndex: [ :value :index | row at: index put: value].\r\t\r\t^row. \r\t\t\t\r',			#stamp : 'AndyMarks 12/16/2023 10:22',			#package : #'Exercise@Matrix'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Matrix,				#isMetaSide : false			},			#name : #'input:atRow:',			#protocol : #querying,			#sourceCode : 'input: aMatrix atRow: aRow\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| rows row |\r\t\r\t"rows := \'\\n\' split: aMatrix."\r\trows := aMatrix findTokens: String cr, String lf.\r\trow := (rows at: aRow) findTokens: String space.\r\t\r\trow doWithIndex: [ :value :index | row at: index put: value asInteger ].\r\t\r\t^row. \r\t\t\t\r',			#stamp : 'AndyMarks 12/16/2023 10:22',			#package : #'Exercise@Matrix'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T10:24:38.36398+11:00' ],		#prior : OmReference [ '434' ],		#self : OmReference [ '435' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Matrix,				#isMetaSide : false			},			#name : #'input:atRow:',			#protocol : #querying,			#sourceCode : 'input: aMatrix atRow: aRow\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| rows row |\r\t\r\t"rows := \'\\n\' split: aMatrix."\r\trows := aMatrix findTokens: String cr, String lf.\r\trow := (rows at: aRow) findTokens: String space.\r\t\r\trow doWithIndex: [ :value :index | row at: index put: value asInteger ].\r\t\r\t^row. \r\t\t\t\r',			#stamp : 'AndyMarks 12/16/2023 10:22',			#package : #'Exercise@Matrix'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Matrix,				#isMetaSide : false			},			#name : #'input:atRow:',			#protocol : #querying,			#sourceCode : 'input: aMatrix atRow: aRow\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| rows row |\r\t\r\t"rows := \'\\n\' split: aMatrix."\r\trows := aMatrix findTokens: String cr, String lf.\r\trow := (rows at: aRow) findTokens: String space.\r\t\r\trow doWithIndex: [ :value :index | row at: index put: value asInteger ].\r\t\r\t^row asOrderedCollection. \r\t\t\t\r',			#stamp : 'AndyMarks 12/16/2023 10:24',			#package : #'Exercise@Matrix'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T10:25:06.627794+11:00' ],		#prior : OmReference [ '435' ],		#self : OmReference [ '436' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Matrix,				#isMetaSide : false			},			#name : #'input:atRow:',			#protocol : #querying,			#sourceCode : 'input: aMatrix atRow: aRow\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| rows row |\r\t\r\t"rows := \'\\n\' split: aMatrix."\r\trows := aMatrix findTokens: String cr, String lf.\r\trow := (rows at: aRow) findTokens: String space.\r\t\r\trow doWithIndex: [ :value :index | row at: index put: value asInteger ].\r\t\r\t^row asOrderedCollection. \r\t\t\t\r',			#stamp : 'AndyMarks 12/16/2023 10:24',			#package : #'Exercise@Matrix'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Matrix,				#isMetaSide : false			},			#name : #'input:atRow:',			#protocol : #querying,			#sourceCode : 'input: aMatrix atRow: aRow\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| rows row |\r\t\r\t"rows := \'\\n\' split: aMatrix."\r\trows := aMatrix findTokens: String cr, String lf.\r\trow := (rows at: aRow) findTokens: String space.\r\t\r\trow doWithIndex: [ :value :index | row at: index put: value asInteger ].\r\t\r\t^row asArray . \r\t\t\t\r',			#stamp : 'AndyMarks 12/16/2023 10:25',			#package : #'Exercise@Matrix'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T10:25:35.044588+11:00' ],		#prior : OmReference [ '436' ],		#self : OmReference [ '437' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Matrix,				#isMetaSide : false			},			#name : #'input:atRow:',			#protocol : #querying,			#sourceCode : 'input: aMatrix atRow: aRow\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| rows row |\r\t\r\t"rows := \'\\n\' split: aMatrix."\r\trows := aMatrix findTokens: String cr, String lf.\r\trow := (rows at: aRow) findTokens: String space.\r\t\r\trow doWithIndex: [ :value :index | row at: index put: value asInteger ].\r\t\r\t^row asArray . \r\t\t\t\r',			#stamp : 'AndyMarks 12/16/2023 10:25',			#package : #'Exercise@Matrix'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Matrix,				#isMetaSide : false			},			#name : #'input:atRow:',			#protocol : #querying,			#sourceCode : 'input: aMatrix atRow: aRow\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| rows row |\r\t\r\trows := aMatrix findTokens: String cr, String lf.\r\trow := (rows at: aRow) findTokens: String space.\r\t\r\trow doWithIndex: [ :value :index | row at: index put: value asInteger ].\r\t\r\t^row asArray . \r\t\t\t\r',			#stamp : 'AndyMarks 12/16/2023 10:25',			#package : #'Exercise@Matrix'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T10:26:04.709668+11:00' ],		#prior : OmReference [ '437' ],		#self : OmReference [ '438' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Matrix,				#isMetaSide : false			},			#name : #'input:atColumn:',			#protocol : #querying,			#sourceCode : 'input: aMatrix atColumn: aColumn\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r',			#stamp : 'AndyMarks 12/16/2023 09:04',			#package : #'Exercise@Matrix'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Matrix,				#isMetaSide : false			},			#name : #'input:atColumn:',			#protocol : #querying,			#sourceCode : 'input: aMatrix atColumn: aColumn\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| rows row |\r\t\r\trows := aMatrix findTokens: String cr, String lf.\r\trow := (rows at: aColumn) findTokens: String space.\r\t\r\trow doWithIndex: [ :value :index | row at: index put: value asInteger ].\r\t\r\t^row asArray . \r',			#stamp : 'AndyMarks 12/16/2023 10:26',			#package : #'Exercise@Matrix'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T10:28:52.954359+11:00' ],		#prior : OmReference [ '438' ],		#self : OmReference [ '439' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Matrix,				#isMetaSide : false			},			#name : #'input:atColumn:',			#protocol : #querying,			#sourceCode : 'input: aMatrix atColumn: aColumn\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| rows row |\r\t\r\trows := aMatrix findTokens: String cr, String lf.\r\trow := (rows at: aColumn) findTokens: String space.\r\t\r\trow doWithIndex: [ :value :index | row at: index put: value asInteger ].\r\t\r\t^row asArray . \r',			#stamp : 'AndyMarks 12/16/2023 10:26',			#package : #'Exercise@Matrix'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Matrix,				#isMetaSide : false			},			#name : #'input:atColumn:',			#protocol : #querying,			#sourceCode : 'input: aMatrix atColumn: aColumn\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| rows column |\r\t\r\trows := aMatrix findTokens: String cr, String lf.\r\tcolumn := rows select: [ :row | (row findTokens: String space) at: aColumn  ].\r\t\r\t^column asArray . \r',			#stamp : 'AndyMarks 12/16/2023 10:28',			#package : #'Exercise@Matrix'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T10:29:26.017596+11:00' ],		#prior : OmReference [ '439' ],		#self : OmReference [ '440' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Matrix,				#isMetaSide : false			},			#name : #'input:atColumn:',			#protocol : #querying,			#sourceCode : 'input: aMatrix atColumn: aColumn\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| rows column |\r\t\r\trows := aMatrix findTokens: String cr, String lf.\r\tcolumn := rows select: [ :row | (row findTokens: String space) at: aColumn  ].\r\t\r\t^column asArray . \r',			#stamp : 'AndyMarks 12/16/2023 10:28',			#package : #'Exercise@Matrix'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Matrix,				#isMetaSide : false			},			#name : #'input:atColumn:',			#protocol : #querying,			#sourceCode : 'input: aMatrix atColumn: aColumn\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| rows column |\r\t\r\trows := aMatrix findTokens: String cr, String lf.\r\tcolumn := rows do: [ :row | (row findTokens: String space) at: aColumn  ].\r\t\r\t^column asArray . \r',			#stamp : 'AndyMarks 12/16/2023 10:29',			#package : #'Exercise@Matrix'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T10:41:02.920691+11:00' ],		#prior : OmReference [ '440' ],		#self : OmReference [ '441' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Matrix,				#isMetaSide : false			},			#name : #'input:atColumn:',			#protocol : #querying,			#sourceCode : 'input: aMatrix atColumn: aColumn\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| rows column |\r\t\r\trows := aMatrix findTokens: String cr, String lf.\r\tcolumn := rows do: [ :row | (row findTokens: String space) at: aColumn  ].\r\t\r\t^column asArray . \r',			#stamp : 'AndyMarks 12/16/2023 10:29',			#package : #'Exercise@Matrix'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Matrix,				#isMetaSide : false			},			#name : #'input:atColumn:',			#protocol : #querying,			#sourceCode : 'input: aMatrix atColumn: aColumn\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| rows column |\r\t\r\trows := aMatrix findTokens: String cr, String lf.\r\tcolumn := rows collect: [ :row | ((row findTokens: String space) at: 2) asInteger  ].\r\t\r\t^column asArray . \r',			#stamp : 'AndyMarks 12/16/2023 10:41',			#package : #'Exercise@Matrix'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T10:41:07.868584+11:00' ],		#prior : OmReference [ '441' ],		#self : OmReference [ '442' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Matrix,				#isMetaSide : false			},			#name : #'input:atColumn:',			#protocol : #querying,			#sourceCode : 'input: aMatrix atColumn: aColumn\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| rows column |\r\t\r\trows := aMatrix findTokens: String cr, String lf.\r\tcolumn := rows collect: [ :row | ((row findTokens: String space) at: 2) asInteger  ].\r\t\r\t^column asArray . \r',			#stamp : 'AndyMarks 12/16/2023 10:41',			#package : #'Exercise@Matrix'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Matrix,				#isMetaSide : false			},			#name : #'input:atColumn:',			#protocol : #querying,			#sourceCode : 'input: aMatrix atColumn: aColumn\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| rows column |\r\t\r\trows := aMatrix findTokens: String cr, String lf.\r\tcolumn := rows collect: [ :row | ((row findTokens: String space) at: aColumn) asInteger  ].\r\t\r\t^column asArray . \r',			#stamp : 'AndyMarks 12/16/2023 10:41',			#package : #'Exercise@Matrix'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T10:42:09.056655+11:00' ],		#prior : OmReference [ '442' ],		#self : OmReference [ '443' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Matrix,				#isMetaSide : false			},			#name : #'input:atRow:',			#protocol : #querying,			#sourceCode : 'input: aMatrix atRow: aRow\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| rows row |\r\t\r\trows := aMatrix findTokens: String cr, String lf.\r\trow := (rows at: aRow) findTokens: String space.\r\t\r\trow doWithIndex: [ :value :index | row at: index put: value asInteger ].\r\t\r\t^row asArray . \r\t\t\t\r',			#stamp : 'AndyMarks 12/16/2023 10:25',			#package : #'Exercise@Matrix'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Matrix,				#isMetaSide : false			},			#name : #'input:atRow:',			#protocol : #querying,			#sourceCode : 'input: aMatrix atRow: aRow\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| rows row |\r\t\r\trows := aMatrix findTokens: String cr, String lf.\r\trow := (rows at: aRow) findTokens: String space.\r\t\r\t^row collect: [ :value | value asInteger ] asArray.\r\t\t\t\r',			#stamp : 'AndyMarks 12/16/2023 10:42',			#package : #'Exercise@Matrix'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T10:42:27.279763+11:00' ],		#prior : OmReference [ '443' ],		#self : OmReference [ '444' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Matrix,				#isMetaSide : false			},			#name : #'input:atRow:',			#protocol : #querying,			#sourceCode : 'input: aMatrix atRow: aRow\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| rows row |\r\t\r\trows := aMatrix findTokens: String cr, String lf.\r\trow := (rows at: aRow) findTokens: String space.\r\t\r\t^row collect: [ :value | value asInteger ] asArray.\r\t\t\t\r',			#stamp : 'AndyMarks 12/16/2023 10:42',			#package : #'Exercise@Matrix'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Matrix,				#isMetaSide : false			},			#name : #'input:atRow:',			#protocol : #querying,			#sourceCode : 'input: aMatrix atRow: aRow\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| rows row |\r\t\r\trows := aMatrix findTokens: String cr, String lf.\r\trow := (rows at: aRow) findTokens: String space.\r\t\r\t^(row collect: [ :value | value asInteger ]) asArray.\r\t\t\t\r',			#stamp : 'AndyMarks 12/16/2023 10:42',			#package : #'Exercise@Matrix'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T11:08:56.517992+11:00' ],		#prior : OmReference [ '444' ],		#self : OmReference [ '445' ]	},	#content : EpCategoryAddition {		#classCategoryName : #'Exercise@GradeSchool',		#affectedPackageName : #'Exercise@GradeSchool'	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T11:08:56.519868+11:00' ],		#prior : OmReference [ '445' ],		#self : OmReference [ '446' ]	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'ExercismTest subclass: #GradeSchoolTest\r\tinstanceVariableNames: \'gradeSchoolCalculator\'\r\tclassVariableNames: \'\'\r\tpackage: \'Exercise@GradeSchool\'',				#superclassName : 'ExercismTest'			},			#name : #GradeSchoolTest,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #GradeSchoolTest,						#isMetaSide : false					},					#name : #gradeSchoolCalculator,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'GradeSchoolTest class\r\tinstanceVariableNames: \'\''				},				#name : #'GradeSchoolTest class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #GradeSchoolTest,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #'Exercise@GradeSchool',			#package : #'Exercise@GradeSchool',			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T11:08:56.521821+11:00' ],		#prior : OmReference [ '446' ],		#self : OmReference [ '447' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'ExercismTest subclass: #GradeSchoolTest\r\tinstanceVariableNames: \'gradeSchoolCalculator\'\r\tclassVariableNames: \'\'\r\tpackage: \'Exercise@GradeSchool\'',				#superclassName : 'ExercismTest'			},			#name : #GradeSchoolTest,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #GradeSchoolTest,						#isMetaSide : false					},					#name : #gradeSchoolCalculator,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'GradeSchoolTest class\r\tinstanceVariableNames: \'\''				},				#name : #'GradeSchoolTest class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #GradeSchoolTest,					#isMetaSide : false				},				#parent : @7,				#content : '# Grade School\r\rGiven students\' names along with the grade that they are in, create a roster\rfor the school.\r\rIn the end, you should be able to:\r\r- Add a student\'s name to the roster for a grade\r  - "Add Jim to grade 2."\r  - "OK."\r- Get a list of all students enrolled in a grade\r  - "Which students are in grade 2?"\r  - "We\'ve only got Jim just now."\r- Get a sorted list of all students in all grades.  Grades should sort\r  as 1, 2, 3, etc., and students within a grade should be sorted\r  alphabetically by name.\r  - "Who all is enrolled in school right now?"\r  - "Grade 1: Anna, Barb, and Charlie. Grade 2: Alex, Peter, and Zoe.\r    Grade 3…"\r\rNote that all our students only have one name.  (It\'s a small town, what\rdo you want?)\r\r## For bonus points\r\rDid you get the tests passing and the code clean? If you want to, these\rare some additional things you could try:\r\r- If you\'re working in a language with mutable data structures and your\r  implementation allows outside code to mutate the school\'s internal DB\r  directly, see if you can prevent this. Feel free to introduce additional\r  tests.\r\rThen please share your thoughts in a comment on the submission. Did this\rexperiment make the code better? Worse? Did you learn anything from it?\r\r## Hint\r\rIt isn\'t strictly necessary to model students as a seperate object, you can use a convenient internal data strcture as the requirements are quite simple (and as long as it doesn\'t leak out into the results).\r\rNote: this exercise has been slightly modified from the problem-specification, as it makes more sense to seperate adding students and querying them in seperate methods (vs. having one method doing both, which feels less Pharo/Smalltalk like).\r',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #'Exercise@GradeSchool',			#package : #'Exercise@GradeSchool',			#sharedPools : OrderedCollection [ ]		},		#oldComment : '',		#newComment : '# Grade School\r\rGiven students\' names along with the grade that they are in, create a roster\rfor the school.\r\rIn the end, you should be able to:\r\r- Add a student\'s name to the roster for a grade\r  - "Add Jim to grade 2."\r  - "OK."\r- Get a list of all students enrolled in a grade\r  - "Which students are in grade 2?"\r  - "We\'ve only got Jim just now."\r- Get a sorted list of all students in all grades.  Grades should sort\r  as 1, 2, 3, etc., and students within a grade should be sorted\r  alphabetically by name.\r  - "Who all is enrolled in school right now?"\r  - "Grade 1: Anna, Barb, and Charlie. Grade 2: Alex, Peter, and Zoe.\r    Grade 3…"\r\rNote that all our students only have one name.  (It\'s a small town, what\rdo you want?)\r\r## For bonus points\r\rDid you get the tests passing and the code clean? If you want to, these\rare some additional things you could try:\r\r- If you\'re working in a language with mutable data structures and your\r  implementation allows outside code to mutate the school\'s internal DB\r  directly, see if you can prevent this. Feel free to introduce additional\r  tests.\r\rThen please share your thoughts in a comment on the submission. Did this\rexperiment make the code better? Worse? Did you learn anything from it?\r\r## Hint\r\rIt isn\'t strictly necessary to model students as a seperate object, you can use a convenient internal data strcture as the requirements are quite simple (and as long as it doesn\'t leak out into the results).\r\rNote: this exercise has been slightly modified from the problem-specification, as it makes more sense to seperate adding students and querying them in seperate methods (vs. having one method doing both, which feels less Pharo/Smalltalk like).\r',		#oldStamp : '',		#newStamp : ''	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T11:08:56.57424+11:00' ],		#prior : OmReference [ '447' ],		#self : OmReference [ '448' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'GradeSchoolTest class',				#isMetaSide : true			},			#name : #exercise,			#protocol : #config,			#sourceCode : 'exercise\r\t"Answer the configured exercise meta data for this exercise, an ExercismExercise"\r\t\r\t\r\t^(self createExerciseAfter: MatrixTest)\r\t\tisCore: true;\r\t\tdifficulty: 4;\r\t\ttopics: #(\'sorting\' \'filtering\' \'lists\' \'object_oriented_programming\');\r\t\tyourself\r\t\t\t\t',			#stamp : '',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T11:08:56.574941+11:00' ],		#prior : OmReference [ '448' ],		#self : OmReference [ '449' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'GradeSchoolTest class',				#isMetaSide : true			},			#name : #generator,			#protocol : #generator,			#sourceCode : 'generator\r\t"Potential generator hints"\r\t\r\t^ {(\'rosterStudents:\' -> #(\'addStudents:\' \'roster\')).\r\t(\'gradeStudents:desiredGrade:\' -> #(\'addStudents:\' \'desiredGrade:\'))}',			#stamp : '',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T11:08:56.576331+11:00' ],		#prior : OmReference [ '449' ],		#self : OmReference [ '450' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'GradeSchoolTest class',				#isMetaSide : true			},			#name : #uuid,			#protocol : #config,			#sourceCode : 'uuid\r\t"Answer a unique id for this exercise"\r\t^\'8198e8bb-8040-0d00-812f-dfab01deb008\'',			#stamp : '',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T11:08:56.576796+11:00' ],		#prior : OmReference [ '450' ],		#self : OmReference [ '451' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'GradeSchoolTest class',				#isMetaSide : true			},			#name : #version,			#protocol : #config,			#sourceCode : 'version\r\t"Generated from specification: 15 March 2019"\r\t^\'1.0.0\'',			#stamp : '',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T11:08:56.577152+11:00' ],		#prior : OmReference [ '451' ],		#self : OmReference [ '452' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchoolTest,				#isMetaSide : false			},			#name : #setUp,			#protocol : #running,			#sourceCode : 'setUp\r\tsuper setUp.\r\tgradeSchoolCalculator := GradeSchool new',			#stamp : '',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T11:08:56.579811+11:00' ],		#prior : OmReference [ '452' ],		#self : OmReference [ '453' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchoolTest,				#isMetaSide : false			},			#name : #test01_AddingAStudentAddsThemToTheSortedRoster,			#protocol : #tests,			#sourceCode : 'test01_AddingAStudentAddsThemToTheSortedRoster\r\t| result |\r\r\tresult := gradeSchoolCalculator\r\t\taddStudents: #(#(\'Aimee\' 2));\r\t\troster.\r\t\t\r\tself assert: result equals: #(\'Aimee\')',			#stamp : '',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T11:08:56.58006+11:00' ],		#prior : OmReference [ '453' ],		#self : OmReference [ '454' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchoolTest,				#isMetaSide : false			},			#name : #test02_AddingMoreStudentAddsThemToTheSortedRoster,			#protocol : #tests,			#sourceCode : 'test02_AddingMoreStudentAddsThemToTheSortedRoster\r\t| result |\r\r\tresult := gradeSchoolCalculator\r\t\taddStudents: #(#(\'Blair\' 2) #(\'James\' 2) #(\'Paul\' 2));\r\t\troster.\r\t\t\r\tself assert: result equals: #(\'Blair\' \'James\' \'Paul\')',			#stamp : '',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T11:08:56.58026+11:00' ],		#prior : OmReference [ '454' ],		#self : OmReference [ '455' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchoolTest,				#isMetaSide : false			},			#name : #test03_AddingStudentsToDifferentGradesAddsThemToTheSameSortedRoster,			#protocol : #tests,			#sourceCode : 'test03_AddingStudentsToDifferentGradesAddsThemToTheSameSortedRoster\r\t| result |\r\r\tresult := gradeSchoolCalculator\r\t\taddStudents: #(#(\'Chelsea\' 3) #(\'Logan\' 7));\r\t\troster.\r\t\t\r\tself assert: result equals: #(\'Chelsea\' \'Logan\')',			#stamp : '',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T11:08:56.580472+11:00' ],		#prior : OmReference [ '455' ],		#self : OmReference [ '456' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchoolTest,				#isMetaSide : false			},			#name : #test04_RosterReturnsAnEmptyListIfThereAreNoStudentsEnrolled,			#protocol : #tests,			#sourceCode : 'test04_RosterReturnsAnEmptyListIfThereAreNoStudentsEnrolled\r\t| result |\r\r\tresult := gradeSchoolCalculator\r\t\taddStudents: #();\r\t\troster.\r\t\t\r\tself assert: result equals: #()',			#stamp : '',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T11:08:56.580656+11:00' ],		#prior : OmReference [ '456' ],		#self : OmReference [ '457' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchoolTest,				#isMetaSide : false			},			#name : #test05_StudentNamesWithGradesAreDisplayedInTheSameSortedRoster,			#protocol : #tests,			#sourceCode : 'test05_StudentNamesWithGradesAreDisplayedInTheSameSortedRoster\r\t| result |\r\r\tresult := gradeSchoolCalculator\r\t\taddStudents:\r\t\t\t#(#(\'Peter\' 2) #(\'Anna\' 1) #(\'Barb\' 1) #(\'Zoe\' 2) #(\'Alex\' 2) #(\'Jim\' 3) #(\'Charlie\' 1));\r\t\troster.\r\t\t\r\tself\r\t\tassert: result\r\t\tequals: #(\'Anna\' \'Barb\' \'Charlie\' \'Alex\' \'Peter\' \'Zoe\' \'Jim\')',			#stamp : '',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T11:08:56.58082+11:00' ],		#prior : OmReference [ '457' ],		#self : OmReference [ '458' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchoolTest,				#isMetaSide : false			},			#name : #test06_GradeReturnsTheStudentsInThatGradeInAlphabeticalOrder,			#protocol : #tests,			#sourceCode : 'test06_GradeReturnsTheStudentsInThatGradeInAlphabeticalOrder\r\t| result |\r\r\tresult := gradeSchoolCalculator addStudents: #(#(\'Franklin\' 5 ) #(\'Bradley\' 5 ) #(\'Jeff\' 1 ) ); desiredGrade: 5.\r\tself assert: result equals: #(\'Bradley\' \'Franklin\' )',			#stamp : '',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T11:08:56.580979+11:00' ],		#prior : OmReference [ '458' ],		#self : OmReference [ '459' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchoolTest,				#isMetaSide : false			},			#name : #test07_GradeReturnsAnEmptyListIfThereAreNoStudentsInThatGrade,			#protocol : #tests,			#sourceCode : 'test07_GradeReturnsAnEmptyListIfThereAreNoStudentsInThatGrade\r\t| result |\r\r\tresult := gradeSchoolCalculator\r\t\taddStudents: #();\r\t\tdesiredGrade: 1.\r\t\t\r\tself assert: result equals: #()',			#stamp : '',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T11:08:56.581153+11:00' ],		#prior : OmReference [ '459' ],		#self : OmReference [ '460' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchoolTest,				#isMetaSide : false			},			#name : #test100_EnsureDataIsImmutable,			#protocol : #tests-extra,			#sourceCode : 'test100_EnsureDataIsImmutable\r\t| result |\r\r\tresult := gradeSchoolCalculator\r\t\taddStudents: #(#(\'Chelsea\' 3) #(\'Logan\' 7));\r\t\tyourself.\r\t\t\r\tresult roster at: 1 put: \'Not Chelsea\'.\r\t\t\r\tself assert: result roster equals: #(\'Chelsea\' \'Logan\')',			#stamp : '',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T11:09:21.902505+11:00' ],		#prior : OmReference [ '460' ],		#self : OmReference [ '461' ]	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #GradeSchool\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpackage: \'Exercise@GradeSchool\'',				#superclassName : 'Object'			},			#name : #GradeSchool,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'GradeSchool class\r\tinstanceVariableNames: \'\''				},				#name : #'GradeSchool class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #GradeSchool,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #'Exercise@GradeSchool',			#package : #'Exercise@GradeSchool',			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T11:10:56.152283+11:00' ],		#prior : OmReference [ '461' ],		#self : OmReference [ '462' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #'as yet unclassified',			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/16/2023 11:10',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T11:10:56.164894+11:00' ],		#prior : OmReference [ '462' ],		#self : OmReference [ '463' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #'as yet unclassified',			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/16/2023 11:10',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/16/2023 11:10',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T11:11:13.826153+11:00' ],		#prior : OmReference [ '463' ],		#self : OmReference [ '464' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #roster,			#protocol : #'as yet unclassified',			#sourceCode : 'roster\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r',			#stamp : 'AndyMarks 12/16/2023 11:11',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T11:11:24.756133+11:00' ],		#prior : OmReference [ '464' ],		#self : OmReference [ '465' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #roster,			#protocol : #'as yet unclassified',			#sourceCode : 'roster\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r',			#stamp : 'AndyMarks 12/16/2023 11:11',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #roster,			#protocol : #'accessing - query',			#sourceCode : 'roster\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r',			#stamp : 'AndyMarks 12/16/2023 11:11',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T11:12:02.181255+11:00' ],		#prior : OmReference [ '465' ],		#self : OmReference [ '466' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'desiredGrade:',			#protocol : #adding,			#sourceCode : 'desiredGrade: aGrade\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t^self.',			#stamp : 'AndyMarks 12/16/2023 11:12',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T11:12:21.442815+11:00' ],		#prior : OmReference [ '466' ],		#self : OmReference [ '467' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'desiredGrade:',			#protocol : #adding,			#sourceCode : 'desiredGrade: aGrade\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t^self.',			#stamp : 'AndyMarks 12/16/2023 11:12',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'desiredGrade:',			#protocol : #'accessing - query',			#sourceCode : 'desiredGrade: aGrade\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t^self.',			#stamp : 'AndyMarks 12/16/2023 11:12',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T11:13:15.630281+11:00' ],		#prior : OmReference [ '467' ],		#self : OmReference [ '468' ]	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #MyClass\r\tinstanceVariableNames: \'students\'\r\tclassVariableNames: \'\'\r\tpackage: \'Exercise@GradeSchool\'',				#superclassName : 'Object'			},			#name : #MyClass,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #MyClass,						#isMetaSide : false					},					#name : #students,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'MyClass class\r\tinstanceVariableNames: \'\''				},				#name : #'MyClass class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #MyClass,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #'Exercise@GradeSchool',			#package : #'Exercise@GradeSchool',			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T11:13:45.612457+11:00' ],		#prior : OmReference [ '468' ],		#self : OmReference [ '469' ]	},	#content : EpGenericRefactoring {		#storeString : '(RBRemoveClassRefactoring classNames: #(#MyClass))'	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '469' ],		#self : OmReference [ '470' ],		#time : DateAndTime [ '2023-12-16T11:13:45.714032+11:00' ],		#trigger : @3	},	#content : EpClassRemoval {		#classRemoved : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #MyClass\r\tinstanceVariableNames: \'students\'\r\tclassVariableNames: \'\'\r\tpackage: #\'Exercise@GradeSchool\'',				#superclassName : 'Object'			},			#name : #MyClass,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #AnObsoleteMyClass,						#isMetaSide : false					},					#name : #students,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'MyClass class\r\tinstanceVariableNames: \'\''				},				#name : #'AnObsoleteMyClass class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #AnObsoleteMyClass,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #'Exercise@GradeSchool',			#package : #'Exercise@GradeSchool',			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T11:13:51.365259+11:00' ],		#prior : OmReference [ '470' ],		#self : OmReference [ '471' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #GradeSchool\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpackage: \'Exercise@GradeSchool\'',				#superclassName : 'Object'			},			#name : #GradeSchool,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'GradeSchool class\r\tinstanceVariableNames: \'\''				},				#name : #'GradeSchool class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #GradeSchool,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #'Exercise@GradeSchool',			#package : #'Exercise@GradeSchool',			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #GradeSchool\r\tinstanceVariableNames: \'students\'\r\tclassVariableNames: \'\'\r\tpackage: \'Exercise@GradeSchool\'',				#superclassName : 'Object'			},			#name : #GradeSchool,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #GradeSchool,						#isMetaSide : false					},					#name : #students,					#parent : @21				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'GradeSchool class\r\tinstanceVariableNames: \'\''				},				#name : #'GradeSchool class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @21			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #GradeSchool,					#isMetaSide : false				},				#parent : @21,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #'Exercise@GradeSchool',			#package : #'Exercise@GradeSchool',			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T11:14:10.212586+11:00' ],		#prior : OmReference [ '471' ],		#self : OmReference [ '472' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/16/2023 11:10',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\tstudents := aStudentArray .\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/16/2023 11:14',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T11:14:19.390124+11:00' ],		#prior : OmReference [ '472' ],		#self : OmReference [ '473' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #roster,			#protocol : #'accessing - query',			#sourceCode : 'roster\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r',			#stamp : 'AndyMarks 12/16/2023 11:11',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #roster,			#protocol : #'accessing - query',			#sourceCode : 'roster\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t^students .\r\t\t\t\r',			#stamp : 'AndyMarks 12/16/2023 11:14',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T11:18:00.726883+11:00' ],		#prior : OmReference [ '473' ],		#self : OmReference [ '474' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\tstudents := aStudentArray .\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/16/2023 11:14',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\taStudentArray do: [ :studentClassTuple | students at: (studentClassTuple at: 2) put: (studentClassTuple at: 1)].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/16/2023 11:18',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T11:19:01.288553+11:00' ],		#prior : OmReference [ '474' ],		#self : OmReference [ '475' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\taStudentArray do: [ :studentClassTuple | students at: (studentClassTuple at: 2) put: (studentClassTuple at: 1)].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/16/2023 11:18',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\tstudents := Dictionary new.\r\t\r\taStudentArray do: [ :studentClassTuple | students at: (studentClassTuple at: 2) put: (studentClassTuple at: 1)].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/16/2023 11:19',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T11:19:50.430033+11:00' ],		#prior : OmReference [ '475' ],		#self : OmReference [ '476' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #roster,			#protocol : #'accessing - query',			#sourceCode : 'roster\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t^students .\r\t\t\t\r',			#stamp : 'AndyMarks 12/16/2023 11:14',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #roster,			#protocol : #'accessing - query',			#sourceCode : 'roster\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t^students values  .\r\t\t\t\r',			#stamp : 'AndyMarks 12/16/2023 11:19',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T11:26:04.490931+11:00' ],		#prior : OmReference [ '476' ],		#self : OmReference [ '477' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\tstudents := Dictionary new.\r\t\r\taStudentArray do: [ :studentClassTuple | students at: (studentClassTuple at: 2) put: (studentClassTuple at: 1)].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/16/2023 11:19',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\tstudents := Dictionary new.\r\t\r\taStudentArray do: [ :studentClassTuple | \r\t\tstudents at: (studentClassTuple at: 2)\r\t\tifPresent: students at: (studentClassTuple at: 2) studentClassTuple at: 1\r\t\tifAbsentPut: studentClassTuple at: 1].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/16/2023 11:26',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T11:26:16.983037+11:00' ],		#prior : OmReference [ '477' ],		#self : OmReference [ '478' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\tstudents := Dictionary new.\r\t\r\taStudentArray do: [ :studentClassTuple | \r\t\tstudents at: (studentClassTuple at: 2)\r\t\tifPresent: students at: (studentClassTuple at: 2) studentClassTuple at: 1\r\t\tifAbsentPut: studentClassTuple at: 1].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/16/2023 11:26',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\tstudents := Dictionary new.\r\t\r\taStudentArray do: [ :studentClassTuple | \r\t\tstudents at: (studentClassTuple at: 2)\r\t\tifPresent: (students at: (studentClassTuple at: 2) studentClassTuple at: 1)\r\t\tifAbsentPut: studentClassTuple at: 1].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/16/2023 11:26',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T11:26:23.884403+11:00' ],		#prior : OmReference [ '478' ],		#self : OmReference [ '479' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\tstudents := Dictionary new.\r\t\r\taStudentArray do: [ :studentClassTuple | \r\t\tstudents at: (studentClassTuple at: 2)\r\t\tifPresent: (students at: (studentClassTuple at: 2) studentClassTuple at: 1)\r\t\tifAbsentPut: studentClassTuple at: 1].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/16/2023 11:26',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\tstudents := Dictionary new.\r\t\r\taStudentArray do: [ :studentClassTuple | \r\t\tstudents at: (studentClassTuple at: 2)\r\t\tifPresent: (students at: (studentClassTuple at: 2) studentClassTuple at: 1)\r\t\tifAbsentPut: (studentClassTuple at: 1)].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/16/2023 11:26',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T11:26:39.414519+11:00' ],		#prior : OmReference [ '479' ],		#self : OmReference [ '480' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\tstudents := Dictionary new.\r\t\r\taStudentArray do: [ :studentClassTuple | \r\t\tstudents at: (studentClassTuple at: 2)\r\t\tifPresent: (students at: (studentClassTuple at: 2) studentClassTuple at: 1)\r\t\tifAbsentPut: (studentClassTuple at: 1)].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/16/2023 11:26',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\tstudents := Dictionary new.\r\t\r\taStudentArray do: [ :studentClassTuple | \r\t\tstudents at: (studentClassTuple at: 2)\r\t\tifPresent: (students at: (studentClassTuple at: 2) put: studentClassTuple at: 1)\r\t\tifAbsentPut: (studentClassTuple at: 1)].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/16/2023 11:26',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T11:28:28.356844+11:00' ],		#prior : OmReference [ '480' ],		#self : OmReference [ '481' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\tstudents := Dictionary new.\r\t\r\taStudentArray do: [ :studentClassTuple | \r\t\tstudents at: (studentClassTuple at: 2)\r\t\tifPresent: (students at: (studentClassTuple at: 2) put: studentClassTuple at: 1)\r\t\tifAbsentPut: (studentClassTuple at: 1)].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/16/2023 11:26',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\tstudents := Dictionary new.\r\t\r\taStudentArray do: [ :studentClassTuple | \r\t\t| studentName studentClass |\r\t\tstudentName := (studentClassTuple at: 1). \r\t\tstudentClass := (studentClassTuple at: 2)].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/16/2023 11:28',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T11:31:37.07193+11:00' ],		#prior : OmReference [ '481' ],		#self : OmReference [ '482' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\tstudents := Dictionary new.\r\t\r\taStudentArray do: [ :studentClassTuple | \r\t\t| studentName studentClass |\r\t\tstudentName := (studentClassTuple at: 1). \r\t\tstudentClass := (studentClassTuple at: 2)].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/16/2023 11:28',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\tstudents := Dictionary new.\r\t\r\taStudentArray do: [ :studentClassTuple | \r\t\t| studentName studentClass |\r\t\tstudentName := (studentClassTuple at: 1). \r\t\tstudentClass := (studentClassTuple at: 2)\r\t\t\r\t\tstudents at: studentClass. \r\t\t].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/16/2023 11:31',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T11:31:47.105801+11:00' ],		#prior : OmReference [ '482' ],		#self : OmReference [ '483' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\tstudents := Dictionary new.\r\t\r\taStudentArray do: [ :studentClassTuple | \r\t\t| studentName studentClass |\r\t\tstudentName := (studentClassTuple at: 1). \r\t\tstudentClass := (studentClassTuple at: 2)\r\t\t\r\t\tstudents at: studentClass. \r\t\t].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/16/2023 11:31',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\tstudents := SmallDictionary new.\r\t\r\taStudentArray do: [ :studentClassTuple | \r\t\t| studentName studentClass |\r\t\tstudentName := (studentClassTuple at: 1). \r\t\tstudentClass := (studentClassTuple at: 2)\r\t\t\r\t\tstudents at: studentClass. \r\t\t].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/16/2023 11:31',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T11:33:38.780428+11:00' ],		#prior : OmReference [ '483' ],		#self : OmReference [ '484' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\tstudents := SmallDictionary new.\r\t\r\taStudentArray do: [ :studentClassTuple | \r\t\t| studentName studentClass |\r\t\tstudentName := (studentClassTuple at: 1). \r\t\tstudentClass := (studentClassTuple at: 2)\r\t\t\r\t\tstudents at: studentClass. \r\t\t].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/16/2023 11:31',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\tstudents := SmallDictionary new.\r\t\r\taStudentArray do: [ :studentClassTuple | \r\t\t| studentName studentClass |\r\t\tstudentName := (studentClassTuple at: 1). \r\t\tstudentClass := (studentClassTuple at: 2).\r\t\t\r\t\tstudents at: studentClass ifPresent: self ifAbsent: (students at: studentClass add: studentName).\r\t\t].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/16/2023 11:33',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T11:33:56.364831+11:00' ],		#prior : OmReference [ '484' ],		#self : OmReference [ '485' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\tstudents := SmallDictionary new.\r\t\r\taStudentArray do: [ :studentClassTuple | \r\t\t| studentName studentClass |\r\t\tstudentName := (studentClassTuple at: 1). \r\t\tstudentClass := (studentClassTuple at: 2).\r\t\t\r\t\tstudents at: studentClass ifPresent: self ifAbsent: (students at: studentClass add: studentName).\r\t\t].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/16/2023 11:33',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\tstudents := SmallDictionary new.\r\t\r\taStudentArray do: [ :studentClassTuple | \r\t\t| studentName studentClass |\r\t\tstudentName := (studentClassTuple at: 1). \r\t\tstudentClass := (studentClassTuple at: 2).\r\t\t\r\t\tstudents at: studentClass ifPresent: self ifAbsent: (students at: studentClass put: studentName).\r\t\t].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/16/2023 11:33',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T11:34:30.366214+11:00' ],		#prior : OmReference [ '485' ],		#self : OmReference [ '486' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\tstudents := SmallDictionary new.\r\t\r\taStudentArray do: [ :studentClassTuple | \r\t\t| studentName studentClass |\r\t\tstudentName := (studentClassTuple at: 1). \r\t\tstudentClass := (studentClassTuple at: 2).\r\t\t\r\t\tstudents at: studentClass ifPresent: self ifAbsent: (students at: studentClass put: studentName).\r\t\t].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/16/2023 11:33',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\tstudents := SmallDictionary new.\r\t\r\taStudentArray do: [ :studentClassTuple | \r\t\t| studentName studentClass |\r\t\tstudentName := (studentClassTuple at: 1). \r\t\tstudentClass := (studentClassTuple at: 2).\r\t\t\r\t\tstudents at: studentClass ifPresent: (students at: studentClass put: studentName) ifAbsent: (students at: studentClass put: studentName).\r\t\t].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/16/2023 11:34',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T11:36:03.192967+11:00' ],		#prior : OmReference [ '486' ],		#self : OmReference [ '487' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\tstudents := SmallDictionary new.\r\t\r\taStudentArray do: [ :studentClassTuple | \r\t\t| studentName studentClass |\r\t\tstudentName := (studentClassTuple at: 1). \r\t\tstudentClass := (studentClassTuple at: 2).\r\t\t\r\t\tstudents at: studentClass ifPresent: (students at: studentClass put: studentName) ifAbsent: (students at: studentClass put: studentName).\r\t\t].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/16/2023 11:34',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\tstudents := SmallDictionary new.\r\t\r\taStudentArray do: [ :studentClassTuple | \r\t\t| studentName studentClass |\r\t\tstudentName := (studentClassTuple at: 1). \r\t\tstudentClass := (studentClassTuple at: 2).\r\t\t\r\t\tstudents at: studentClass ifPresent: (students at: studentClass update: studentName) ifAbsent: (students at: studentClass put: studentName).\r\t\t].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/16/2023 11:36',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T11:37:16.095837+11:00' ],		#prior : OmReference [ '487' ],		#self : OmReference [ '488' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\tstudents := SmallDictionary new.\r\t\r\taStudentArray do: [ :studentClassTuple | \r\t\t| studentName studentClass |\r\t\tstudentName := (studentClassTuple at: 1). \r\t\tstudentClass := (studentClassTuple at: 2).\r\t\t\r\t\tstudents at: studentClass ifPresent: (students at: studentClass update: studentName) ifAbsent: (students at: studentClass put: studentName).\r\t\t].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/16/2023 11:36',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\tstudents := SmallDictionary new.\r\t\r\taStudentArray do: [ :studentClassTuple | \r\t\t| studentName studentClass |\r\t\tstudentName := (studentClassTuple at: 1). \r\t\tstudentClass := (studentClassTuple at: 2).\r\t\t\r\t\tstudents at: studentClass \r\t\tifPresent: (students at: studentClass update: studentName) \r\t\tifAbsent: (students at: studentClass put: studentName).\r\t\t].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/16/2023 11:37',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T11:37:19.413192+11:00' ],		#prior : OmReference [ '488' ],		#self : OmReference [ '489' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\tstudents := SmallDictionary new.\r\t\r\taStudentArray do: [ :studentClassTuple | \r\t\t| studentName studentClass |\r\t\tstudentName := (studentClassTuple at: 1). \r\t\tstudentClass := (studentClassTuple at: 2).\r\t\t\r\t\tstudents at: studentClass \r\t\tifPresent: (students at: studentClass update: studentName) \r\t\tifAbsent: (students at: studentClass put: studentName).\r\t\t].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/16/2023 11:37',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\tstudents := SmallDictionary new.\r\t\r\taStudentArray do: [ :studentClassTuple | \r\t\t| studentName studentClass |\r\t\tstudentName := (studentClassTuple at: 1). \r\t\tstudentClass := (studentClassTuple at: 2).\r\t\t\r\t\tstudents at: studentClass \r\t\tifPresent: (students at: studentClass update: studentName) \r\t\tifAbsent: (students at: studentClass put: studentName)\r\t\t].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/16/2023 11:37',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T11:45:33.264933+11:00' ],		#prior : OmReference [ '489' ],		#self : OmReference [ '490' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\tstudents := SmallDictionary new.\r\t\r\taStudentArray do: [ :studentClassTuple | \r\t\t| studentName studentClass |\r\t\tstudentName := (studentClassTuple at: 1). \r\t\tstudentClass := (studentClassTuple at: 2).\r\t\t\r\t\tstudents at: studentClass \r\t\tifPresent: (students at: studentClass update: studentName) \r\t\tifAbsent: (students at: studentClass put: studentName)\r\t\t].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/16/2023 11:37',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| studentName studentClass |\r\t\t\r\tstudents := SmallDictionary new.\r\t\r\taStudentArray do: [ :studentClassTuple | \r\t\tstudentName := (studentClassTuple at: 1). \r\t\tstudentClass := (studentClassTuple at: 2).\r\t\t\r\t\tstudents at: studentClass \r\t\tifPresent: (students at: studentClass update: studentName) \r\t\tifAbsent: (students at: studentClass put: studentName)\r\t\t].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/16/2023 11:45',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T11:54:18.872598+11:00' ],		#prior : OmReference [ '490' ],		#self : OmReference [ '491' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'desiredGrade:',			#protocol : #'accessing - query',			#sourceCode : 'desiredGrade: aGrade\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t^self.',			#stamp : 'AndyMarks 12/16/2023 11:12',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'desiredGrade:',			#protocol : #'accessing - query',			#sourceCode : 'desiredGrade: aGrade\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t^students at: aGrade.',			#stamp : 'AndyMarks 12/16/2023 11:54',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T11:55:21.175857+11:00' ],		#prior : OmReference [ '491' ],		#self : OmReference [ '492' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'desiredGrade:',			#protocol : #'accessing - query',			#sourceCode : 'desiredGrade: aGrade\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t^students at: aGrade.',			#stamp : 'AndyMarks 12/16/2023 11:54',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'desiredGrade:',			#protocol : #'accessing - query',			#sourceCode : 'desiredGrade: aGrade\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t^students at: aGrade\r\tifAbsent: Array new.',			#stamp : 'AndyMarks 12/16/2023 11:55',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-16T11:56:12.550952+11:00' ],		#prior : OmReference [ '492' ],		#self : OmReference [ '493' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #roster,			#protocol : #'accessing - query',			#sourceCode : 'roster\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t^students values  .\r\t\t\t\r',			#stamp : 'AndyMarks 12/16/2023 11:19',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #roster,			#protocol : #'accessing - query',			#sourceCode : 'roster\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t^students values.\r\t\t\t\r',			#stamp : 'AndyMarks 12/16/2023 11:56',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-17T11:44:27.346077+11:00' ],		#prior : OmReference [ '493' ],		#self : OmReference [ '494' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| studentName studentClass |\r\t\t\r\tstudents := SmallDictionary new.\r\t\r\taStudentArray do: [ :studentClassTuple | \r\t\tstudentName := (studentClassTuple at: 1). \r\t\tstudentClass := (studentClassTuple at: 2).\r\t\t\r\t\tstudents at: studentClass \r\t\tifPresent: (students at: studentClass update: studentName) \r\t\tifAbsent: (students at: studentClass put: studentName)\r\t\t].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/16/2023 11:45',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| studentName studentClass |\r\t\t\r\tstudents := SmallDictionary new.\r\t\r\taStudentArray do: [ :studentClassTuple | \r\t\tstudentName := (studentClassTuple at: 1). \r\t\tstudentClass := (studentClassTuple at: 2).\r\t\t\r\t\tstudents at: studentClass \r\t\tifPresent: (students at: studentClass update: studentName) \r\t\tifAbsentPut: (Array newFrom: studentName)\r\t\t].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/17/2023 11:44',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-17T11:46:44.816336+11:00' ],		#prior : OmReference [ '494' ],		#self : OmReference [ '495' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| studentName studentClass |\r\t\t\r\tstudents := SmallDictionary new.\r\t\r\taStudentArray do: [ :studentClassTuple | \r\t\tstudentName := (studentClassTuple at: 1). \r\t\tstudentClass := (studentClassTuple at: 2).\r\t\t\r\t\tstudents at: studentClass \r\t\tifPresent: (students at: studentClass update: studentName) \r\t\tifAbsentPut: (Array newFrom: studentName)\r\t\t].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/17/2023 11:44',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| studentName studentClass |\r\t\t\r\tstudents := SmallDictionary new.\r\t\r\taStudentArray do: [ :studentClassTuple | \r\t\tstudentName := (studentClassTuple at: 1). \r\t\tstudentClass := (studentClassTuple at: 2).\r\t\t\r\t\tstudents at: studentClass \r\t\tifPresent: [students at: studentClass update: studentName]\r\t\tifAbsentPut: [Array newFrom: studentName]\r\t\t].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/17/2023 11:46',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-17T11:54:53.898337+11:00' ],		#prior : OmReference [ '495' ],		#self : OmReference [ '496' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| studentName studentClass |\r\t\t\r\tstudents := SmallDictionary new.\r\t\r\taStudentArray do: [ :studentClassTuple | \r\t\tstudentName := (studentClassTuple at: 1). \r\t\tstudentClass := (studentClassTuple at: 2).\r\t\t\r\t\tstudents at: studentClass \r\t\tifPresent: [students at: studentClass update: studentName]\r\t\tifAbsentPut: [Array newFrom: studentName]\r\t\t].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/17/2023 11:46',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| studentName studentClass |\r\t\t\r\tstudents := SmallDictionary new.\r\t\r\taStudentArray do: [ :studentClassTuple | \r\t\tstudentName := (studentClassTuple at: 1). \r\t\tstudentClass := (studentClassTuple at: 2).\r\t\t\r\t\tstudents at: studentClass \r\t\tifPresent: [students at: studentClass update: studentName]\r\t\tifAbsentPut: [Array with: studentName]\r\t\t].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/17/2023 11:54',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-17T11:56:17.910078+11:00' ],		#prior : OmReference [ '496' ],		#self : OmReference [ '497' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| studentName studentClass |\r\t\t\r\tstudents := SmallDictionary new.\r\t\r\taStudentArray do: [ :studentClassTuple | \r\t\tstudentName := (studentClassTuple at: 1). \r\t\tstudentClass := (studentClassTuple at: 2).\r\t\t\r\t\tstudents at: studentClass \r\t\tifPresent: [students at: studentClass update: studentName]\r\t\tifAbsentPut: [Array with: studentName]\r\t\t].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/17/2023 11:54',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| studentName studentClass |\r\t\t\r\tstudents := SmallDictionary new.\r\t\r\taStudentArray do: [ :studentClassTuple | \r\t\tstudentName := (studentClassTuple at: 1). \r\t\tstudentClass := (studentClassTuple at: 2).\r\t\t\r\t\tstudents at: studentClass \r\t\tifPresent: [students at: studentClass update: studentName]\r\t\tifAbsentPut: [#(studentName)]\r\t\t].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/17/2023 11:56',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-17T11:57:50.382242+11:00' ],		#prior : OmReference [ '497' ],		#self : OmReference [ '498' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| studentName studentClass |\r\t\t\r\tstudents := SmallDictionary new.\r\t\r\taStudentArray do: [ :studentClassTuple | \r\t\tstudentName := (studentClassTuple at: 1). \r\t\tstudentClass := (studentClassTuple at: 2).\r\t\t\r\t\tstudents at: studentClass \r\t\tifPresent: [students at: studentClass update: studentName]\r\t\tifAbsentPut: [#(studentName)]\r\t\t].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/17/2023 11:56',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| studentName studentClass |\r\t\t\r\tstudents := SmallDictionary new.\r\t\r\taStudentArray do: [ :studentClassTuple | \r\t\tstudentName := (studentClassTuple at: 1). \r\t\tstudentClass := (studentClassTuple at: 2).\r\t\t\r\t\tstudents at: studentClass \r\t\tifPresent: [students at: studentClass put: ({students at: studentClass . studentName})]\r\t\tifAbsentPut: [#(studentName)]\r\t\t].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/17/2023 11:57',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-17T11:58:31.534455+11:00' ],		#prior : OmReference [ '498' ],		#self : OmReference [ '499' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| studentName studentClass |\r\t\t\r\tstudents := SmallDictionary new.\r\t\r\taStudentArray do: [ :studentClassTuple | \r\t\tstudentName := (studentClassTuple at: 1). \r\t\tstudentClass := (studentClassTuple at: 2).\r\t\t\r\t\tstudents at: studentClass \r\t\tifPresent: [students at: studentClass put: ({students at: studentClass . studentName})]\r\t\tifAbsentPut: [#(studentName)]\r\t\t].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/17/2023 11:57',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| studentName studentClass |\r\t\t\r\tstudents := SmallDictionary new.\r\t\r\taStudentArray do: [ :studentClassTuple | \r\t\tstudentName := (studentClassTuple at: 1). \r\t\tstudentClass := (studentClassTuple at: 2).\r\t\t\r\t\tstudents at: studentClass \r\t\tifPresent: [students at: studentClass put: ({students at: studentClass . studentName})]\r\t\tifAbsentPut: [Array with: studentName]\r\t\t].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/17/2023 11:58',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-17T12:02:10.511329+11:00' ],		#prior : OmReference [ '499' ],		#self : OmReference [ '500' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| studentName studentClass |\r\t\t\r\tstudents := SmallDictionary new.\r\t\r\taStudentArray do: [ :studentClassTuple | \r\t\tstudentName := (studentClassTuple at: 1). \r\t\tstudentClass := (studentClassTuple at: 2).\r\t\t\r\t\tstudents at: studentClass \r\t\tifPresent: [students at: studentClass put: ({students at: studentClass . studentName})]\r\t\tifAbsentPut: [Array with: studentName]\r\t\t].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/17/2023 11:58',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| studentName studentClass |\r\t\t\r\tstudents := SmallDictionary new.\r\t\r\taStudentArray do: [ :studentClassTuple | \r\t\tstudentName := (studentClassTuple at: 1). \r\t\tstudentClass := (studentClassTuple at: 2).\r\t\t\r\t\tstudents at: studentClass \r\t\tifPresent: [\r\t\t\t| existingStudents |\r\t\t\texistingStudents := students at: studentClass.\r\t\t\tstudents at: studentClass put: ({students at: studentClass . studentName})\r\t\t\t]\r\t\tifAbsentPut: [OrderedCollection with: studentName]\r\t\t].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/17/2023 12:02',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-17T12:04:17.913143+11:00' ],		#prior : OmReference [ '500' ],		#self : OmReference [ '501' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| studentName studentClass |\r\t\t\r\tstudents := SmallDictionary new.\r\t\r\taStudentArray do: [ :studentClassTuple | \r\t\tstudentName := (studentClassTuple at: 1). \r\t\tstudentClass := (studentClassTuple at: 2).\r\t\t\r\t\tstudents at: studentClass \r\t\tifPresent: [\r\t\t\t| existingStudents |\r\t\t\texistingStudents := students at: studentClass.\r\t\t\tstudents at: studentClass put: ({students at: studentClass . studentName})\r\t\t\t]\r\t\tifAbsentPut: [OrderedCollection with: studentName]\r\t\t].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/17/2023 12:02',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| studentName studentClass |\r\t\t\r\tstudents := SmallDictionary new.\r\t\r\taStudentArray do: [ :studentClassTuple | \r\t\tstudentName := (studentClassTuple at: 1). \r\t\tstudentClass := (studentClassTuple at: 2).\r\t\t\r\t\tstudents at: studentClass \r\t\tifPresent: [\r\t\t\t| existingStudents |\r\t\t\texistingStudents := students at: studentClass.\r\t\t\texistingStudents add: studentName .\r\t\t\tstudents at: studentClass put: existingStudents\r\t\t\t]\r\t\tifAbsentPut: [OrderedCollection with: studentName]\r\t\t].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/17/2023 12:04',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-17T12:08:04.846218+11:00' ],		#prior : OmReference [ '501' ],		#self : OmReference [ '502' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #roster,			#protocol : #'accessing - query',			#sourceCode : 'roster\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t^students values.\r\t\t\t\r',			#stamp : 'AndyMarks 12/17/2023 12:05',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #roster,			#protocol : #'accessing - query',			#sourceCode : 'roster\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| allStudents |\r\t\r\tallStudents := OrderedCollection new.\r\t\r\tstudents valuesDo: [ :studentsForClass |\r\t\tallStudents addAll: studentsForClass\r\t\t ].\r\t\r\t^allStudents.\r\t\t\t\r',			#stamp : 'AndyMarks 12/17/2023 12:08',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-17T12:08:12.024565+11:00' ],		#prior : OmReference [ '502' ],		#self : OmReference [ '503' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #roster,			#protocol : #'accessing - query',			#sourceCode : 'roster\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| allStudents |\r\t\r\tallStudents := OrderedCollection new.\r\t\r\tstudents valuesDo: [ :studentsForClass |\r\t\tallStudents addAll: studentsForClass\r\t\t ].\r\t\r\t^allStudents.\r\t\t\t\r',			#stamp : 'AndyMarks 12/17/2023 12:08',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #roster,			#protocol : #'accessing - query',			#sourceCode : 'roster\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| allStudents |\r\t\r\tallStudents := OrderedCollection new.\r\t\r\tstudents valuesDo: [ :studentsForClass |\r\t\tallStudents addAll: studentsForClass\r\t\t ].\r\t\r\t^allStudents asArray.\r\t\t\t\r',			#stamp : 'AndyMarks 12/17/2023 12:08',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-17T12:11:15.045529+11:00' ],		#prior : OmReference [ '503' ],		#self : OmReference [ '504' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #roster,			#protocol : #'accessing - query',			#sourceCode : 'roster\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| allStudents |\r\t\r\tallStudents := OrderedCollection new.\r\t\r\tstudents valuesDo: [ :studentsForClass |\r\t\tallStudents addAll: studentsForClass\r\t\t ].\r\t\r\t^allStudents asArray.\r\t\t\t\r',			#stamp : 'AndyMarks 12/17/2023 12:08',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #roster,			#protocol : #'accessing - query',			#sourceCode : 'roster\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| allStudents |\r\t\r\tallStudents := OrderedCollection new.\r\t\r\tstudents valuesDo: [ :studentsForClass |\r\t\tallStudents addAll: studentsForClass sort: [ :first :second | first > second ]\r\t\t ].\r\t\r\t^allStudents asArray.\r\t\t\t\r',			#stamp : 'AndyMarks 12/17/2023 12:11',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-17T12:11:24.833619+11:00' ],		#prior : OmReference [ '504' ],		#self : OmReference [ '505' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #roster,			#protocol : #'accessing - query',			#sourceCode : 'roster\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| allStudents |\r\t\r\tallStudents := OrderedCollection new.\r\t\r\tstudents valuesDo: [ :studentsForClass |\r\t\tallStudents addAll: studentsForClass sort: [ :first :second | first > second ]\r\t\t ].\r\t\r\t^allStudents asArray.\r\t\t\t\r',			#stamp : 'AndyMarks 12/17/2023 12:11',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #roster,			#protocol : #'accessing - query',			#sourceCode : 'roster\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| allStudents |\r\t\r\tallStudents := OrderedCollection new.\r\t\r\tstudents valuesDo: [ :studentsForClass |\r\t\tallStudents addAll: (studentsForClass sort: [ :first :second | first > second ])\r\t\t ].\r\t\r\t^allStudents asArray.\r\t\t\t\r',			#stamp : 'AndyMarks 12/17/2023 12:11',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-17T12:12:01.564387+11:00' ],		#prior : OmReference [ '505' ],		#self : OmReference [ '506' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #roster,			#protocol : #'accessing - query',			#sourceCode : 'roster\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| allStudents |\r\t\r\tallStudents := OrderedCollection new.\r\t\r\tstudents valuesDo: [ :studentsForClass |\r\t\tallStudents addAll: (studentsForClass sort: [ :first :second | first > second ])\r\t\t ].\r\t\r\t^allStudents asArray.\r\t\t\t\r',			#stamp : 'AndyMarks 12/17/2023 12:11',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #roster,			#protocol : #'accessing - query',			#sourceCode : 'roster\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| allStudents |\r\t\r\tallStudents := OrderedCollection new.\r\t\r\tstudents valuesDo: [ :studentsForClass |\r\t\t| sortedStudents |\r\t\tsortedStudents := studentsForClass sort: [ :first :second | first > second ]\r\t\tallStudents addAll: sortedStudents\r\t\t ].\r\t\r\t^allStudents asArray.\r\t\t\t\r',			#stamp : 'AndyMarks 12/17/2023 12:12',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-17T12:12:05.36199+11:00' ],		#prior : OmReference [ '506' ],		#self : OmReference [ '507' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #roster,			#protocol : #'accessing - query',			#sourceCode : 'roster\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| allStudents |\r\t\r\tallStudents := OrderedCollection new.\r\t\r\tstudents valuesDo: [ :studentsForClass |\r\t\t| sortedStudents |\r\t\tsortedStudents := studentsForClass sort: [ :first :second | first > second ]\r\t\tallStudents addAll: sortedStudents\r\t\t ].\r\t\r\t^allStudents asArray.\r\t\t\t\r',			#stamp : 'AndyMarks 12/17/2023 12:12',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #roster,			#protocol : #'accessing - query',			#sourceCode : 'roster\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| allStudents |\r\t\r\tallStudents := OrderedCollection new.\r\t\r\tstudents valuesDo: [ :studentsForClass |\r\t\t| sortedStudents |\r\t\tsortedStudents := studentsForClass sort: [ :first :second | first > second ].\r\t\tallStudents addAll: sortedStudents\r\t\t ].\r\t\r\t^allStudents asArray.\r\t\t\t\r',			#stamp : 'AndyMarks 12/17/2023 12:12',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-17T12:12:15.609796+11:00' ],		#prior : OmReference [ '507' ],		#self : OmReference [ '508' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #roster,			#protocol : #'accessing - query',			#sourceCode : 'roster\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| allStudents |\r\t\r\tallStudents := OrderedCollection new.\r\t\r\tstudents valuesDo: [ :studentsForClass |\r\t\t| sortedStudents |\r\t\tsortedStudents := studentsForClass sort: [ :first :second | first > second ].\r\t\tallStudents addAll: sortedStudents\r\t\t ].\r\t\r\t^allStudents asArray.\r\t\t\t\r',			#stamp : 'AndyMarks 12/17/2023 12:12',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #roster,			#protocol : #'accessing - query',			#sourceCode : 'roster\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| allStudents |\r\t\r\tallStudents := OrderedCollection new.\r\t\r\tstudents valuesDo: [ :studentsForClass |\r\t\t| sortedStudents |\r\t\tsortedStudents := studentsForClass sort: [ :first :second | first > second ].\r\t\tallStudents addAll: sortedStudents\r\t\t].\r\t\r\t^allStudents asArray.\r\t\t\t\r',			#stamp : 'AndyMarks 12/17/2023 12:12',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-17T12:12:54.612457+11:00' ],		#prior : OmReference [ '508' ],		#self : OmReference [ '509' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #roster,			#protocol : #'accessing - query',			#sourceCode : 'roster\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| allStudents |\r\t\r\tallStudents := OrderedCollection new.\r\t\r\tstudents valuesDo: [ :studentsForClass |\r\t\t| sortedStudents |\r\t\tsortedStudents := studentsForClass sort: [ :first :second | first > second ].\r\t\tallStudents addAll: sortedStudents\r\t\t].\r\t\r\t^allStudents asArray.\r\t\t\t\r',			#stamp : 'AndyMarks 12/17/2023 12:12',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #roster,			#protocol : #'accessing - query',			#sourceCode : 'roster\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| allStudents |\r\t\r\tallStudents := OrderedCollection new.\r\t\r\tstudents valuesDo: [ :studentsForClass |\r\t\t| sortedStudents |\r\t\tsortedStudents := studentsForClass sort: [ :first :second | first < second ].\r\t\tallStudents addAll: sortedStudents\r\t\t].\r\t\r\t^allStudents asArray.\r\t\t\t\r',			#stamp : 'AndyMarks 12/17/2023 12:12',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-17T12:16:21.503746+11:00' ],		#prior : OmReference [ '509' ],		#self : OmReference [ '510' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #roster,			#protocol : #'accessing - query',			#sourceCode : 'roster\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| allStudents |\r\t\r\tallStudents := OrderedCollection new.\r\t\r\tstudents valuesDo: [ :studentsForClass |\r\t\t| sortedStudents |\r\t\tsortedStudents := studentsForClass sort: [ :first :second | first < second ].\r\t\tallStudents addAll: sortedStudents\r\t\t].\r\t\r\t^allStudents asArray.\r\t\t\t\r',			#stamp : 'AndyMarks 12/17/2023 12:12',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #roster,			#protocol : #'accessing - query',			#sourceCode : 'roster\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| allStudents |\r\t\r\tallStudents := OrderedCollection new.\r\t\r\tstudents keysDo: [ :classNumber |\r\t\t| sortedStudents |\r\t\tsortedStudents := (students at: classNumber) sort: [ :first :second | first < second ].\r\t\tallStudents addAll: sortedStudents\r\t\t].\r\t\r\t^allStudents asArray.\r\t\t\t\r',			#stamp : 'AndyMarks 12/17/2023 12:16',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-17T12:17:35.03321+11:00' ],		#prior : OmReference [ '510' ],		#self : OmReference [ '511' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| studentName studentClass |\r\t\t\r\tstudents := SmallDictionary new.\r\t\r\taStudentArray do: [ :studentClassTuple | \r\t\tstudentName := (studentClassTuple at: 1). \r\t\tstudentClass := (studentClassTuple at: 2).\r\t\t\r\t\tstudents at: studentClass \r\t\tifPresent: [\r\t\t\t| existingStudents |\r\t\t\texistingStudents := students at: studentClass.\r\t\t\texistingStudents add: studentName .\r\t\t\tstudents at: studentClass put: existingStudents\r\t\t\t]\r\t\tifAbsentPut: [OrderedCollection with: studentName]\r\t\t].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/17/2023 12:04',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| studentName studentClass |\r\t\t\r\tstudents := OrderedDictionary new.\r\t\r\taStudentArray do: [ :studentClassTuple | \r\t\tstudentName := (studentClassTuple at: 1). \r\t\tstudentClass := (studentClassTuple at: 2).\r\t\t\r\t\tstudents at: studentClass \r\t\tifPresent: [\r\t\t\t| existingStudents |\r\t\t\texistingStudents := students at: studentClass.\r\t\t\texistingStudents add: studentName .\r\t\t\tstudents at: studentClass put: existingStudents\r\t\t\t]\r\t\tifAbsentPut: [OrderedCollection with: studentName]\r\t\t].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/17/2023 12:17',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-17T12:19:27.380584+11:00' ],		#prior : OmReference [ '511' ],		#self : OmReference [ '512' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #roster,			#protocol : #'accessing - query',			#sourceCode : 'roster\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| allStudents |\r\t\r\tallStudents := OrderedCollection new.\r\t\r\tstudents keysDo: [ :classNumber |\r\t\t| sortedStudents |\r\t\tsortedStudents := (students at: classNumber) sort: [ :first :second | first < second ].\r\t\tallStudents addAll: sortedStudents\r\t\t].\r\t\r\t^allStudents asArray.\r\t\t\t\r',			#stamp : 'AndyMarks 12/17/2023 12:16',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #roster,			#protocol : #'accessing - query',			#sourceCode : 'roster\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| allStudents allClasses |\r\t\r\tallStudents := OrderedCollection new.\r\tallClasses := students keysSortedSafely .\r\t\r\tallClasses keysDo: [ :classNumber |\r\t\t| sortedStudents |\r\t\tsortedStudents := (students at: classNumber) sort: [ :first :second | first < second ].\r\t\tallStudents addAll: sortedStudents\r\t\t].\r\t\r\t^allStudents asArray.\r\t\t\t\r',			#stamp : 'AndyMarks 12/17/2023 12:19',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-17T12:19:44.213413+11:00' ],		#prior : OmReference [ '512' ],		#self : OmReference [ '513' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #roster,			#protocol : #'accessing - query',			#sourceCode : 'roster\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| allStudents allClasses |\r\t\r\tallStudents := OrderedCollection new.\r\tallClasses := students keysSortedSafely .\r\t\r\tallClasses keysDo: [ :classNumber |\r\t\t| sortedStudents |\r\t\tsortedStudents := (students at: classNumber) sort: [ :first :second | first < second ].\r\t\tallStudents addAll: sortedStudents\r\t\t].\r\t\r\t^allStudents asArray.\r\t\t\t\r',			#stamp : 'AndyMarks 12/17/2023 12:19',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #roster,			#protocol : #'accessing - query',			#sourceCode : 'roster\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| allStudents allClasses |\r\t\r\tallStudents := OrderedCollection new.\r\tallClasses := students keysSortedSafely .\r\t\r\tallClasses do: [ :classNumber |\r\t\t| sortedStudents |\r\t\tsortedStudents := (students at: classNumber) sort: [ :first :second | first < second ].\r\t\tallStudents addAll: sortedStudents\r\t\t].\r\t\r\t^allStudents asArray.\r\t\t\t\r',			#stamp : 'AndyMarks 12/17/2023 12:19',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-17T12:21:31.486323+11:00' ],		#prior : OmReference [ '513' ],		#self : OmReference [ '514' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'desiredGrade:',			#protocol : #'accessing - query',			#sourceCode : 'desiredGrade: aGrade\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t^students at: aGrade\r\tifAbsent: Array new.',			#stamp : 'AndyMarks 12/16/2023 11:55',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'desiredGrade:',			#protocol : #'accessing - query',			#sourceCode : 'desiredGrade: aGrade\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\tstudents at: aGrade\r\tifPresent: [^(students at: aGrade) sort: [ :first :second | first < second ]]\r\r\tifAbsent: Array new.',			#stamp : 'AndyMarks 12/17/2023 12:21',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-17T12:21:35.337653+11:00' ],		#prior : OmReference [ '514' ],		#self : OmReference [ '515' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'desiredGrade:',			#protocol : #'accessing - query',			#sourceCode : 'desiredGrade: aGrade\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\tstudents at: aGrade\r\tifPresent: [^(students at: aGrade) sort: [ :first :second | first < second ]]\r\r\tifAbsent: Array new.',			#stamp : 'AndyMarks 12/17/2023 12:21',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'desiredGrade:',			#protocol : #'accessing - query',			#sourceCode : 'desiredGrade: aGrade\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\tstudents at: aGrade\r\tifPresent: [^(students at: aGrade) sort: [ :first :second | first < second ]]\r\tifAbsent: Array new.',			#stamp : 'AndyMarks 12/17/2023 12:21',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-17T12:21:40.720772+11:00' ],		#prior : OmReference [ '515' ],		#self : OmReference [ '516' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'desiredGrade:',			#protocol : #'accessing - query',			#sourceCode : 'desiredGrade: aGrade\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\tstudents at: aGrade\r\tifPresent: [^(students at: aGrade) sort: [ :first :second | first < second ]]\r\tifAbsent: Array new.',			#stamp : 'AndyMarks 12/17/2023 12:21',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'desiredGrade:',			#protocol : #'accessing - query',			#sourceCode : 'desiredGrade: aGrade\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\tstudents at: aGrade\r\t\tifPresent: [^(students at: aGrade) sort: [ :first :second | first < second ]]\r\t\tifAbsent: Array new.',			#stamp : 'AndyMarks 12/17/2023 12:21',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-17T12:22:22.565873+11:00' ],		#prior : OmReference [ '516' ],		#self : OmReference [ '517' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'desiredGrade:',			#protocol : #'accessing - query',			#sourceCode : 'desiredGrade: aGrade\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\tstudents at: aGrade\r\t\tifPresent: [^(students at: aGrade) sort: [ :first :second | first < second ]]\r\t\tifAbsent: Array new.',			#stamp : 'AndyMarks 12/17/2023 12:21',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'desiredGrade:',			#protocol : #'accessing - query',			#sourceCode : 'desiredGrade: aGrade\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t^students at: aGrade\r\t\tifPresent: [(students at: aGrade) sort: [ :first :second | first < second ]]\r\t\tifAbsent: Array new.',			#stamp : 'AndyMarks 12/17/2023 12:22',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-17T12:23:31.726588+11:00' ],		#prior : OmReference [ '517' ],		#self : OmReference [ '518' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'desiredGrade:',			#protocol : #'accessing - query',			#sourceCode : 'desiredGrade: aGrade\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t^students at: aGrade\r\t\tifPresent: [(students at: aGrade) sort: [ :first :second | first < second ]]\r\t\tifAbsent: Array new.',			#stamp : 'AndyMarks 12/17/2023 12:22',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'desiredGrade:',			#protocol : #'accessing - query',			#sourceCode : 'desiredGrade: aGrade\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t^students at: aGrade\r\t\tifPresent: [(students at: aGrade) sort: [ :first :second | first < second ]]\r\t\tifAbsent: #().',			#stamp : 'AndyMarks 12/17/2023 12:23',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-17T12:23:44.040996+11:00' ],		#prior : OmReference [ '518' ],		#self : OmReference [ '519' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'desiredGrade:',			#protocol : #'accessing - query',			#sourceCode : 'desiredGrade: aGrade\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t^students at: aGrade\r\t\tifPresent: [(students at: aGrade) sort: [ :first :second | first < second ]]\r\t\tifAbsent: #().',			#stamp : 'AndyMarks 12/17/2023 12:23',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'desiredGrade:',			#protocol : #'accessing - query',			#sourceCode : 'desiredGrade: aGrade\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t^students at: aGrade\r\t\tifPresent: [(students at: aGrade) sort: [ :first :second | first < second ]] asArray\r\t\tifAbsent: #().',			#stamp : 'AndyMarks 12/17/2023 12:23',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-17T12:23:47.90511+11:00' ],		#prior : OmReference [ '519' ],		#self : OmReference [ '520' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'desiredGrade:',			#protocol : #'accessing - query',			#sourceCode : 'desiredGrade: aGrade\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t^students at: aGrade\r\t\tifPresent: [(students at: aGrade) sort: [ :first :second | first < second ]] asArray\r\t\tifAbsent: #().',			#stamp : 'AndyMarks 12/17/2023 12:23',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'desiredGrade:',			#protocol : #'accessing - query',			#sourceCode : 'desiredGrade: aGrade\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t^students at: aGrade\r\t\tifPresent: [(students at: aGrade) sort: [ :first :second | first < second ] asArray]\r\t\tifAbsent: #().',			#stamp : 'AndyMarks 12/17/2023 12:23',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-17T12:24:50.799081+11:00' ],		#prior : OmReference [ '520' ],		#self : OmReference [ '521' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'desiredGrade:',			#protocol : #'accessing - query',			#sourceCode : 'desiredGrade: aGrade\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t^students at: aGrade\r\t\tifPresent: [(students at: aGrade) sort: [ :first :second | first < second ] asArray]\r\t\tifAbsent: #().',			#stamp : 'AndyMarks 12/17/2023 12:23',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'desiredGrade:',			#protocol : #'accessing - query',			#sourceCode : 'desiredGrade: aGrade\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t^students at: aGrade\r\t\tifPresent: [\r\t\t\t| sortedStudents |\r\t\t\tsortedStudents := (students at: aGrade)\r\t\t\tsortedStudents\tsort: [ :first :second | first < second ] \r\t\t\tsortedStudents asArray\r\t\t\t]\r\t\tifAbsent: #().',			#stamp : 'AndyMarks 12/17/2023 12:24',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-17T12:24:54.692941+11:00' ],		#prior : OmReference [ '521' ],		#self : OmReference [ '522' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'desiredGrade:',			#protocol : #'accessing - query',			#sourceCode : 'desiredGrade: aGrade\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t^students at: aGrade\r\t\tifPresent: [\r\t\t\t| sortedStudents |\r\t\t\tsortedStudents := (students at: aGrade)\r\t\t\tsortedStudents\tsort: [ :first :second | first < second ] \r\t\t\tsortedStudents asArray\r\t\t\t]\r\t\tifAbsent: #().',			#stamp : 'AndyMarks 12/17/2023 12:24',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'desiredGrade:',			#protocol : #'accessing - query',			#sourceCode : 'desiredGrade: aGrade\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t^students at: aGrade\r\t\tifPresent: [\r\t\t\t| sortedStudents |\r\t\t\tsortedStudents := (students at: aGrade).\r\t\t\tsortedStudents\tsort: [ :first :second | first < second ] .\r\t\t\tsortedStudents asArray\r\t\t\t]\r\t\tifAbsent: #().',			#stamp : 'AndyMarks 12/17/2023 12:24',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-17T12:26:08.31469+11:00' ],		#prior : OmReference [ '522' ],		#self : OmReference [ '523' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| studentName studentClass |\r\t\t\r\tstudents := OrderedDictionary new.\r\t\r\taStudentArray do: [ :studentClassTuple | \r\t\tstudentName := (studentClassTuple at: 1). \r\t\tstudentClass := (studentClassTuple at: 2).\r\t\t\r\t\tstudents at: studentClass \r\t\tifPresent: [\r\t\t\t| existingStudents |\r\t\t\texistingStudents := students at: studentClass.\r\t\t\texistingStudents add: studentName .\r\t\t\tstudents at: studentClass put: existingStudents\r\t\t\t]\r\t\tifAbsentPut: [OrderedCollection with: studentName]\r\t\t].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/17/2023 12:17',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| studentName studentClass |\r\t\t\r\tstudents := OrderedDictionary new.\r\t\r\taStudentArray do: [ :studentClassTuple | \r\t\tstudentName := (studentClassTuple at: 1). \r\t\tstudentClass := (studentClassTuple at: 2).\r\t\t\r\t\tstudents at: studentClass \r\t\tifPresent: [\r\t\t\t| existingStudents |\r\t\t\texistingStudents := students at: studentClass.\r\t\t\texistingStudents add: studentName .\r\t\t\tstudents at: studentClass put: existingStudents\r\t\t\t]\r\t\tifAbsentPut: [SortedCollection with: studentName]\r\t\t].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/17/2023 12:26',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-17T12:26:59.774398+11:00' ],		#prior : OmReference [ '523' ],		#self : OmReference [ '524' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'desiredGrade:',			#protocol : #'accessing - query',			#sourceCode : 'desiredGrade: aGrade\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t^students at: aGrade\r\t\tifPresent: [\r\t\t\t| sortedStudents |\r\t\t\tsortedStudents := (students at: aGrade).\r\t\t\tsortedStudents\tsort: [ :first :second | first < second ] .\r\t\t\tsortedStudents asArray\r\t\t\t]\r\t\tifAbsent: #().',			#stamp : 'AndyMarks 12/17/2023 12:24',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'desiredGrade:',			#protocol : #'accessing - query',			#sourceCode : 'desiredGrade: aGrade\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t^students at: aGrade\r\t\tifPresent: [\r\t\t\t(students at: aGrade) asArray.\r\t\t\t]\r\t\tifAbsent: #().',			#stamp : 'AndyMarks 12/17/2023 12:26',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-17T12:27:17.538266+11:00' ],		#prior : OmReference [ '524' ],		#self : OmReference [ '525' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'desiredGrade:',			#protocol : #'accessing - query',			#sourceCode : 'desiredGrade: aGrade\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t^students at: aGrade\r\t\tifPresent: [\r\t\t\t(students at: aGrade) asArray.\r\t\t\t]\r\t\tifAbsent: #().',			#stamp : 'AndyMarks 12/17/2023 12:26',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'desiredGrade:',			#protocol : #'accessing - query',			#sourceCode : 'desiredGrade: aGrade\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t^students at: aGrade\r\t\tifPresent: [\t(students at: aGrade) asArray]\r\t\tifAbsent: #().',			#stamp : 'AndyMarks 12/17/2023 12:27',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-17T12:27:44.682085+11:00' ],		#prior : OmReference [ '525' ],		#self : OmReference [ '526' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #roster,			#protocol : #'accessing - query',			#sourceCode : 'roster\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| allStudents allClasses |\r\t\r\tallStudents := OrderedCollection new.\r\tallClasses := students keysSortedSafely .\r\t\r\tallClasses do: [ :classNumber |\r\t\t| sortedStudents |\r\t\tsortedStudents := (students at: classNumber) sort: [ :first :second | first < second ].\r\t\tallStudents addAll: sortedStudents\r\t\t].\r\t\r\t^allStudents asArray.\r\t\t\t\r',			#stamp : 'AndyMarks 12/17/2023 12:19',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #roster,			#protocol : #'accessing - query',			#sourceCode : 'roster\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| allStudents allClasses |\r\t\r\tallStudents := OrderedCollection new.\r\tallClasses := students keysSortedSafely .\r\t\r\tallClasses do: [ :classNumber |\r\t\tallStudents addAll: (students at: classNumber)\r\t\t].\r\t\r\t^allStudents asArray.\r\t\t\t\r',			#stamp : 'AndyMarks 12/17/2023 12:27',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-17T12:30:10.143898+11:00' ],		#prior : OmReference [ '526' ],		#self : OmReference [ '527' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #roster,			#protocol : #'accessing - query',			#sourceCode : 'roster\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| allStudents allClasses |\r\t\r\tallStudents := OrderedCollection new.\r\tallClasses := students keysSortedSafely .\r\t\r\tallClasses do: [ :classNumber |\r\t\tallStudents addAll: (students at: classNumber)\r\t\t].\r\t\r\t^allStudents asArray.\r\t\t\t\r',			#stamp : 'AndyMarks 12/17/2023 12:27',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #roster,			#protocol : #'accessing - query',			#sourceCode : 'roster\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| allStudents allClasses |\r\t\r\tallStudents := OrderedCollection new.\r\t\r\tstudents keysSortedSafely do: [ :classNumber |\r\t\tallStudents addAll: (students at: classNumber)\r\t\t].\r\t\r\t^allStudents asArray.\r\t\t\t\r',			#stamp : 'AndyMarks 12/17/2023 12:30',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-17T12:30:18.731461+11:00' ],		#prior : OmReference [ '527' ],		#self : OmReference [ '528' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #roster,			#protocol : #'accessing - query',			#sourceCode : 'roster\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| allStudents allClasses |\r\t\r\tallStudents := OrderedCollection new.\r\t\r\tstudents keysSortedSafely do: [ :classNumber |\r\t\tallStudents addAll: (students at: classNumber)\r\t\t].\r\t\r\t^allStudents asArray.\r\t\t\t\r',			#stamp : 'AndyMarks 12/17/2023 12:30',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #roster,			#protocol : #'accessing - query',			#sourceCode : 'roster\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\r\t| allStudents |\r\t\r\tallStudents := OrderedCollection new.\r\t\r\tstudents keysSortedSafely do: [ :classNumber |\r\t\tallStudents addAll: (students at: classNumber)\r\t\t].\r\t\r\t^allStudents asArray.\r\t\t\t\r',			#stamp : 'AndyMarks 12/17/2023 12:30',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-17T12:37:36.126536+11:00' ],		#prior : OmReference [ '528' ],		#self : OmReference [ '529' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'desiredGrade:',			#protocol : #'accessing - query',			#sourceCode : 'desiredGrade: aGrade\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t^students at: aGrade\r\t\tifPresent: [\t(students at: aGrade) asArray]\r\t\tifAbsent: #().',			#stamp : 'AndyMarks 12/17/2023 12:27',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'desiredGrade:',			#protocol : #'accessing - query',			#sourceCode : 'desiredGrade: aGrade\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t^(students at: aGrade) asArray.\r',			#stamp : 'AndyMarks 12/17/2023 12:37',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-17T12:38:03.531546+11:00' ],		#prior : OmReference [ '529' ],		#self : OmReference [ '530' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'desiredGrade:',			#protocol : #'accessing - query',			#sourceCode : 'desiredGrade: aGrade\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t^(students at: aGrade) asArray.\r',			#stamp : 'AndyMarks 12/17/2023 12:37',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'desiredGrade:',			#protocol : #'accessing - query',			#sourceCode : 'desiredGrade: aGrade\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t^(students at: aGrade) asArray\r\t\tifAbsent: #().',			#stamp : 'AndyMarks 12/17/2023 12:38',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-17T12:38:32.427605+11:00' ],		#prior : OmReference [ '530' ],		#self : OmReference [ '531' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'desiredGrade:',			#protocol : #'accessing - query',			#sourceCode : 'desiredGrade: aGrade\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t^(students at: aGrade) asArray\r\t\tifAbsent: #().',			#stamp : 'AndyMarks 12/17/2023 12:38',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'desiredGrade:',			#protocol : #'accessing - query',			#sourceCode : 'desiredGrade: aGrade\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t^students at: aGrade\r\t\tifPresent: [\t(students at: aGrade) asArray]\r\t\tifAbsent: #().',			#stamp : 'AndyMarks 12/17/2023 12:38',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-17T12:39:49.378348+11:00' ],		#prior : OmReference [ '531' ],		#self : OmReference [ '532' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'desiredGrade:',			#protocol : #'accessing - query',			#sourceCode : 'desiredGrade: aGrade\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t^students at: aGrade\r\t\tifPresent: [\t(students at: aGrade) asArray]\r\t\tifAbsent: #().',			#stamp : 'AndyMarks 12/17/2023 12:38',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'desiredGrade:',			#protocol : #'accessing - query',			#sourceCode : 'desiredGrade: aGrade\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t^(students at: aGrade\r\t\tifAbsent: #()) asArray.',			#stamp : 'AndyMarks 12/17/2023 12:39',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-17T12:45:20.344537+11:00' ],		#prior : OmReference [ '532' ],		#self : OmReference [ '533' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| studentName studentClass |\r\t\t\r\tstudents := OrderedDictionary new.\r\t\r\taStudentArray do: [ :studentClassTuple | \r\t\tstudentName := (studentClassTuple at: 1). \r\t\tstudentClass := (studentClassTuple at: 2).\r\t\t\r\t\tstudents at: studentClass \r\t\tifPresent: [\r\t\t\t| existingStudents |\r\t\t\texistingStudents := students at: studentClass.\r\t\t\texistingStudents add: studentName .\r\t\t\tstudents at: studentClass put: existingStudents\r\t\t\t]\r\t\tifAbsentPut: [SortedCollection with: studentName]\r\t\t].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/17/2023 12:26',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| studentName studentClass |\r\t\t\r\tstudents := OrderedDictionary new.\r\t\r\taStudentArray do: [ :studentClassTuple | \r\t\tstudentName := (studentClassTuple at: 1). \r\t\tstudentClass := (studentClassTuple at: 2).\r\t\t\r\t\tstudents at: studentClass \r\t\tupdate: [ :existingStudents |\r\t\t\texistingStudents add: studentName .\r\t\t\tstudents at: studentClass put: existingStudents\r\t\t\t]\r\t\tinitBlockOrValue: [SortedCollection with: studentName]\r\t\t].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/17/2023 12:45',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-17T12:45:36.384563+11:00' ],		#prior : OmReference [ '533' ],		#self : OmReference [ '534' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| studentName studentClass |\r\t\t\r\tstudents := OrderedDictionary new.\r\t\r\taStudentArray do: [ :studentClassTuple | \r\t\tstudentName := (studentClassTuple at: 1). \r\t\tstudentClass := (studentClassTuple at: 2).\r\t\t\r\t\tstudents at: studentClass \r\t\tupdate: [ :existingStudents |\r\t\t\texistingStudents add: studentName .\r\t\t\tstudents at: studentClass put: existingStudents\r\t\t\t]\r\t\tinitBlockOrValue: [SortedCollection with: studentName]\r\t\t].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/17/2023 12:45',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| studentName studentClass |\r\t\t\r\tstudents := OrderedDictionary new.\r\t\r\taStudentArray do: [ :studentClassTuple | \r\t\tstudentName := (studentClassTuple at: 1). \r\t\tstudentClass := (studentClassTuple at: 2).\r\t\t\r\t\tstudents at: studentClass \r\t\tupdate: [ :existingStudents |\r\t\t\texistingStudents add: studentName .\r\t\t\tstudents at: studentClass put: existingStudents\r\t\t\t]\r\t\tinitial: [SortedCollection with: studentName]\r\t\t].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/17/2023 12:45',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-17T12:45:52.517949+11:00' ],		#prior : OmReference [ '534' ],		#self : OmReference [ '535' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| studentName studentClass |\r\t\t\r\tstudents := OrderedDictionary new.\r\t\r\taStudentArray do: [ :studentClassTuple | \r\t\tstudentName := (studentClassTuple at: 1). \r\t\tstudentClass := (studentClassTuple at: 2).\r\t\t\r\t\tstudents at: studentClass \r\t\tupdate: [ :existingStudents |\r\t\t\texistingStudents add: studentName .\r\t\t\tstudents at: studentClass put: existingStudents\r\t\t\t]\r\t\tinitial: [SortedCollection with: studentName]\r\t\t].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/17/2023 12:45',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| studentName studentClass |\r\t\t\r\tstudents := OrderedDictionary new.\r\t\r\taStudentArray do: [ :studentClassTuple | \r\t\tstudentName := (studentClassTuple at: 1). \r\t\tstudentClass := (studentClassTuple at: 2).\r\t\t\r\t\tstudents at: studentClass \r\t\t\tupdate: [ :existingStudents |\r\t\t\t\texistingStudents add: studentName .\r\t\t\t\tstudents at: studentClass put: existingStudents\r\t\t\t\t]\r\t\t\tinitial: [SortedCollection with: studentName]\r\t\t].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/17/2023 12:45',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-17T12:51:12.629003+11:00' ],		#prior : OmReference [ '535' ],		#self : OmReference [ '536' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| studentName studentClass |\r\t\t\r\tstudents := OrderedDictionary new.\r\t\r\taStudentArray do: [ :studentClassTuple | \r\t\tstudentName := (studentClassTuple at: 1). \r\t\tstudentClass := (studentClassTuple at: 2).\r\t\t\r\t\tstudents at: studentClass \r\t\t\tupdate: [ :existingStudents |\r\t\t\t\texistingStudents add: studentName .\r\t\t\t\tstudents at: studentClass put: existingStudents\r\t\t\t\t]\r\t\t\tinitial: [SortedCollection with: studentName]\r\t\t].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/17/2023 12:45',			#package : #'Exercise@GradeSchool'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #GradeSchool,				#isMetaSide : false			},			#name : #'addStudents:',			#protocol : #adding,			#sourceCode : 'addStudents: aStudentArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| studentName studentClass |\r\t\t\r\tstudents := OrderedDictionary new.\r\t\r\taStudentArray do: [ :studentClassTuple | \r\t\tstudentName := studentClassTuple first. \r\t\tstudentClass := studentClassTuple last.\r\t\t\r\t\tstudents at: studentClass \r\t\t\tupdate: [ :existingStudents |\r\t\t\t\texistingStudents add: studentName .\r\t\t\t\tstudents at: studentClass put: existingStudents\r\t\t\t\t]\r\t\t\tinitial: [SortedCollection with: studentName]\r\t\t].\r\t\t\t\r\t',			#stamp : 'AndyMarks 12/17/2023 12:51',			#package : #'Exercise@GradeSchool'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T19:56:12.501754+11:00' ],		#prior : OmReference [ '536' ],		#self : OmReference [ '537' ]	},	#content : EpCategoryAddition {		#classCategoryName : #'Exercise@Forth',		#affectedPackageName : #'Exercise@Forth'	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T19:56:12.503425+11:00' ],		#prior : OmReference [ '537' ],		#self : OmReference [ '538' ]	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'ExercismTest subclass: #ForthTest\r\tinstanceVariableNames: \'forthCalculator\'\r\tclassVariableNames: \'\'\r\tpackage: \'Exercise@Forth\'',				#superclassName : 'ExercismTest'			},			#name : #ForthTest,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ForthTest,						#isMetaSide : false					},					#name : #forthCalculator,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ForthTest class\r\tinstanceVariableNames: \'\''				},				#name : #'ForthTest class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ForthTest,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #'Exercise@Forth',			#package : #'Exercise@Forth',			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T19:56:12.511751+11:00' ],		#prior : OmReference [ '538' ],		#self : OmReference [ '539' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'ExercismTest subclass: #ForthTest\r\tinstanceVariableNames: \'forthCalculator\'\r\tclassVariableNames: \'\'\r\tpackage: \'Exercise@Forth\'',				#superclassName : 'ExercismTest'			},			#name : #ForthTest,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ForthTest,						#isMetaSide : false					},					#name : #forthCalculator,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ForthTest class\r\tinstanceVariableNames: \'\''				},				#name : #'ForthTest class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ForthTest,					#isMetaSide : false				},				#parent : @7,				#content : '# Forth\r\rImplement an evaluator for a very simple subset of Forth.\r\r[Forth](https://en.wikipedia.org/wiki/Forth_%28programming_language%29)\ris a stack-based programming language. Implement a very basic evaluator\rfor a small subset of Forth.\r\rYour evaluator has to support the following words:\r\r- `+`, `-`, `*`, `/` (integer arithmetic)\r- `DUP`, `DROP`, `SWAP`, `OVER` (stack manipulation)\r\rYour evaluator also has to support defining new words using the\rcustomary syntax: `: word-name definition ;`.\r\rTo keep things simple the only data type you need to support is signed\rintegers of at least 16 bits size.\r\rYou should use the following rules for the syntax: a number is a\rsequence of one or more (ASCII) digits, a word is a sequence of one or\rmore letters, digits, symbols or punctuation that is not a number.\r(Forth probably uses slightly different rules, but this is close\renough.)\r\rWords are case-insensitive.\r\r## Hint\r\rIt might take several classes and/or instances to model this\r',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #'Exercise@Forth',			#package : #'Exercise@Forth',			#sharedPools : OrderedCollection [ ]		},		#oldComment : '',		#newComment : '# Forth\r\rImplement an evaluator for a very simple subset of Forth.\r\r[Forth](https://en.wikipedia.org/wiki/Forth_%28programming_language%29)\ris a stack-based programming language. Implement a very basic evaluator\rfor a small subset of Forth.\r\rYour evaluator has to support the following words:\r\r- `+`, `-`, `*`, `/` (integer arithmetic)\r- `DUP`, `DROP`, `SWAP`, `OVER` (stack manipulation)\r\rYour evaluator also has to support defining new words using the\rcustomary syntax: `: word-name definition ;`.\r\rTo keep things simple the only data type you need to support is signed\rintegers of at least 16 bits size.\r\rYou should use the following rules for the syntax: a number is a\rsequence of one or more (ASCII) digits, a word is a sequence of one or\rmore letters, digits, symbols or punctuation that is not a number.\r(Forth probably uses slightly different rules, but this is close\renough.)\r\rWords are case-insensitive.\r\r## Hint\r\rIt might take several classes and/or instances to model this\r',		#oldStamp : '',		#newStamp : ''	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T19:56:12.574153+11:00' ],		#prior : OmReference [ '539' ],		#self : OmReference [ '540' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ForthTest class',				#isMetaSide : true			},			#name : #exercise,			#protocol : #config,			#sourceCode : 'exercise\r\t"Answer the configured exercise meta data for this exercise, an ExercismExercise"\r\r\t^ (self createExerciseAfter: GradeSchoolTest)\r\t\tisCore: true;\r\t\tdifficulty: 6;\r\t\ttopics: #(\'parsing\' \'stacks\');\r\t\tyourself',			#stamp : '',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T19:56:12.574816+11:00' ],		#prior : OmReference [ '540' ],		#self : OmReference [ '541' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ForthTest class',				#isMetaSide : true			},			#name : #uuid,			#protocol : #config,			#sourceCode : 'uuid\r\t"Answer a unique id for this exercise"\r\t^\'98e35398-a743-0d00-aeac-1c4207045670\'',			#stamp : '',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T19:56:12.575376+11:00' ],		#prior : OmReference [ '541' ],		#self : OmReference [ '542' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ForthTest class',				#isMetaSide : true			},			#name : #version,			#protocol : #config,			#sourceCode : 'version\r\t"Generated from specification: 24 April 2019"\r\t^\'1.7.0\'',			#stamp : '',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T19:56:12.575819+11:00' ],		#prior : OmReference [ '542' ],		#self : OmReference [ '543' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForthTest,				#isMetaSide : false			},			#name : #setUp,			#protocol : #running,			#sourceCode : 'setUp\r\tsuper setUp.\r\tforthCalculator := Forth new',			#stamp : '',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T19:56:12.576101+11:00' ],		#prior : OmReference [ '543' ],		#self : OmReference [ '544' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForthTest,				#isMetaSide : false			},			#name : #test01_ParsingAndNumbersNumbersJustGetPushedOntoTheStack,			#protocol : #tests,			#sourceCode : 'test01_ParsingAndNumbersNumbersJustGetPushedOntoTheStack\r\t| result |\r\r\tresult := forthCalculator evaluateInstructions: #(\'1 2 3 4 5\' ) .\r\tself assert: result equals: #(1 2 3 4 5 )',			#stamp : '',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T19:56:12.57636+11:00' ],		#prior : OmReference [ '544' ],		#self : OmReference [ '545' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForthTest,				#isMetaSide : false			},			#name : #test02_AdditionCanAddTwoNumbers,			#protocol : #tests,			#sourceCode : 'test02_AdditionCanAddTwoNumbers\r\t| result |\r\r\tresult := forthCalculator evaluateInstructions: #(\'1 2 +\' ) .\r\tself assert: result equals: #(3 )',			#stamp : '',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T19:56:12.57656+11:00' ],		#prior : OmReference [ '545' ],		#self : OmReference [ '546' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForthTest,				#isMetaSide : false			},			#name : #test03_AdditionErrorsIfThereIsNothingOnTheStack,			#protocol : #tests,			#sourceCode : 'test03_AdditionErrorsIfThereIsNothingOnTheStack\r\t| result |\r\r\tself\r\t\tshould: [ result := forthCalculator evaluateInstructions: #(\'+\' ) ]\r\t\traise: Error\r\t\twhoseDescriptionIncludes: \'empty stack\'\r\t\tdescription: \'Should get an error with the correct description\'',			#stamp : '',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T19:56:12.576803+11:00' ],		#prior : OmReference [ '546' ],		#self : OmReference [ '547' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForthTest,				#isMetaSide : false			},			#name : #test04_AdditionErrorsIfThereIsOnlyOneValueOnTheStack,			#protocol : #tests,			#sourceCode : 'test04_AdditionErrorsIfThereIsOnlyOneValueOnTheStack\r\t| result |\r\r\tself\r\t\tshould: [ result := forthCalculator evaluateInstructions: #(\'1 +\' ) ]\r\t\traise: Error\r\t\twhoseDescriptionIncludes: \'only one value on the stack\'\r\t\tdescription: \'Should get an error with the correct description\'',			#stamp : '',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T19:56:12.576993+11:00' ],		#prior : OmReference [ '547' ],		#self : OmReference [ '548' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForthTest,				#isMetaSide : false			},			#name : #test05_SubtractionCanSubtractTwoNumbers,			#protocol : #tests,			#sourceCode : 'test05_SubtractionCanSubtractTwoNumbers\r\t| result |\r\r\tresult := forthCalculator evaluateInstructions: #(\'3 4 -\' ) .\r\tself assert: result equals: #( -1 )',			#stamp : '',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T19:56:12.57718+11:00' ],		#prior : OmReference [ '548' ],		#self : OmReference [ '549' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForthTest,				#isMetaSide : false			},			#name : #test06_SubtractionErrorsIfThereIsNothingOnTheStack,			#protocol : #tests,			#sourceCode : 'test06_SubtractionErrorsIfThereIsNothingOnTheStack\r\t| result |\r\r\tself\r\t\tshould: [ result := forthCalculator evaluateInstructions: #(\'-\' ) ]\r\t\traise: Error\r\t\twhoseDescriptionIncludes: \'empty stack\'\r\t\tdescription: \'Should get an error with the correct description\'',			#stamp : '',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T19:56:12.577372+11:00' ],		#prior : OmReference [ '549' ],		#self : OmReference [ '550' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForthTest,				#isMetaSide : false			},			#name : #test07_SubtractionErrorsIfThereIsOnlyOneValueOnTheStack,			#protocol : #tests,			#sourceCode : 'test07_SubtractionErrorsIfThereIsOnlyOneValueOnTheStack\r\t| result |\r\r\tself\r\t\tshould: [ result := forthCalculator evaluateInstructions: #(\'1 -\' ) ]\r\t\traise: Error\r\t\twhoseDescriptionIncludes: \'only one value on the stack\'\r\t\tdescription: \'Should get an error with the correct description\'',			#stamp : '',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T19:56:12.577571+11:00' ],		#prior : OmReference [ '550' ],		#self : OmReference [ '551' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForthTest,				#isMetaSide : false			},			#name : #test08_MultiplicationCanMultiplyTwoNumbers,			#protocol : #tests,			#sourceCode : 'test08_MultiplicationCanMultiplyTwoNumbers\r\t| result |\r\r\tresult := forthCalculator evaluateInstructions: #(\'2 4 *\' ) .\r\tself assert: result equals: #(8 )',			#stamp : '',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T19:56:12.577868+11:00' ],		#prior : OmReference [ '551' ],		#self : OmReference [ '552' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForthTest,				#isMetaSide : false			},			#name : #test09_MultiplicationErrorsIfThereIsNothingOnTheStack,			#protocol : #tests,			#sourceCode : 'test09_MultiplicationErrorsIfThereIsNothingOnTheStack\r\t| result |\r\r\tself\r\t\tshould: [ result := forthCalculator evaluateInstructions: #(\'*\' ) ]\r\t\traise: Error\r\t\twhoseDescriptionIncludes: \'empty stack\'\r\t\tdescription: \'Should get an error with the correct description\'',			#stamp : '',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T19:56:12.578104+11:00' ],		#prior : OmReference [ '552' ],		#self : OmReference [ '553' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForthTest,				#isMetaSide : false			},			#name : #test10_MultiplicationErrorsIfThereIsOnlyOneValueOnTheStack,			#protocol : #tests,			#sourceCode : 'test10_MultiplicationErrorsIfThereIsOnlyOneValueOnTheStack\r\t| result |\r\r\tself\r\t\tshould: [ result := forthCalculator evaluateInstructions: #(\'1 *\' ) ]\r\t\traise: Error\r\t\twhoseDescriptionIncludes: \'only one value on the stack\'\r\t\tdescription: \'Should get an error with the correct description\'',			#stamp : '',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T19:56:12.578312+11:00' ],		#prior : OmReference [ '553' ],		#self : OmReference [ '554' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForthTest,				#isMetaSide : false			},			#name : #test11_DivisionCanDivideTwoNumbers,			#protocol : #tests,			#sourceCode : 'test11_DivisionCanDivideTwoNumbers\r\t| result |\r\r\tresult := forthCalculator evaluateInstructions: #(\'12 3 /\' ) .\r\tself assert: result equals: #(4 )',			#stamp : '',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T19:56:12.581132+11:00' ],		#prior : OmReference [ '554' ],		#self : OmReference [ '555' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForthTest,				#isMetaSide : false			},			#name : #test12_DivisionPerformsIntegerDivision,			#protocol : #tests,			#sourceCode : 'test12_DivisionPerformsIntegerDivision\r\t| result |\r\r\tresult := forthCalculator evaluateInstructions: #(\'8 3 /\' ) .\r\tself assert: result equals: #(2 )',			#stamp : '',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T19:56:12.581321+11:00' ],		#prior : OmReference [ '555' ],		#self : OmReference [ '556' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForthTest,				#isMetaSide : false			},			#name : #test13_DivisionErrorsIfDividingByZero,			#protocol : #tests,			#sourceCode : 'test13_DivisionErrorsIfDividingByZero\r\t| result |\r\r\tself\r\t\tshould: [ result := forthCalculator evaluateInstructions: #(\'4 0 /\' ) ]\r\t\traise: Error\r\t\twhoseDescriptionIncludes: \'divide by zero\'\r\t\tdescription: \'Should get an error with the correct description\'',			#stamp : '',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T19:56:12.581492+11:00' ],		#prior : OmReference [ '556' ],		#self : OmReference [ '557' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForthTest,				#isMetaSide : false			},			#name : #test14_DivisionErrorsIfThereIsNothingOnTheStack,			#protocol : #tests,			#sourceCode : 'test14_DivisionErrorsIfThereIsNothingOnTheStack\r\t| result |\r\r\tself\r\t\tshould: [ result := forthCalculator evaluateInstructions: #(\'/\' ) ]\r\t\traise: Error\r\t\twhoseDescriptionIncludes: \'empty stack\'\r\t\tdescription: \'Should get an error with the correct description\'',			#stamp : '',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T19:56:12.581666+11:00' ],		#prior : OmReference [ '557' ],		#self : OmReference [ '558' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForthTest,				#isMetaSide : false			},			#name : #test15_DivisionErrorsIfThereIsOnlyOneValueOnTheStack,			#protocol : #tests,			#sourceCode : 'test15_DivisionErrorsIfThereIsOnlyOneValueOnTheStack\r\t| result |\r\r\tself\r\t\tshould: [ result := forthCalculator evaluateInstructions: #(\'1 /\' ) ]\r\t\traise: Error\r\t\twhoseDescriptionIncludes: \'only one value on the stack\'\r\t\tdescription: \'Should get an error with the correct description\'',			#stamp : '',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T19:56:12.581936+11:00' ],		#prior : OmReference [ '558' ],		#self : OmReference [ '559' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForthTest,				#isMetaSide : false			},			#name : #test16_CombinedArithmeticAdditionAndSubtraction,			#protocol : #tests,			#sourceCode : 'test16_CombinedArithmeticAdditionAndSubtraction\r\t| result |\r\r\tresult := forthCalculator evaluateInstructions: #(\'1 2 + 4 -\' ) .\r\tself assert: result equals: #( -1 )',			#stamp : '',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T19:56:12.582104+11:00' ],		#prior : OmReference [ '559' ],		#self : OmReference [ '560' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForthTest,				#isMetaSide : false			},			#name : #test17_CombinedArithmeticMultiplicationAndDivision,			#protocol : #tests,			#sourceCode : 'test17_CombinedArithmeticMultiplicationAndDivision\r\t| result |\r\r\tresult := forthCalculator evaluateInstructions: #(\'2 4 * 3 /\' ) .\r\tself assert: result equals: #(2 )',			#stamp : '',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T19:56:12.582273+11:00' ],		#prior : OmReference [ '560' ],		#self : OmReference [ '561' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForthTest,				#isMetaSide : false			},			#name : #test18_DupCopiesAValueOnTheStack,			#protocol : #tests,			#sourceCode : 'test18_DupCopiesAValueOnTheStack\r\t| result |\r\r\tresult := forthCalculator evaluateInstructions: #(\'1 dup\' ) .\r\tself assert: result equals: #(1 1 )',			#stamp : '',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T19:56:12.582437+11:00' ],		#prior : OmReference [ '561' ],		#self : OmReference [ '562' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForthTest,				#isMetaSide : false			},			#name : #test19_DupCopiesTheTopValueOnTheStack,			#protocol : #tests,			#sourceCode : 'test19_DupCopiesTheTopValueOnTheStack\r\t| result |\r\r\tresult := forthCalculator evaluateInstructions: #(\'1 2 dup\' ) .\r\tself assert: result equals: #(1 2 2 )',			#stamp : '',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T19:56:12.582601+11:00' ],		#prior : OmReference [ '562' ],		#self : OmReference [ '563' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForthTest,				#isMetaSide : false			},			#name : #test20_DupErrorsIfThereIsNothingOnTheStack,			#protocol : #tests,			#sourceCode : 'test20_DupErrorsIfThereIsNothingOnTheStack\r\t| result |\r\r\tself\r\t\tshould: [ result := forthCalculator evaluateInstructions: #(\'dup\' ) ]\r\t\traise: Error\r\t\twhoseDescriptionIncludes: \'empty stack\'\r\t\tdescription: \'Should get an error with the correct description\'',			#stamp : '',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T19:56:12.58276+11:00' ],		#prior : OmReference [ '563' ],		#self : OmReference [ '564' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForthTest,				#isMetaSide : false			},			#name : #test21_DropRemovesTheTopValueOnTheStackIfItIsTheOnlyOne,			#protocol : #tests,			#sourceCode : 'test21_DropRemovesTheTopValueOnTheStackIfItIsTheOnlyOne\r\t| result |\r\r\tresult := forthCalculator evaluateInstructions: #(\'1 drop\' ) .\r\tself assert: result equals: #()',			#stamp : '',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T19:56:12.582919+11:00' ],		#prior : OmReference [ '564' ],		#self : OmReference [ '565' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForthTest,				#isMetaSide : false			},			#name : #test22_DropRemovesTheTopValueOnTheStackIfItIsNotTheOnlyOne,			#protocol : #tests,			#sourceCode : 'test22_DropRemovesTheTopValueOnTheStackIfItIsNotTheOnlyOne\r\t| result |\r\r\tresult := forthCalculator evaluateInstructions: #(\'1 2 drop\' ) .\r\tself assert: result equals: #(1 )',			#stamp : '',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T19:56:12.583083+11:00' ],		#prior : OmReference [ '565' ],		#self : OmReference [ '566' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForthTest,				#isMetaSide : false			},			#name : #test23_DropErrorsIfThereIsNothingOnTheStack,			#protocol : #tests,			#sourceCode : 'test23_DropErrorsIfThereIsNothingOnTheStack\r\t| result |\r\r\tself\r\t\tshould: [ result := forthCalculator evaluateInstructions: #(\'drop\' ) ]\r\t\traise: Error\r\t\twhoseDescriptionIncludes: \'empty stack\'\r\t\tdescription: \'Should get an error with the correct description\'',			#stamp : '',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T19:56:12.583242+11:00' ],		#prior : OmReference [ '566' ],		#self : OmReference [ '567' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForthTest,				#isMetaSide : false			},			#name : #test24_SwapSwapsTheTopTwoValuesOnTheStackIfTheyAreTheOnlyOnes,			#protocol : #tests,			#sourceCode : 'test24_SwapSwapsTheTopTwoValuesOnTheStackIfTheyAreTheOnlyOnes\r\t| result |\r\r\tresult := forthCalculator evaluateInstructions: #(\'1 2 swap\' ) .\r\tself assert: result equals: #(2 1 )',			#stamp : '',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T19:56:12.583402+11:00' ],		#prior : OmReference [ '567' ],		#self : OmReference [ '568' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForthTest,				#isMetaSide : false			},			#name : #test25_SwapSwapsTheTopTwoValuesOnTheStackIfTheyAreNotTheOnlyOnes,			#protocol : #tests,			#sourceCode : 'test25_SwapSwapsTheTopTwoValuesOnTheStackIfTheyAreNotTheOnlyOnes\r\t| result |\r\r\tresult := forthCalculator evaluateInstructions: #(\'1 2 3 swap\' ) .\r\tself assert: result equals: #(1 3 2 )',			#stamp : '',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T19:56:12.583565+11:00' ],		#prior : OmReference [ '568' ],		#self : OmReference [ '569' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForthTest,				#isMetaSide : false			},			#name : #test26_SwapErrorsIfThereIsNothingOnTheStack,			#protocol : #tests,			#sourceCode : 'test26_SwapErrorsIfThereIsNothingOnTheStack\r\t| result |\r\r\tself\r\t\tshould: [ result := forthCalculator evaluateInstructions: #(\'swap\' ) ]\r\t\traise: Error\r\t\twhoseDescriptionIncludes: \'empty stack\'\r\t\tdescription: \'Should get an error with the correct description\'',			#stamp : '',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T19:56:12.583728+11:00' ],		#prior : OmReference [ '569' ],		#self : OmReference [ '570' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForthTest,				#isMetaSide : false			},			#name : #test27_SwapErrorsIfThereIsOnlyOneValueOnTheStack,			#protocol : #tests,			#sourceCode : 'test27_SwapErrorsIfThereIsOnlyOneValueOnTheStack\r\t| result |\r\r\tself\r\t\tshould: [ result := forthCalculator evaluateInstructions: #(\'1 swap\' ) ]\r\t\traise: Error\r\t\twhoseDescriptionIncludes: \'only one value on the stack\'\r\t\tdescription: \'Should get an error with the correct description\'',			#stamp : '',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T19:56:12.58389+11:00' ],		#prior : OmReference [ '570' ],		#self : OmReference [ '571' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForthTest,				#isMetaSide : false			},			#name : #test28_OverCopiesTheSecondElementIfThereAreOnlyTwo,			#protocol : #tests,			#sourceCode : 'test28_OverCopiesTheSecondElementIfThereAreOnlyTwo\r\t| result |\r\r\tresult := forthCalculator evaluateInstructions: #(\'1 2 over\' ) .\r\tself assert: result equals: #(1 2 1 )',			#stamp : '',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T19:56:12.584049+11:00' ],		#prior : OmReference [ '571' ],		#self : OmReference [ '572' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForthTest,				#isMetaSide : false			},			#name : #test29_OverCopiesTheSecondElementIfThereAreMoreThanTwo,			#protocol : #tests,			#sourceCode : 'test29_OverCopiesTheSecondElementIfThereAreMoreThanTwo\r\t| result |\r\r\tresult := forthCalculator evaluateInstructions: #(\'1 2 3 over\' ) .\r\tself assert: result equals: #(1 2 3 2 )',			#stamp : '',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T19:56:12.584209+11:00' ],		#prior : OmReference [ '572' ],		#self : OmReference [ '573' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForthTest,				#isMetaSide : false			},			#name : #test30_OverErrorsIfThereIsNothingOnTheStack,			#protocol : #tests,			#sourceCode : 'test30_OverErrorsIfThereIsNothingOnTheStack\r\t| result |\r\r\tself\r\t\tshould: [ result := forthCalculator evaluateInstructions: #(\'over\' ) ]\r\t\traise: Error\r\t\twhoseDescriptionIncludes: \'empty stack\'\r\t\tdescription: \'Should get an error with the correct description\'',			#stamp : '',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T19:56:12.584369+11:00' ],		#prior : OmReference [ '573' ],		#self : OmReference [ '574' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForthTest,				#isMetaSide : false			},			#name : #test31_OverErrorsIfThereIsOnlyOneValueOnTheStack,			#protocol : #tests,			#sourceCode : 'test31_OverErrorsIfThereIsOnlyOneValueOnTheStack\r\t| result |\r\r\tself\r\t\tshould: [ result := forthCalculator evaluateInstructions: #(\'1 over\' ) ]\r\t\traise: Error\r\t\twhoseDescriptionIncludes: \'only one value on the stack\'\r\t\tdescription: \'Should get an error with the correct description\'',			#stamp : '',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T19:56:12.584525+11:00' ],		#prior : OmReference [ '574' ],		#self : OmReference [ '575' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForthTest,				#isMetaSide : false			},			#name : #test32_UserdefinedWordsCanConsistOfBuiltinWords,			#protocol : #tests,			#sourceCode : 'test32_UserdefinedWordsCanConsistOfBuiltinWords\r\t| result |\r\r\tresult := forthCalculator evaluateInstructions: #(\': dup-twice dup dup ;\' \'1 dup-twice\' ) .\r\tself assert: result equals: #(1 1 1 )',			#stamp : '',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T19:56:12.58469+11:00' ],		#prior : OmReference [ '575' ],		#self : OmReference [ '576' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForthTest,				#isMetaSide : false			},			#name : #test33_UserdefinedWordsExecuteInTheRightOrder,			#protocol : #tests,			#sourceCode : 'test33_UserdefinedWordsExecuteInTheRightOrder\r\t| result |\r\r\tresult := forthCalculator evaluateInstructions: #(\': countup 1 2 3 ;\' \'countup\' ) .\r\tself assert: result equals: #(1 2 3 )',			#stamp : '',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T19:56:12.584849+11:00' ],		#prior : OmReference [ '576' ],		#self : OmReference [ '577' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForthTest,				#isMetaSide : false			},			#name : #test34_UserdefinedWordsCanOverrideOtherUserdefinedWords,			#protocol : #tests,			#sourceCode : 'test34_UserdefinedWordsCanOverrideOtherUserdefinedWords\r\t| result |\r\r\tresult := forthCalculator evaluateInstructions: #(\': foo dup ;\' \': foo dup dup ;\' \'1 foo\' ) .\r\tself assert: result equals: #(1 1 1 )',			#stamp : '',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T19:56:12.585007+11:00' ],		#prior : OmReference [ '577' ],		#self : OmReference [ '578' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForthTest,				#isMetaSide : false			},			#name : #test35_UserdefinedWordsCanOverrideBuiltinWords,			#protocol : #tests,			#sourceCode : 'test35_UserdefinedWordsCanOverrideBuiltinWords\r\t| result |\r\r\tresult := forthCalculator evaluateInstructions: #(\': swap dup ;\' \'1 swap\' ) .\r\tself assert: result equals: #(1 1 )',			#stamp : '',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T19:56:12.585178+11:00' ],		#prior : OmReference [ '578' ],		#self : OmReference [ '579' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForthTest,				#isMetaSide : false			},			#name : #test36_UserdefinedWordsCanOverrideBuiltinOperators,			#protocol : #tests,			#sourceCode : 'test36_UserdefinedWordsCanOverrideBuiltinOperators\r\t| result |\r\r\tresult := forthCalculator evaluateInstructions: #(\': + * ;\' \'3 4 +\' ) .\r\tself assert: result equals: #(12 )',			#stamp : '',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T19:56:12.58534+11:00' ],		#prior : OmReference [ '579' ],		#self : OmReference [ '580' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForthTest,				#isMetaSide : false			},			#name : #test37_UserdefinedWordsCanUseDifferentWordsWithTheSameName,			#protocol : #tests,			#sourceCode : 'test37_UserdefinedWordsCanUseDifferentWordsWithTheSameName\r\t| result |\r\r\tresult := forthCalculator evaluateInstructions: #(\': foo 5 ;\' \': bar foo ;\' \': foo 6 ;\' \'bar foo\' ) .\r\tself assert: result equals: #(5 6 )',			#stamp : '',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T19:56:12.585498+11:00' ],		#prior : OmReference [ '580' ],		#self : OmReference [ '581' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForthTest,				#isMetaSide : false			},			#name : #test38_UserdefinedWordsCanDefineWordThatUsesWordWithTheSameName,			#protocol : #tests,			#sourceCode : 'test38_UserdefinedWordsCanDefineWordThatUsesWordWithTheSameName\r\t| result |\r\r\tresult := forthCalculator evaluateInstructions: #(\': foo 10 ;\' \': foo foo 1 + ;\' \'foo\' ) .\r\tself assert: result equals: #(11 )',			#stamp : '',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T19:56:12.585661+11:00' ],		#prior : OmReference [ '581' ],		#self : OmReference [ '582' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForthTest,				#isMetaSide : false			},			#name : #test39_UserdefinedWordsCannotRedefineNumbers,			#protocol : #tests,			#sourceCode : 'test39_UserdefinedWordsCannotRedefineNumbers\r\t| result |\r\r\tself\r\t\tshould: [ result := forthCalculator evaluateInstructions: #(\': 1 2 ;\' ) ]\r\t\traise: Error\r\t\twhoseDescriptionIncludes: \'illegal operation\'\r\t\tdescription: \'Should get an error with the correct description\'',			#stamp : '',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T19:56:12.585823+11:00' ],		#prior : OmReference [ '582' ],		#self : OmReference [ '583' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForthTest,				#isMetaSide : false			},			#name : #test40_UserdefinedWordsErrorsIfExecutingANonexistentWord,			#protocol : #tests,			#sourceCode : 'test40_UserdefinedWordsErrorsIfExecutingANonexistentWord\r\t| result |\r\r\tself\r\t\tshould: [ result := forthCalculator evaluateInstructions: #(\'foo\' ) ]\r\t\traise: Error\r\t\twhoseDescriptionIncludes: \'undefined operation\'\r\t\tdescription: \'Should get an error with the correct description\'',			#stamp : '',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T19:56:12.585982+11:00' ],		#prior : OmReference [ '583' ],		#self : OmReference [ '584' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForthTest,				#isMetaSide : false			},			#name : #test41_CaseinsensitivityDUPIsCaseinsensitive,			#protocol : #tests,			#sourceCode : 'test41_CaseinsensitivityDUPIsCaseinsensitive\r\t| result |\r\r\tresult := forthCalculator evaluateInstructions: #(\'1 DUP Dup dup\' ) .\r\tself assert: result equals: #(1 1 1 1 )',			#stamp : '',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T19:56:12.592678+11:00' ],		#prior : OmReference [ '584' ],		#self : OmReference [ '585' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForthTest,				#isMetaSide : false			},			#name : #test42_CaseinsensitivityDROPIsCaseinsensitive,			#protocol : #tests,			#sourceCode : 'test42_CaseinsensitivityDROPIsCaseinsensitive\r\t| result |\r\r\tresult := forthCalculator evaluateInstructions: #(\'1 2 3 4 DROP Drop drop\' ) .\r\tself assert: result equals: #(1 )',			#stamp : '',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T19:56:12.592902+11:00' ],		#prior : OmReference [ '585' ],		#self : OmReference [ '586' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForthTest,				#isMetaSide : false			},			#name : #test43_CaseinsensitivitySWAPIsCaseinsensitive,			#protocol : #tests,			#sourceCode : 'test43_CaseinsensitivitySWAPIsCaseinsensitive\r\t| result |\r\r\tresult := forthCalculator evaluateInstructions: #(\'1 2 SWAP 3 Swap 4 swap\' ) .\r\tself assert: result equals: #(2 3 4 1 )',			#stamp : '',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T19:56:12.593068+11:00' ],		#prior : OmReference [ '586' ],		#self : OmReference [ '587' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForthTest,				#isMetaSide : false			},			#name : #test44_CaseinsensitivityOVERIsCaseinsensitive,			#protocol : #tests,			#sourceCode : 'test44_CaseinsensitivityOVERIsCaseinsensitive\r\t| result |\r\r\tresult := forthCalculator evaluateInstructions: #(\'1 2 OVER Over over\' ) .\r\tself assert: result equals: #(1 2 1 2 1 )',			#stamp : '',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T19:56:12.59323+11:00' ],		#prior : OmReference [ '587' ],		#self : OmReference [ '588' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForthTest,				#isMetaSide : false			},			#name : #test45_CaseinsensitivityUserdefinedWordsAreCaseinsensitive,			#protocol : #tests,			#sourceCode : 'test45_CaseinsensitivityUserdefinedWordsAreCaseinsensitive\r\t| result |\r\r\tresult := forthCalculator evaluateInstructions: #(\': foo dup ;\' \'1 FOO Foo foo\' ) .\r\tself assert: result equals: #(1 1 1 1 )',			#stamp : '',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T19:56:12.593392+11:00' ],		#prior : OmReference [ '588' ],		#self : OmReference [ '589' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForthTest,				#isMetaSide : false			},			#name : #test46_CaseinsensitivityDefinitionsAreCaseinsensitive,			#protocol : #tests,			#sourceCode : 'test46_CaseinsensitivityDefinitionsAreCaseinsensitive\r\t| result |\r\r\tresult := forthCalculator evaluateInstructions: #(\': SWAP DUP Dup dup ;\' \'1 swap\' ) .\r\tself assert: result equals: #(1 1 1 1 )',			#stamp : '',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T19:56:35.258393+11:00' ],		#prior : OmReference [ '589' ],		#self : OmReference [ '590' ]	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Forth\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpackage: \'Exercise@Forth\'',				#superclassName : 'Object'			},			#name : #Forth,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Forth class\r\tinstanceVariableNames: \'\''				},				#name : #'Forth class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Forth,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #'Exercise@Forth',			#package : #'Exercise@Forth',			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T19:57:11.704755+11:00' ],		#prior : OmReference [ '590' ],		#self : OmReference [ '591' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #'as yet unclassified',			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t^#().',			#stamp : 'AndyMarks 12/18/2023 19:57',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T19:57:25.729051+11:00' ],		#prior : OmReference [ '591' ],		#self : OmReference [ '592' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #'as yet unclassified',			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t^#().',			#stamp : 'AndyMarks 12/18/2023 19:57',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t^#().',			#stamp : 'AndyMarks 12/18/2023 19:57',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T20:02:43.116058+11:00' ],		#prior : OmReference [ '592' ],		#self : OmReference [ '593' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t^#().',			#stamp : 'AndyMarks 12/18/2023 19:57',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| result |\r\t\r\tresult := #().\r\t^result.',			#stamp : 'AndyMarks 12/18/2023 20:02',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T20:04:02.441823+11:00' ],		#prior : OmReference [ '593' ],		#self : OmReference [ '594' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| result |\r\t\r\tresult := #().\r\t^result.',			#stamp : 'AndyMarks 12/18/2023 20:02',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| result |\r\t\r\tresult := OrderedCollection new.\r\t\r\tanInstructionArray do: [ :element | \r\t\tresult add: element\r\t\t].\r\t^result asArray.',			#stamp : 'AndyMarks 12/18/2023 20:04',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T20:04:03.851361+11:00' ],		#prior : OmReference [ '594' ],		#self : OmReference [ '595' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| result |\r\t\r\tresult := OrderedCollection new.\r\t\r\tanInstructionArray do: [ :element | \r\t\tresult add: element\r\t\t].\r\t^result asArray.',			#stamp : 'AndyMarks 12/18/2023 20:04',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| result |\r\t\r\tresult := OrderedCollection new.\r\t\r\tanInstructionArray do: [ :element | \r\t\tresult add: element\r\t\t].\r\t\r\t^result asArray.',			#stamp : 'AndyMarks 12/18/2023 20:04',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T20:05:09.911719+11:00' ],		#prior : OmReference [ '595' ],		#self : OmReference [ '596' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| result |\r\t\r\tresult := OrderedCollection new.\r\t\r\tanInstructionArray do: [ :element | \r\t\tresult add: element\r\t\t].\r\t\r\t^result asArray.',			#stamp : 'AndyMarks 12/18/2023 20:04',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| result elements |\r\t\r\telements := anInstructionArray first.\r\t\r\tresult := OrderedCollection new.\r\t\r\telements do: [ :element | \r\t\tresult add: element\r\t\t].\r\t\r\t^result asArray.',			#stamp : 'AndyMarks 12/18/2023 20:05',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T20:07:20.216745+11:00' ],		#prior : OmReference [ '596' ],		#self : OmReference [ '597' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| result elements |\r\t\r\telements := anInstructionArray first.\r\t\r\tresult := OrderedCollection new.\r\t\r\telements do: [ :element | \r\t\tresult add: element\r\t\t].\r\t\r\t^result asArray.',			#stamp : 'AndyMarks 12/18/2023 20:05',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| result elements |\r\t\r\telements := anInstructionArray first.\r\t\r\tresult := OrderedCollection new.\r\t\r\telements findTokens: Character space do: [ :element | \r\t\tresult add: element\r\t\t].\r\t\r\t^result asArray.',			#stamp : 'AndyMarks 12/18/2023 20:07',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T20:07:29.671257+11:00' ],		#prior : OmReference [ '597' ],		#self : OmReference [ '598' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| result elements |\r\t\r\telements := anInstructionArray first.\r\t\r\tresult := OrderedCollection new.\r\t\r\telements findTokens: Character space do: [ :element | \r\t\tresult add: element\r\t\t].\r\t\r\t^result asArray.',			#stamp : 'AndyMarks 12/18/2023 20:07',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| result elements |\r\t\r\telements := anInstructionArray first.\r\t\r\tresult := OrderedCollection new.\r\t\r\t(elements findTokens: Character space) do: [ :element | \r\t\tresult add: element\r\t\t].\r\t\r\t^result asArray.',			#stamp : 'AndyMarks 12/18/2023 20:07',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T20:08:34.340126+11:00' ],		#prior : OmReference [ '598' ],		#self : OmReference [ '599' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| result elements |\r\t\r\telements := anInstructionArray first.\r\t\r\tresult := OrderedCollection new.\r\t\r\t(elements findTokens: Character space) do: [ :element | \r\t\tresult add: element\r\t\t].\r\t\r\t^result asArray.',			#stamp : 'AndyMarks 12/18/2023 20:07',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| result elements |\r\t\r\telements := anInstructionArray first.\r\t\r\tresult := OrderedCollection new.\r\t\r\t(elements findTokens: Character space) do: [ :element | \r\t\telement isNumber: (result add: element)\r\t\t].\r\t\r\t^result asArray.',			#stamp : 'AndyMarks 12/18/2023 20:08',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T20:20:02.573244+11:00' ],		#prior : OmReference [ '599' ],		#self : OmReference [ '600' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| result elements |\r\t\r\telements := anInstructionArray first.\r\t\r\tresult := OrderedCollection new.\r\t\r\t(elements findTokens: Character space) do: [ :element | \r\t\telement isNumber: (result add: element)\r\t\t].\r\t\r\t^result asArray.',			#stamp : 'AndyMarks 12/18/2023 20:08',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| result elements |\r\t\r\telements := anInstructionArray first.\r\t\r\tresult := OrderedCollection new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t(NumberParser isNumber: char) ifTrue: [result add: char].\r\t].\r\t\r\t^result asArray.',			#stamp : 'AndyMarks 12/18/2023 20:20',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T20:20:25.544264+11:00' ],		#prior : OmReference [ '600' ],		#self : OmReference [ '601' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| result elements |\r\t\r\telements := anInstructionArray first.\r\t\r\tresult := OrderedCollection new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t(NumberParser isNumber: char) ifTrue: [result add: char].\r\t].\r\t\r\t^result asArray.',			#stamp : 'AndyMarks 12/18/2023 20:20',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| result elements |\r\t\r\telements := anInstructionArray first.\r\t\r\tresult := OrderedCollection new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t(NumberParser isNumber: char) ifTrue: [result add: char asNumber].\r\t].\r\t\r\t^result asArray.',			#stamp : 'AndyMarks 12/18/2023 20:20',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T20:22:20.462736+11:00' ],		#prior : OmReference [ '601' ],		#self : OmReference [ '602' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| result elements |\r\t\r\telements := anInstructionArray first.\r\t\r\tresult := OrderedCollection new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t(NumberParser isNumber: char) ifTrue: [result add: char asNumber].\r\t].\r\t\r\t^result asArray.',			#stamp : 'AndyMarks 12/18/2023 20:20',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| result elements operandStack |\r\t\r\telements := anInstructionArray first.\r\toperandStack := Stack new.\r\t\r\tresult := OrderedCollection new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t\t(NumberParser isNumber: char) ifTrue: [result add: char asNumber].\r\t].\r\t\r\t^result asArray.',			#stamp : 'AndyMarks 12/18/2023 20:22',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T20:22:49.119925+11:00' ],		#prior : OmReference [ '602' ],		#self : OmReference [ '603' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| result elements operandStack |\r\t\r\telements := anInstructionArray first.\r\toperandStack := Stack new.\r\t\r\tresult := OrderedCollection new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t\t(NumberParser isNumber: char) ifTrue: [result add: char asNumber].\r\t].\r\t\r\t^result asArray.',			#stamp : 'AndyMarks 12/18/2023 20:22',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| result elements operandStack |\r\t\r\telements := anInstructionArray first.\r\toperandStack := Stack new.\r\t\r\tresult := OrderedCollection new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t\t(NumberParser isNumber: char) ifTrue: [operandStack push: char asNumber].\r\t].\r\t\r\t^result asArray.',			#stamp : 'AndyMarks 12/18/2023 20:22',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T20:23:20.436359+11:00' ],		#prior : OmReference [ '603' ],		#self : OmReference [ '604' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| result elements operandStack |\r\t\r\telements := anInstructionArray first.\r\toperandStack := Stack new.\r\t\r\tresult := OrderedCollection new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t\t(NumberParser isNumber: char) ifTrue: [operandStack push: char asNumber].\r\t].\r\t\r\t^result asArray.',			#stamp : 'AndyMarks 12/18/2023 20:22',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| result elements operandStack |\r\t\r\telements := anInstructionArray first.\r\toperandStack := Stack new.\r\t\r\tresult := OrderedCollection new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t\t(NumberParser isNumber: char) ifTrue: [operandStack push: char asNumber].\r\t].\r\t\r\t^operandStack asArray.',			#stamp : 'AndyMarks 12/18/2023 20:23',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T20:24:04.352773+11:00' ],		#prior : OmReference [ '604' ],		#self : OmReference [ '605' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| result elements operandStack |\r\t\r\telements := anInstructionArray first.\r\toperandStack := Stack new.\r\t\r\tresult := OrderedCollection new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t\t(NumberParser isNumber: char) ifTrue: [operandStack push: char asNumber].\r\t].\r\t\r\t^operandStack asArray.',			#stamp : 'AndyMarks 12/18/2023 20:23',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| result elements operandStack |\r\t\r\telements := anInstructionArray first.\r\toperandStack := Stack new.\r\t\r\tresult := OrderedCollection new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t\t(NumberParser isNumber: char) ifTrue: [operandStack push: char asNumber].\r\t].\r\t\r\t^operandStack reversed asArray.',			#stamp : 'AndyMarks 12/18/2023 20:24',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T20:30:56.954427+11:00' ],		#prior : OmReference [ '605' ],		#self : OmReference [ '606' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| result elements operandStack |\r\t\r\telements := anInstructionArray first.\r\toperandStack := Stack new.\r\t\r\tresult := OrderedCollection new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t\t(NumberParser isNumber: char) ifTrue: [operandStack push: char asNumber].\r\t].\r\t\r\t^operandStack reversed asArray.',			#stamp : 'AndyMarks 12/18/2023 20:24',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| result elements operandStack |\r\t\r\telements := anInstructionArray first.\r\toperandStack := Stack new.\r\t\r\tresult := OrderedCollection new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t\t(NumberParser isNumber: char) ifTrue: [result := char asNumber].\r\t\t(char == \'+\') ifTrue: [ result := (operandStack pop) + (operandStack pop) ].\r\t\t\r\t\toperandStack push: result.\r\t].\r\t\r\t^operandStack reversed asArray.',			#stamp : 'AndyMarks 12/18/2023 20:30',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T20:32:35.803801+11:00' ],		#prior : OmReference [ '606' ],		#self : OmReference [ '607' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| result elements operandStack |\r\t\r\telements := anInstructionArray first.\r\toperandStack := Stack new.\r\t\r\tresult := OrderedCollection new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t\t(NumberParser isNumber: char) ifTrue: [result := char asNumber].\r\t\t(char == \'+\') ifTrue: [ result := (operandStack pop) + (operandStack pop) ].\r\t\t\r\t\toperandStack push: result.\r\t].\r\t\r\t^operandStack reversed asArray.',			#stamp : 'AndyMarks 12/18/2023 20:30',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| result elements operandStack |\r\t\r\telements := anInstructionArray first.\r\toperandStack := Stack new.\r\t\r\tresult := OrderedCollection new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t\t| operand1 operand2 |\r\t\t(NumberParser isNumber: char) ifTrue: [result := char asNumber].\r\t\t(char == \'+\') ifTrue: [ \r\t\t\toperand1 := operandStack pop.\r\t\t\toperand2 := operandStack pop.\r\t\t\tresult := operand1 + operand2.\r\t\t\t].\r\t\t\r\t\toperandStack push: result.\r\t].\r\t\r\t^operandStack reversed asArray.',			#stamp : 'AndyMarks 12/18/2023 20:32',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T20:33:26.885704+11:00' ],		#prior : OmReference [ '607' ],		#self : OmReference [ '608' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| result elements operandStack |\r\t\r\telements := anInstructionArray first.\r\toperandStack := Stack new.\r\t\r\tresult := OrderedCollection new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t\t| operand1 operand2 |\r\t\t(NumberParser isNumber: char) ifTrue: [result := char asNumber].\r\t\t(char == \'+\') ifTrue: [ \r\t\t\toperand1 := operandStack pop.\r\t\t\toperand2 := operandStack pop.\r\t\t\tresult := operand1 + operand2.\r\t\t\t].\r\t\t\r\t\toperandStack push: result.\r\t].\r\t\r\t^operandStack reversed asArray.',			#stamp : 'AndyMarks 12/18/2023 20:32',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| result elements stack |\r\t\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\t\r\tresult := OrderedCollection new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t\t| operand1 operand2 |\r\t\t(NumberParser isNumber: char) ifTrue: [result := char asNumber].\r\t\t(char == \'+\') ifTrue: [ \r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand1 + operand2.\r\t\t\t].\r\t\t\r\t\tstack push: result.\r\t].\r\t\r\t^stack reversed asArray.',			#stamp : 'AndyMarks 12/18/2023 20:33',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T20:34:18.955578+11:00' ],		#prior : OmReference [ '608' ],		#self : OmReference [ '609' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| result elements stack |\r\t\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\t\r\tresult := OrderedCollection new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t\t| operand1 operand2 |\r\t\t(NumberParser isNumber: char) ifTrue: [result := char asNumber].\r\t\t(char == \'+\') ifTrue: [ \r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand1 + operand2.\r\t\t\t].\r\t\t\r\t\tstack push: result.\r\t].\r\t\r\t^stack reversed asArray.',			#stamp : 'AndyMarks 12/18/2023 20:33',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| result elements stack |\r\t\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\t\r\tresult := OrderedCollection new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t\t| operand1 operand2 |\r\t\t(NumberParser isNumber: char) ifTrue: [result := char asNumber].\r\t\t(char == \'+\') ifTrue: [ \r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\toperand2 inspec.\r\t\t\tresult := operand1 + operand2.\r\t\t\t].\r\t\t\r\t\tstack push: result.\r\t].\r\t\r\t^stack reversed asArray.',			#stamp : 'AndyMarks 12/18/2023 20:34',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T20:34:20.539432+11:00' ],		#prior : OmReference [ '609' ],		#self : OmReference [ '610' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| result elements stack |\r\t\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\t\r\tresult := OrderedCollection new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t\t| operand1 operand2 |\r\t\t(NumberParser isNumber: char) ifTrue: [result := char asNumber].\r\t\t(char == \'+\') ifTrue: [ \r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\toperand2 inspec.\r\t\t\tresult := operand1 + operand2.\r\t\t\t].\r\t\t\r\t\tstack push: result.\r\t].\r\t\r\t^stack reversed asArray.',			#stamp : 'AndyMarks 12/18/2023 20:34',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| result elements stack |\r\t\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\t\r\tresult := OrderedCollection new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t\t| operand1 operand2 |\r\t\t(NumberParser isNumber: char) ifTrue: [result := char asNumber].\r\t\t(char == \'+\') ifTrue: [ \r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\toperand2 inspect.\r\t\t\tresult := operand1 + operand2.\r\t\t\t].\r\t\t\r\t\tstack push: result.\r\t].\r\t\r\t^stack reversed asArray.',			#stamp : 'AndyMarks 12/18/2023 20:34',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T20:36:18.026847+11:00' ],		#prior : OmReference [ '610' ],		#self : OmReference [ '611' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| result elements stack |\r\t\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\t\r\tresult := OrderedCollection new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t\t| operand1 operand2 |\r\t\t(NumberParser isNumber: char) ifTrue: [result := char asNumber].\r\t\t(char == \'+\') ifTrue: [ \r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\toperand2 inspect.\r\t\t\tresult := operand1 + operand2.\r\t\t\t].\r\t\t\r\t\tstack push: result.\r\t].\r\t\r\t^stack reversed asArray.',			#stamp : 'AndyMarks 12/18/2023 20:34',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| elements stack |\r\t\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [result := char asNumber].\r\t\t(char == \'+\') ifTrue: [ \r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\toperand2 inspect.\r\t\t\tresult := operand1 + operand2.\r\t\t\t].\r\t\t\r\t\tstack push: result.\r\t].\r\t\r\t^stack reversed asArray.',			#stamp : 'AndyMarks 12/18/2023 20:36',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T20:37:29.050975+11:00' ],		#prior : OmReference [ '611' ],		#self : OmReference [ '612' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| elements stack |\r\t\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [result := char asNumber].\r\t\t(char == \'+\') ifTrue: [ \r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\toperand2 inspect.\r\t\t\tresult := operand1 + operand2.\r\t\t\t].\r\t\t\r\t\tstack push: result.\r\t].\r\t\r\t^stack reversed asArray.',			#stamp : 'AndyMarks 12/18/2023 20:36',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| elements stack |\r\t\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [result := char asNumber].\r\t\t(char == \'+\') ifTrue: [ \r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\toperand2 inspect.\r\t\t\tresult := operand1 + operand2.\r\t\t\t].\r\t\t(char == \'dup\') ifTrue: [ \r\t\t\tresult := stack top.\r\t\t\t].\r\t\t\r\t\tstack push: result.\r\t].\r\t\r\t^stack reversed asArray.',			#stamp : 'AndyMarks 12/18/2023 20:37',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T20:39:50.876544+11:00' ],		#prior : OmReference [ '612' ],		#self : OmReference [ '613' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| elements stack |\r\t\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [result := char asNumber].\r\t\t(char == \'+\') ifTrue: [ \r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\toperand2 inspect.\r\t\t\tresult := operand1 + operand2.\r\t\t\t].\r\t\t(char == \'dup\') ifTrue: [ \r\t\t\tresult := stack top.\r\t\t\t].\r\t\t\r\t\tstack push: result.\r\t].\r\t\r\t^stack reversed asArray.',			#stamp : 'AndyMarks 12/18/2023 20:37',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| elements stack |\r\t\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [result := char asNumber].\r\t\t(char = \'+\') ifTrue: [ \r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\toperand2 inspect.\r\t\t\tresult := operand1 + operand2.\r\t\t\t].\r\t\t(char = \'dup\') ifTrue: [ \r\t\t\tresult := stack top.\r\t\t\t].\r\t\t\r\t\tstack push: result.\r\t].\r\t\r\t^stack reversed asArray.',			#stamp : 'AndyMarks 12/18/2023 20:39',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T20:43:23.316879+11:00' ],		#prior : OmReference [ '613' ],		#self : OmReference [ '614' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| elements stack |\r\t\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [result := char asNumber].\r\t\t(char = \'+\') ifTrue: [ \r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\toperand2 inspect.\r\t\t\tresult := operand1 + operand2.\r\t\t\t].\r\t\t(char = \'dup\') ifTrue: [ \r\t\t\tresult := stack top.\r\t\t\t].\r\t\t\r\t\tstack push: result.\r\t].\r\t\r\t^stack reversed asArray.',			#stamp : 'AndyMarks 12/18/2023 20:39',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| elements stack |\r\t\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [result := char asNumber].\r\t\t(char = \'+\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\toperand2 inspect.\r\t\t\tresult := operand1 + operand2.\r\t\t\t].\r\t\t(char = \'dup\') ifTrue: [ \r\t\t\tresult := stack top.\r\t\t\t].\r\t\t\r\t\tstack push: result.\r\t].\r\t\r\t^stack reversed asArray.',			#stamp : 'AndyMarks 12/18/2023 20:43',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T20:44:00.358604+11:00' ],		#prior : OmReference [ '614' ],		#self : OmReference [ '615' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| elements stack |\r\t\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [result := char asNumber].\r\t\t(char = \'+\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\toperand2 inspect.\r\t\t\tresult := operand1 + operand2.\r\t\t\t].\r\t\t(char = \'dup\') ifTrue: [ \r\t\t\tresult := stack top.\r\t\t\t].\r\t\t\r\t\tstack push: result.\r\t].\r\t\r\t^stack reversed asArray.',			#stamp : 'AndyMarks 12/18/2023 20:43',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| elements stack |\r\t\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [result := char asNumber].\r\t\t(char = \'+\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\toperand2 inspect.\r\t\t\tresult := operand1 + operand2.\r\t\t\t].\r\t\t(char = \'dup\') ifTrue: [ \r\t\t\tresult := stack top.\r\t\t\t].\r\t\t\r\t\tstack push: result.\r\t].\r\t\r\t^stack reversed asArray.',			#stamp : 'AndyMarks 12/18/2023 20:44',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T20:44:40.214014+11:00' ],		#prior : OmReference [ '615' ],		#self : OmReference [ '616' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| elements stack |\r\t\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [result := char asNumber].\r\t\t(char = \'+\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\toperand2 inspect.\r\t\t\tresult := operand1 + operand2.\r\t\t\t].\r\t\t(char = \'dup\') ifTrue: [ \r\t\t\tresult := stack top.\r\t\t\t].\r\t\t\r\t\tstack push: result.\r\t].\r\t\r\t^stack reversed asArray.',			#stamp : 'AndyMarks 12/18/2023 20:44',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| elements stack |\r\t\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [result := char asNumber].\r\t\t(char = \'+\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\toperand2 inspect.\r\t\t\tresult := operand1 + operand2.\r\t\t\t].\r\t\t(char = \'-\') ifTrue: [ \r\t\t\t"(stack size < 1) ifTrue: [ self error: \'empty stack\' ]."\r\t\t\t"(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ]."\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\toperand2 inspect.\r\t\t\tresult := operand1 - operand2.\r\t\t\t].\r\t\t(char = \'dup\') ifTrue: [ \r\t\t\tresult := stack top.\r\t\t\t].\r\t\t\r\t\tstack push: result.\r\t].\r\t\r\t^stack reversed asArray.',			#stamp : 'AndyMarks 12/18/2023 20:44',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T20:44:53.333939+11:00' ],		#prior : OmReference [ '616' ],		#self : OmReference [ '617' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| elements stack |\r\t\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [result := char asNumber].\r\t\t(char = \'+\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\toperand2 inspect.\r\t\t\tresult := operand1 + operand2.\r\t\t\t].\r\t\t(char = \'-\') ifTrue: [ \r\t\t\t"(stack size < 1) ifTrue: [ self error: \'empty stack\' ]."\r\t\t\t"(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ]."\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\toperand2 inspect.\r\t\t\tresult := operand1 - operand2.\r\t\t\t].\r\t\t(char = \'dup\') ifTrue: [ \r\t\t\tresult := stack top.\r\t\t\t].\r\t\t\r\t\tstack push: result.\r\t].\r\t\r\t^stack reversed asArray.',			#stamp : 'AndyMarks 12/18/2023 20:44',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| elements stack |\r\t\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [result := char asNumber].\r\t\t(char = \'+\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand1 + operand2.\r\t\t\t].\r\t\t(char = \'-\') ifTrue: [ \r\t\t\t"(stack size < 1) ifTrue: [ self error: \'empty stack\' ]."\r\t\t\t"(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ]."\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand1 - operand2.\r\t\t\t].\r\t\t(char = \'dup\') ifTrue: [ \r\t\t\tresult := stack top.\r\t\t\t].\r\t\t\r\t\tstack push: result.\r\t].\r\t\r\t^stack reversed asArray.',			#stamp : 'AndyMarks 12/18/2023 20:44',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T20:45:13.712283+11:00' ],		#prior : OmReference [ '617' ],		#self : OmReference [ '618' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| elements stack |\r\t\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [result := char asNumber].\r\t\t(char = \'+\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand1 + operand2.\r\t\t\t].\r\t\t(char = \'-\') ifTrue: [ \r\t\t\t"(stack size < 1) ifTrue: [ self error: \'empty stack\' ]."\r\t\t\t"(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ]."\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand1 - operand2.\r\t\t\t].\r\t\t(char = \'dup\') ifTrue: [ \r\t\t\tresult := stack top.\r\t\t\t].\r\t\t\r\t\tstack push: result.\r\t].\r\t\r\t^stack reversed asArray.',			#stamp : 'AndyMarks 12/18/2023 20:44',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| elements stack |\r\t\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [result := char asNumber].\r\t\t(char = \'+\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand1 + operand2.\r\t\t\t].\r\t\t(char = \'-\') ifTrue: [ \r\t\t\t"(stack size < 1) ifTrue: [ self error: \'empty stack\' ]."\r\t\t\t"(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ]."\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 - operand1.\r\t\t\t].\r\t\t(char = \'dup\') ifTrue: [ \r\t\t\tresult := stack top.\r\t\t\t].\r\t\t\r\t\tstack push: result.\r\t].\r\t\r\t^stack reversed asArray.',			#stamp : 'AndyMarks 12/18/2023 20:45',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T20:46:12.504209+11:00' ],		#prior : OmReference [ '618' ],		#self : OmReference [ '619' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| elements stack |\r\t\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [result := char asNumber].\r\t\t(char = \'+\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand1 + operand2.\r\t\t\t].\r\t\t(char = \'-\') ifTrue: [ \r\t\t\t"(stack size < 1) ifTrue: [ self error: \'empty stack\' ]."\r\t\t\t"(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ]."\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 - operand1.\r\t\t\t].\r\t\t(char = \'dup\') ifTrue: [ \r\t\t\tresult := stack top.\r\t\t\t].\r\t\t\r\t\tstack push: result.\r\t].\r\t\r\t^stack reversed asArray.',			#stamp : 'AndyMarks 12/18/2023 20:45',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| elements stack |\r\t\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [result := char asNumber].\r\t\t(char = \'+\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand1 + operand2.\r\t\t\t].\r\t\t(char = \'-\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t"(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ]."\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 - operand1.\r\t\t\t].\r\t\t(char = \'dup\') ifTrue: [ \r\t\t\tresult := stack top.\r\t\t\t].\r\t\t\r\t\tstack push: result.\r\t].\r\t\r\t^stack reversed asArray.',			#stamp : 'AndyMarks 12/18/2023 20:46',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T20:46:22.790322+11:00' ],		#prior : OmReference [ '619' ],		#self : OmReference [ '620' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| elements stack |\r\t\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [result := char asNumber].\r\t\t(char = \'+\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand1 + operand2.\r\t\t\t].\r\t\t(char = \'-\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t"(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ]."\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 - operand1.\r\t\t\t].\r\t\t(char = \'dup\') ifTrue: [ \r\t\t\tresult := stack top.\r\t\t\t].\r\t\t\r\t\tstack push: result.\r\t].\r\t\r\t^stack reversed asArray.',			#stamp : 'AndyMarks 12/18/2023 20:46',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| elements stack |\r\t\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [result := char asNumber].\r\t\t(char = \'+\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand1 + operand2.\r\t\t\t].\r\t\t(char = \'-\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 - operand1.\r\t\t\t].\r\t\t(char = \'dup\') ifTrue: [ \r\t\t\tresult := stack top.\r\t\t\t].\r\t\t\r\t\tstack push: result.\r\t].\r\t\r\t^stack reversed asArray.',			#stamp : 'AndyMarks 12/18/2023 20:46',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T20:47:29.259641+11:00' ],		#prior : OmReference [ '620' ],		#self : OmReference [ '621' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| elements stack |\r\t\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [result := char asNumber].\r\t\t(char = \'+\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand1 + operand2.\r\t\t\t].\r\t\t(char = \'-\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 - operand1.\r\t\t\t].\r\t\t(char = \'dup\') ifTrue: [ \r\t\t\tresult := stack top.\r\t\t\t].\r\t\t\r\t\tstack push: result.\r\t].\r\t\r\t^stack reversed asArray.',			#stamp : 'AndyMarks 12/18/2023 20:46',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| elements stack |\r\t\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [result := char asNumber].\r\t\t(char = \'+\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand1 + operand2.\r\t\t\t].\r\t\t(char = \'-\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 - operand1.\r\t\t\t].\r\t\t(char = \'*\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 * operand1.\r\t\t\t].\r\t\t(char = \'dup\') ifTrue: [ \r\t\t\tresult := stack top.\r\t\t\t].\r\t\t\r\t\tstack push: result.\r\t].\r\t\r\t^stack reversed asArray.',			#stamp : 'AndyMarks 12/18/2023 20:47',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T20:47:51.994476+11:00' ],		#prior : OmReference [ '621' ],		#self : OmReference [ '622' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| elements stack |\r\t\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [result := char asNumber].\r\t\t(char = \'+\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand1 + operand2.\r\t\t\t].\r\t\t(char = \'-\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 - operand1.\r\t\t\t].\r\t\t(char = \'*\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 * operand1.\r\t\t\t].\r\t\t(char = \'dup\') ifTrue: [ \r\t\t\tresult := stack top.\r\t\t\t].\r\t\t\r\t\tstack push: result.\r\t].\r\t\r\t^stack reversed asArray.',			#stamp : 'AndyMarks 12/18/2023 20:47',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| elements stack |\r\t\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [result := char asNumber].\r\t\t(char = \'+\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand1 + operand2.\r\t\t\t].\r\t\t(char = \'-\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 - operand1.\r\t\t\t].\r\t\t(char = \'*\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 * operand1.\r\t\t\t].\r\t\t(char = \'/\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 / operand1.\r\t\t\t].\r\t\t(char = \'dup\') ifTrue: [ \r\t\t\tresult := stack top.\r\t\t\t].\r\t\t\r\t\tstack push: result.\r\t].\r\t\r\t^stack reversed asArray.',			#stamp : 'AndyMarks 12/18/2023 20:47',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T20:49:29.030097+11:00' ],		#prior : OmReference [ '622' ],		#self : OmReference [ '623' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| elements stack |\r\t\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [result := char asNumber].\r\t\t(char = \'+\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand1 + operand2.\r\t\t\t].\r\t\t(char = \'-\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 - operand1.\r\t\t\t].\r\t\t(char = \'*\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 * operand1.\r\t\t\t].\r\t\t(char = \'/\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 / operand1.\r\t\t\t].\r\t\t(char = \'dup\') ifTrue: [ \r\t\t\tresult := stack top.\r\t\t\t].\r\t\t\r\t\tstack push: result.\r\t].\r\t\r\t^stack reversed asArray.',			#stamp : 'AndyMarks 12/18/2023 20:47',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| elements stack |\r\t\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [result := char asNumber].\r\t\t(char = \'+\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand1 + operand2.\r\t\t\t].\r\t\t(char = \'-\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 - operand1.\r\t\t\t].\r\t\t(char = \'*\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 * operand1.\r\t\t\t].\r\t\t(char = \'/\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 // operand1.\r\t\t\t].\r\t\t(char = \'dup\') ifTrue: [ \r\t\t\tresult := stack top.\r\t\t\t].\r\t\t\r\t\tstack push: result.\r\t].\r\t\r\t^stack reversed asArray.',			#stamp : 'AndyMarks 12/18/2023 20:49',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T20:50:14.505776+11:00' ],		#prior : OmReference [ '623' ],		#self : OmReference [ '624' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| elements stack |\r\t\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [result := char asNumber].\r\t\t(char = \'+\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand1 + operand2.\r\t\t\t].\r\t\t(char = \'-\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 - operand1.\r\t\t\t].\r\t\t(char = \'*\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 * operand1.\r\t\t\t].\r\t\t(char = \'/\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 // operand1.\r\t\t\t].\r\t\t(char = \'dup\') ifTrue: [ \r\t\t\tresult := stack top.\r\t\t\t].\r\t\t\r\t\tstack push: result.\r\t].\r\t\r\t^stack reversed asArray.',			#stamp : 'AndyMarks 12/18/2023 20:49',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| elements stack |\r\t\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [result := char asNumber].\r\t\t(char = \'+\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand1 + operand2.\r\t\t\t].\r\t\t(char = \'-\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 - operand1.\r\t\t\t].\r\t\t(char = \'*\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 * operand1.\r\t\t\t].\r\t\t(char = \'/\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\t(operand2 = 0) ifTrue: [ self error: \'divide by zero\' ].\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 // operand1.\r\t\t\t].\r\t\t(char = \'dup\') ifTrue: [ \r\t\t\tresult := stack top.\r\t\t\t].\r\t\t\r\t\tstack push: result.\r\t].\r\t\r\t^stack reversed asArray.',			#stamp : 'AndyMarks 12/18/2023 20:50',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T20:50:36.662796+11:00' ],		#prior : OmReference [ '624' ],		#self : OmReference [ '625' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| elements stack |\r\t\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [result := char asNumber].\r\t\t(char = \'+\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand1 + operand2.\r\t\t\t].\r\t\t(char = \'-\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 - operand1.\r\t\t\t].\r\t\t(char = \'*\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 * operand1.\r\t\t\t].\r\t\t(char = \'/\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\t(operand2 = 0) ifTrue: [ self error: \'divide by zero\' ].\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 // operand1.\r\t\t\t].\r\t\t(char = \'dup\') ifTrue: [ \r\t\t\tresult := stack top.\r\t\t\t].\r\t\t\r\t\tstack push: result.\r\t].\r\t\r\t^stack reversed asArray.',			#stamp : 'AndyMarks 12/18/2023 20:50',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| elements stack |\r\t\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [result := char asNumber].\r\t\t(char = \'+\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand1 + operand2.\r\t\t\t].\r\t\t(char = \'-\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 - operand1.\r\t\t\t].\r\t\t(char = \'*\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 * operand1.\r\t\t\t].\r\t\t(char = \'/\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\t(operand1 = 0) ifTrue: [ self error: \'divide by zero\' ].\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 // operand1.\r\t\t\t].\r\t\t(char = \'dup\') ifTrue: [ \r\t\t\tresult := stack top.\r\t\t\t].\r\t\t\r\t\tstack push: result.\r\t].\r\t\r\t^stack reversed asArray.',			#stamp : 'AndyMarks 12/18/2023 20:50',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T20:52:31.974003+11:00' ],		#prior : OmReference [ '625' ],		#self : OmReference [ '626' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| elements stack |\r\t\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [result := char asNumber].\r\t\t(char = \'+\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand1 + operand2.\r\t\t\t].\r\t\t(char = \'-\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 - operand1.\r\t\t\t].\r\t\t(char = \'*\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 * operand1.\r\t\t\t].\r\t\t(char = \'/\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\t(operand1 = 0) ifTrue: [ self error: \'divide by zero\' ].\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 // operand1.\r\t\t\t].\r\t\t(char = \'dup\') ifTrue: [ \r\t\t\tresult := stack top.\r\t\t\t].\r\t\t\r\t\tstack push: result.\r\t].\r\t\r\t^stack reversed asArray.',			#stamp : 'AndyMarks 12/18/2023 20:50',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| elements stack |\r\t\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [result := char asNumber].\r\t\t(char = \'+\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand1 + operand2.\r\t\t\t].\r\t\t(char = \'-\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 - operand1.\r\t\t\t].\r\t\t(char = \'*\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 * operand1.\r\t\t\t].\r\t\t(char = \'/\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\t(operand1 = 0) ifTrue: [ self error: \'divide by zero\' ].\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 // operand1.\r\t\t\t].\r\t\t(char = \'dup\') ifTrue: [ \r\t\t\tresult := stack top.\r\t\t\t].\r\t\t(char = \'drop\') ifTrue: [ \r\t\t\tstack pop.\r\t\t\t].\r\t\t\r\t\tstack push: result.\r\t].\r\t\r\t^stack reversed asArray.',			#stamp : 'AndyMarks 12/18/2023 20:52',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T20:52:48.522024+11:00' ],		#prior : OmReference [ '626' ],		#self : OmReference [ '627' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| elements stack |\r\t\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [result := char asNumber].\r\t\t(char = \'+\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand1 + operand2.\r\t\t\t].\r\t\t(char = \'-\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 - operand1.\r\t\t\t].\r\t\t(char = \'*\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 * operand1.\r\t\t\t].\r\t\t(char = \'/\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\t(operand1 = 0) ifTrue: [ self error: \'divide by zero\' ].\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 // operand1.\r\t\t\t].\r\t\t(char = \'dup\') ifTrue: [ \r\t\t\tresult := stack top.\r\t\t\t].\r\t\t(char = \'drop\') ifTrue: [ \r\t\t\tstack pop.\r\t\t\t].\r\t\t\r\t\tstack push: result.\r\t].\r\t\r\t^stack reversed asArray.',			#stamp : 'AndyMarks 12/18/2023 20:52',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| elements stack |\r\t\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [result := char asNumber].\r\t\t(char = \'+\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand1 + operand2.\r\t\t\t].\r\t\t(char = \'-\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 - operand1.\r\t\t\t].\r\t\t(char = \'*\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 * operand1.\r\t\t\t].\r\t\t(char = \'/\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\t(operand1 = 0) ifTrue: [ self error: \'divide by zero\' ].\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 // operand1.\r\t\t\t].\r\t\t(char = \'dup\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\tresult := stack top.\r\t\t\t].\r\t\t(char = \'drop\') ifTrue: [ \r\t\t\tstack pop.\r\t\t\t].\r\t\t\r\t\tstack push: result.\r\t].\r\t\r\t^stack reversed asArray.',			#stamp : 'AndyMarks 12/18/2023 20:52',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T20:54:09.489647+11:00' ],		#prior : OmReference [ '627' ],		#self : OmReference [ '628' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| elements stack |\r\t\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [result := char asNumber].\r\t\t(char = \'+\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand1 + operand2.\r\t\t\t].\r\t\t(char = \'-\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 - operand1.\r\t\t\t].\r\t\t(char = \'*\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 * operand1.\r\t\t\t].\r\t\t(char = \'/\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\t(operand1 = 0) ifTrue: [ self error: \'divide by zero\' ].\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 // operand1.\r\t\t\t].\r\t\t(char = \'dup\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\tresult := stack top.\r\t\t\t].\r\t\t(char = \'drop\') ifTrue: [ \r\t\t\tstack pop.\r\t\t\t].\r\t\t\r\t\tstack push: result.\r\t].\r\t\r\t^stack reversed asArray.',			#stamp : 'AndyMarks 12/18/2023 20:52',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| elements stack |\r\t\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [result := char asNumber].\r\t\t(char = \'+\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand1 + operand2.\r\t\t\t].\r\t\t(char = \'-\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 - operand1.\r\t\t\t].\r\t\t(char = \'*\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 * operand1.\r\t\t\t].\r\t\t(char = \'/\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\t(operand1 = 0) ifTrue: [ self error: \'divide by zero\' ].\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 // operand1.\r\t\t\t].\r\t\t(char = \'dup\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\tresult := stack top.\r\t\t\t].\r\t\t(char = \'drop\') ifTrue: [ \r\t\t\tstack pop.\r\t\t\t].\r\t\t\r\t\tresult not isNil: [ stack push: result ].\r\t].\r\t\r\t^stack reversed asArray.',			#stamp : 'AndyMarks 12/18/2023 20:54',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T20:54:50.88921+11:00' ],		#prior : OmReference [ '628' ],		#self : OmReference [ '629' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| elements stack |\r\t\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [result := char asNumber].\r\t\t(char = \'+\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand1 + operand2.\r\t\t\t].\r\t\t(char = \'-\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 - operand1.\r\t\t\t].\r\t\t(char = \'*\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 * operand1.\r\t\t\t].\r\t\t(char = \'/\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\t(operand1 = 0) ifTrue: [ self error: \'divide by zero\' ].\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 // operand1.\r\t\t\t].\r\t\t(char = \'dup\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\tresult := stack top.\r\t\t\t].\r\t\t(char = \'drop\') ifTrue: [ \r\t\t\tstack pop.\r\t\t\t].\r\t\t\r\t\tresult not isNil: [ stack push: result ].\r\t].\r\t\r\t^stack reversed asArray.',			#stamp : 'AndyMarks 12/18/2023 20:54',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| elements stack |\r\t\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [result := char asNumber].\r\t\t(char = \'+\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand1 + operand2.\r\t\t\t].\r\t\t(char = \'-\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 - operand1.\r\t\t\t].\r\t\t(char = \'*\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 * operand1.\r\t\t\t].\r\t\t(char = \'/\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\t(operand1 = 0) ifTrue: [ self error: \'divide by zero\' ].\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 // operand1.\r\t\t\t].\r\t\t(char = \'dup\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\tresult := stack top.\r\t\t\t].\r\t\t(char = \'drop\') ifTrue: [ \r\t\t\tstack pop.\r\t\t\t].\r\t\t\r\t\tresult isNil ifFalse: [ stack push: result ].\r\t].\r\t\r\t^stack reversed asArray.',			#stamp : 'AndyMarks 12/18/2023 20:54',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T20:55:08.176496+11:00' ],		#prior : OmReference [ '629' ],		#self : OmReference [ '630' ]	},	#content : EpCompositeRefactoring {		#childrenRefactorings : [ ]	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '630' ],		#self : OmReference [ '631' ],		#time : DateAndTime [ '2023-12-18T20:55:08.214556+11:00' ],		#trigger : @3	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| elements stack |\r\t\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\t\r\telements splitOn: (Character space) do: [ :char |\r\t\r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [result := char asNumber].\r\t\t(char = \'+\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand1 + operand2.\r\t\t\t].\r\t\t(char = \'-\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 - operand1.\r\t\t\t].\r\t\t(char = \'*\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 * operand1.\r\t\t\t].\r\t\t(char = \'/\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\t(stack size < 2) ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\t(operand1 = 0) ifTrue: [ self error: \'divide by zero\' ].\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 // operand1.\r\t\t\t].\r\t\t(char = \'dup\') ifTrue: [ \r\t\t\t(stack size < 1) ifTrue: [ self error: \'empty stack\' ].\r\t\t\tresult := stack top.\r\t\t\t].\r\t\t(char = \'drop\') ifTrue: [ \r\t\t\tstack pop.\r\t\t\t].\r\t\t\r\t\tresult isNil ifFalse: [ stack push: result ].\r\t].\r\t\r\t^stack reversed asArray.',			#stamp : 'AndyMarks 12/18/2023 20:54',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\r\t"comment stating purpose of instance-side method"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| elements stack |\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\r\telements splitOn: Character space do: [ :char | \r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [ result := char asNumber ].\r\t\tchar = \'+\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand1 + operand2 ].\r\t\tchar = \'-\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 - operand1 ].\r\t\tchar = \'*\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 * operand1 ].\r\t\tchar = \'/\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand1 = 0 ifTrue: [ self error: \'divide by zero\' ].\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 // operand1 ].\r\t\tchar = \'dup\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tresult := stack top ].\r\t\tchar = \'drop\' ifTrue: [ stack pop ].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^ stack reversed asArray',			#stamp : 'AndyMarks 12/18/2023 20:55',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T20:55:43.094943+11:00' ],		#prior : OmReference [ '631' ],		#self : OmReference [ '632' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\r\t"comment stating purpose of instance-side method"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| elements stack |\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\r\telements splitOn: Character space do: [ :char | \r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [ result := char asNumber ].\r\t\tchar = \'+\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand1 + operand2 ].\r\t\tchar = \'-\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 - operand1 ].\r\t\tchar = \'*\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 * operand1 ].\r\t\tchar = \'/\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand1 = 0 ifTrue: [ self error: \'divide by zero\' ].\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 // operand1 ].\r\t\tchar = \'dup\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tresult := stack top ].\r\t\tchar = \'drop\' ifTrue: [ stack pop ].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^ stack reversed asArray',			#stamp : 'AndyMarks 12/18/2023 20:55',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\r\t"comment stating purpose of instance-side method"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| elements stack |\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\r\telements splitOn: Character space do: [ :char | \r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [ result := char asNumber ].\r\t\tchar = \'+\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand1 + operand2 ].\r\t\tchar = \'-\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 - operand1 ].\r\t\tchar = \'*\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 * operand1 ].\r\t\tchar = \'/\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand1 = 0 ifTrue: [ self error: \'divide by zero\' ].\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 // operand1 ].\r\t\tchar = \'dup\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tresult := stack top ].\r\t\tchar = \'drop\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack pop \r\t\t\t].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^ stack reversed asArray',			#stamp : 'AndyMarks 12/18/2023 20:55',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T20:57:47.380963+11:00' ],		#prior : OmReference [ '632' ],		#self : OmReference [ '633' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\r\t"comment stating purpose of instance-side method"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| elements stack |\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\r\telements splitOn: Character space do: [ :char | \r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [ result := char asNumber ].\r\t\tchar = \'+\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand1 + operand2 ].\r\t\tchar = \'-\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 - operand1 ].\r\t\tchar = \'*\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 * operand1 ].\r\t\tchar = \'/\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand1 = 0 ifTrue: [ self error: \'divide by zero\' ].\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 // operand1 ].\r\t\tchar = \'dup\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tresult := stack top ].\r\t\tchar = \'drop\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack pop \r\t\t\t].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^ stack reversed asArray',			#stamp : 'AndyMarks 12/18/2023 20:55',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\r\t"comment stating purpose of instance-side method"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| elements stack |\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\r\telements splitOn: Character space do: [ :char | \r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [ result := char asNumber ].\r\t\tchar = \'+\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand1 + operand2 ].\r\t\tchar = \'-\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 - operand1 ].\r\t\tchar = \'*\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 * operand1 ].\r\t\tchar = \'/\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand1 = 0 ifTrue: [ self error: \'divide by zero\' ].\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 // operand1 ].\r\t\tchar = \'dup\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tresult := stack top ].\r\t\tchar = \'drop\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack pop \r\t\t\t].\r\t\tchar = \'swap\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tstack push: operand1.\r\t\t\tresult := operand2.\r\t\t\t].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^ stack reversed asArray',			#stamp : 'AndyMarks 12/18/2023 20:57',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T21:00:59.74583+11:00' ],		#prior : OmReference [ '633' ],		#self : OmReference [ '634' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'add:',			#protocol : #'as yet unclassified',			#sourceCode : 'add: aStack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| operand1 operand2 |\t\t\t\r\taStack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\taStack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\toperand1 := aStack pop.\r\toperand2 := aStack pop.\r\r\t^operand1 + operand2.\r',			#stamp : 'AndyMarks 12/18/2023 21:00',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T21:00:59.752187+11:00' ],		#prior : OmReference [ '634' ],		#self : OmReference [ '635' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'add:',			#protocol : #'as yet unclassified',			#sourceCode : 'add: aStack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| operand1 operand2 |\t\t\t\r\taStack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\taStack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\toperand1 := aStack pop.\r\toperand2 := aStack pop.\r\r\t^operand1 + operand2.\r',			#stamp : 'AndyMarks 12/18/2023 21:00',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'add:',			#protocol : #adding,			#sourceCode : 'add: aStack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| operand1 operand2 |\t\t\t\r\taStack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\taStack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\toperand1 := aStack pop.\r\toperand2 := aStack pop.\r\r\t^operand1 + operand2.\r',			#stamp : 'AndyMarks 12/18/2023 21:00',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T21:01:58.472327+11:00' ],		#prior : OmReference [ '635' ],		#self : OmReference [ '636' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\r\t"comment stating purpose of instance-side method"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| elements stack |\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\r\telements splitOn: Character space do: [ :char | \r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [ result := char asNumber ].\r\t\tchar = \'+\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand1 + operand2 ].\r\t\tchar = \'-\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 - operand1 ].\r\t\tchar = \'*\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 * operand1 ].\r\t\tchar = \'/\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand1 = 0 ifTrue: [ self error: \'divide by zero\' ].\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 // operand1 ].\r\t\tchar = \'dup\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tresult := stack top ].\r\t\tchar = \'drop\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack pop \r\t\t\t].\r\t\tchar = \'swap\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tstack push: operand1.\r\t\t\tresult := operand2.\r\t\t\t].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^ stack reversed asArray',			#stamp : 'AndyMarks 12/18/2023 20:57',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\r\t"comment stating purpose of instance-side method"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| elements stack |\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\r\telements splitOn: Character space do: [ :char | \r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [ result := char asNumber ].\r\t\tchar = \'+\' ifTrue: [ \r\t\t\tresult := self add: stack.\r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand1 + operand2 ].\r\t\tchar = \'-\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 - operand1 ].\r\t\tchar = \'*\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 * operand1 ].\r\t\tchar = \'/\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand1 = 0 ifTrue: [ self error: \'divide by zero\' ].\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 // operand1 ].\r\t\tchar = \'dup\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tresult := stack top ].\r\t\tchar = \'drop\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack pop \r\t\t\t].\r\t\tchar = \'swap\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tstack push: operand1.\r\t\t\tresult := operand2.\r\t\t\t].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^ stack reversed asArray',			#stamp : 'AndyMarks 12/18/2023 21:01',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T21:03:29.244169+11:00' ],		#prior : OmReference [ '636' ],		#self : OmReference [ '637' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\r\t"comment stating purpose of instance-side method"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| elements stack |\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\r\telements splitOn: Character space do: [ :char | \r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [ result := char asNumber ].\r\t\tchar = \'+\' ifTrue: [ \r\t\t\tresult := self add: stack.\r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand1 + operand2 ].\r\t\tchar = \'-\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 - operand1 ].\r\t\tchar = \'*\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 * operand1 ].\r\t\tchar = \'/\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand1 = 0 ifTrue: [ self error: \'divide by zero\' ].\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 // operand1 ].\r\t\tchar = \'dup\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tresult := stack top ].\r\t\tchar = \'drop\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack pop \r\t\t\t].\r\t\tchar = \'swap\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tstack push: operand1.\r\t\t\tresult := operand2.\r\t\t\t].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^ stack reversed asArray',			#stamp : 'AndyMarks 12/18/2023 21:01',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\r\t"comment stating purpose of instance-side method"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| elements stack |\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\r\telements splitOn: Character space do: [ :char | \r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [ result := char asNumber ].\r\t\tchar = \'+\' ifTrue: [ \r\t\t\tresult := self add: stack.].\r\t\tchar = \'-\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 - operand1 ].\r\t\tchar = \'*\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 * operand1 ].\r\t\tchar = \'/\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand1 = 0 ifTrue: [ self error: \'divide by zero\' ].\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 // operand1 ].\r\t\tchar = \'dup\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tresult := stack top ].\r\t\tchar = \'drop\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack pop \r\t\t\t].\r\t\tchar = \'swap\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tstack push: operand1.\r\t\t\tresult := operand2.\r\t\t\t].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^ stack reversed asArray',			#stamp : 'AndyMarks 12/18/2023 21:03',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T21:04:17.60207+11:00' ],		#prior : OmReference [ '637' ],		#self : OmReference [ '638' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'subtract:',			#protocol : #'as yet unclassified',			#sourceCode : 'subtract: aStack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| operand1 operand2 |\t\t\t\r\taStack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\taStack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\toperand1 := aStack pop.\r\toperand2 := aStack pop.\r\r\t^operand1 + operand2.\r',			#stamp : 'AndyMarks 12/18/2023 21:04',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T21:04:35.889846+11:00' ],		#prior : OmReference [ '638' ],		#self : OmReference [ '639' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\r\t"comment stating purpose of instance-side method"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| elements stack |\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\r\telements splitOn: Character space do: [ :char | \r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [ result := char asNumber ].\r\t\tchar = \'+\' ifTrue: [ \r\t\t\tresult := self add: stack.].\r\t\tchar = \'-\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 - operand1 ].\r\t\tchar = \'*\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 * operand1 ].\r\t\tchar = \'/\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand1 = 0 ifTrue: [ self error: \'divide by zero\' ].\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 // operand1 ].\r\t\tchar = \'dup\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tresult := stack top ].\r\t\tchar = \'drop\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack pop \r\t\t\t].\r\t\tchar = \'swap\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tstack push: operand1.\r\t\t\tresult := operand2.\r\t\t\t].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^ stack reversed asArray',			#stamp : 'AndyMarks 12/18/2023 21:03',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\r\t"comment stating purpose of instance-side method"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| elements stack |\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\r\telements splitOn: Character space do: [ :char | \r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [ result := char asNumber ].\r\t\tchar = \'+\' ifTrue: [ \r\t\t\tresult := self add: stack].\r\t\tchar = \'-\' ifTrue: [ \r\t\t\tresult := self subtrack: stack].\r\t\tchar = \'*\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 * operand1 ].\r\t\tchar = \'/\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand1 = 0 ifTrue: [ self error: \'divide by zero\' ].\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 // operand1 ].\r\t\tchar = \'dup\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tresult := stack top ].\r\t\tchar = \'drop\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack pop \r\t\t\t].\r\t\tchar = \'swap\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tstack push: operand1.\r\t\t\tresult := operand2.\r\t\t\t].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^ stack reversed asArray',			#stamp : 'AndyMarks 12/18/2023 21:04',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T21:04:41.379066+11:00' ],		#prior : OmReference [ '639' ],		#self : OmReference [ '640' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\r\t"comment stating purpose of instance-side method"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| elements stack |\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\r\telements splitOn: Character space do: [ :char | \r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [ result := char asNumber ].\r\t\tchar = \'+\' ifTrue: [ \r\t\t\tresult := self add: stack].\r\t\tchar = \'-\' ifTrue: [ \r\t\t\tresult := self subtrack: stack].\r\t\tchar = \'*\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 * operand1 ].\r\t\tchar = \'/\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand1 = 0 ifTrue: [ self error: \'divide by zero\' ].\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 // operand1 ].\r\t\tchar = \'dup\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tresult := stack top ].\r\t\tchar = \'drop\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack pop \r\t\t\t].\r\t\tchar = \'swap\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tstack push: operand1.\r\t\t\tresult := operand2.\r\t\t\t].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^ stack reversed asArray',			#stamp : 'AndyMarks 12/18/2023 21:04',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\r\t"comment stating purpose of instance-side method"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| elements stack |\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\r\telements splitOn: Character space do: [ :char | \r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [ result := char asNumber ].\r\t\tchar = \'+\' ifTrue: [ \r\t\t\tresult := self add: stack].\r\t\tchar = \'-\' ifTrue: [ \r\t\t\tresult := self subtract: stack].\r\t\tchar = \'*\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 * operand1 ].\r\t\tchar = \'/\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand1 = 0 ifTrue: [ self error: \'divide by zero\' ].\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 // operand1 ].\r\t\tchar = \'dup\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tresult := stack top ].\r\t\tchar = \'drop\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack pop \r\t\t\t].\r\t\tchar = \'swap\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tstack push: operand1.\r\t\t\tresult := operand2.\r\t\t\t].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^ stack reversed asArray',			#stamp : 'AndyMarks 12/18/2023 21:04',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T21:05:12.768389+11:00' ],		#prior : OmReference [ '640' ],		#self : OmReference [ '641' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'subtract:',			#protocol : #'as yet unclassified',			#sourceCode : 'subtract: aStack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| operand1 operand2 |\t\t\t\r\taStack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\taStack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\toperand1 := aStack pop.\r\toperand2 := aStack pop.\r\r\t^operand1 + operand2.\r',			#stamp : 'AndyMarks 12/18/2023 21:04',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'subtract:',			#protocol : #'as yet unclassified',			#sourceCode : 'subtract: aStack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| operand1 operand2 |\t\t\t\r\taStack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\taStack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\toperand1 := aStack pop.\r\toperand2 := aStack pop.\r\r\t^operand2 - operand1.\r',			#stamp : 'AndyMarks 12/18/2023 21:05',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T21:06:05.081+11:00' ],		#prior : OmReference [ '641' ],		#self : OmReference [ '642' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'divide:',			#protocol : #'as yet unclassified',			#sourceCode : 'divide: aStack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| operand1 operand2 |\t\t\t\r\taStack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\taStack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\toperand1 := aStack pop.\r\toperand2 := aStack pop.\r\r\t^operand2 // operand1.\r',			#stamp : 'AndyMarks 12/18/2023 21:06',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T21:06:12.906124+11:00' ],		#prior : OmReference [ '642' ],		#self : OmReference [ '643' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\r\t"comment stating purpose of instance-side method"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| elements stack |\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\r\telements splitOn: Character space do: [ :char | \r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [ result := char asNumber ].\r\t\tchar = \'+\' ifTrue: [ \r\t\t\tresult := self add: stack].\r\t\tchar = \'-\' ifTrue: [ \r\t\t\tresult := self subtract: stack].\r\t\tchar = \'*\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 * operand1 ].\r\t\tchar = \'/\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand1 = 0 ifTrue: [ self error: \'divide by zero\' ].\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 // operand1 ].\r\t\tchar = \'dup\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tresult := stack top ].\r\t\tchar = \'drop\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack pop \r\t\t\t].\r\t\tchar = \'swap\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tstack push: operand1.\r\t\t\tresult := operand2.\r\t\t\t].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^ stack reversed asArray',			#stamp : 'AndyMarks 12/18/2023 21:04',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\r\t"comment stating purpose of instance-side method"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| elements stack |\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\r\telements splitOn: Character space do: [ :char | \r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [ result := char asNumber ].\r\t\tchar = \'+\' ifTrue: [ \r\t\t\tresult := self add: stack].\r\t\tchar = \'-\' ifTrue: [ \r\t\t\tresult := self subtract: stack].\r\t\tchar = \'*\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 * operand1 ].\r\t\tchar = \'/\' ifTrue: [ \r\t\t\tresult := self divide: stack].\r\t\tchar = \'dup\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tresult := stack top ].\r\t\tchar = \'drop\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack pop \r\t\t\t].\r\t\tchar = \'swap\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tstack push: operand1.\r\t\t\tresult := operand2.\r\t\t\t].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^ stack reversed asArray',			#stamp : 'AndyMarks 12/18/2023 21:06',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T21:06:48.503382+11:00' ],		#prior : OmReference [ '643' ],		#self : OmReference [ '644' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'divide:',			#protocol : #'as yet unclassified',			#sourceCode : 'divide: aStack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| operand1 operand2 |\t\t\t\r\taStack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\taStack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\toperand1 := aStack pop.\r\toperand2 := aStack pop.\r\r\t^operand2 // operand1.\r',			#stamp : 'AndyMarks 12/18/2023 21:06',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'divide:',			#protocol : #'as yet unclassified',			#sourceCode : 'divide: aStack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| operand1 operand2 |\t\t\t\r\taStack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\taStack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\toperand1 := aStack pop.\r\toperand1 = 0 ifTrue: [ self error: \'divide by zero\' ].\r\toperand2 := aStack pop.\r\r\t^operand2 // operand1.\r',			#stamp : 'AndyMarks 12/18/2023 21:06',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T21:07:42.900794+11:00' ],		#prior : OmReference [ '644' ],		#self : OmReference [ '645' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'multiply:',			#protocol : #'as yet unclassified',			#sourceCode : 'multiply: aStack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| operand1 operand2 |\t\t\t\r\taStack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\taStack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\toperand1 := aStack pop.\r\toperand2 := aStack pop.\r\r\t^operand2 * operand1.\r',			#stamp : 'AndyMarks 12/18/2023 21:07',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T21:07:57.499997+11:00' ],		#prior : OmReference [ '645' ],		#self : OmReference [ '646' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\r\t"comment stating purpose of instance-side method"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| elements stack |\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\r\telements splitOn: Character space do: [ :char | \r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [ result := char asNumber ].\r\t\tchar = \'+\' ifTrue: [ \r\t\t\tresult := self add: stack].\r\t\tchar = \'-\' ifTrue: [ \r\t\t\tresult := self subtract: stack].\r\t\tchar = \'*\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tresult := operand2 * operand1 ].\r\t\tchar = \'/\' ifTrue: [ \r\t\t\tresult := self divide: stack].\r\t\tchar = \'dup\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tresult := stack top ].\r\t\tchar = \'drop\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack pop \r\t\t\t].\r\t\tchar = \'swap\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tstack push: operand1.\r\t\t\tresult := operand2.\r\t\t\t].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^ stack reversed asArray',			#stamp : 'AndyMarks 12/18/2023 21:06',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\r\t"comment stating purpose of instance-side method"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| elements stack |\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\r\telements splitOn: Character space do: [ :char | \r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [ result := char asNumber ].\r\t\tchar = \'+\' ifTrue: [ \r\t\t\tresult := self add: stack].\r\t\tchar = \'-\' ifTrue: [ \r\t\t\tresult := self subtract: stack].\r\t\tchar = \'*\' ifTrue: [ \r\t\t\tresult := self multiply: stack].\r\t\tchar = \'/\' ifTrue: [ \r\t\t\tresult := self divide: stack].\r\t\tchar = \'dup\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tresult := stack top ].\r\t\tchar = \'drop\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack pop \r\t\t\t].\r\t\tchar = \'swap\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tstack push: operand1.\r\t\t\tresult := operand2.\r\t\t\t].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^ stack reversed asArray',			#stamp : 'AndyMarks 12/18/2023 21:07',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T21:09:46.414075+11:00' ],		#prior : OmReference [ '646' ],		#self : OmReference [ '647' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'dup:',			#protocol : #'as yet unclassified',			#sourceCode : 'dup: aStack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\taStack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\r\t^aStack top.\r',			#stamp : 'AndyMarks 12/18/2023 21:09',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T21:10:01.064948+11:00' ],		#prior : OmReference [ '647' ],		#self : OmReference [ '648' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\r\t"comment stating purpose of instance-side method"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| elements stack |\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\r\telements splitOn: Character space do: [ :char | \r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [ result := char asNumber ].\r\t\tchar = \'+\' ifTrue: [ \r\t\t\tresult := self add: stack].\r\t\tchar = \'-\' ifTrue: [ \r\t\t\tresult := self subtract: stack].\r\t\tchar = \'*\' ifTrue: [ \r\t\t\tresult := self multiply: stack].\r\t\tchar = \'/\' ifTrue: [ \r\t\t\tresult := self divide: stack].\r\t\tchar = \'dup\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tresult := stack top ].\r\t\tchar = \'drop\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack pop \r\t\t\t].\r\t\tchar = \'swap\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tstack push: operand1.\r\t\t\tresult := operand2.\r\t\t\t].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^ stack reversed asArray',			#stamp : 'AndyMarks 12/18/2023 21:07',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\r\t"comment stating purpose of instance-side method"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| elements stack |\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\r\telements splitOn: Character space do: [ :char | \r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [ result := char asNumber ].\r\t\tchar = \'+\' ifTrue: [ \r\t\t\tresult := self add: stack].\r\t\tchar = \'-\' ifTrue: [ \r\t\t\tresult := self subtract: stack].\r\t\tchar = \'*\' ifTrue: [ \r\t\t\tresult := self multiply: stack].\r\t\tchar = \'/\' ifTrue: [ \r\t\t\tresult := self divide: stack].\r\t\tchar = \'dup\' ifTrue: [ \r\t\t\tresult := self dup: stack].\r\t\tchar = \'drop\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack pop \r\t\t\t].\r\t\tchar = \'swap\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tstack push: operand1.\r\t\t\tresult := operand2.\r\t\t\t].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^ stack reversed asArray',			#stamp : 'AndyMarks 12/18/2023 21:10',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T21:10:49.516003+11:00' ],		#prior : OmReference [ '648' ],		#self : OmReference [ '649' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'drop:',			#protocol : #'as yet unclassified',			#sourceCode : 'drop: aStack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\taStack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\taStack pop.\r',			#stamp : 'AndyMarks 12/18/2023 21:10',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T21:11:03.440429+11:00' ],		#prior : OmReference [ '649' ],		#self : OmReference [ '650' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\r\t"comment stating purpose of instance-side method"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| elements stack |\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\r\telements splitOn: Character space do: [ :char | \r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [ result := char asNumber ].\r\t\tchar = \'+\' ifTrue: [ \r\t\t\tresult := self add: stack].\r\t\tchar = \'-\' ifTrue: [ \r\t\t\tresult := self subtract: stack].\r\t\tchar = \'*\' ifTrue: [ \r\t\t\tresult := self multiply: stack].\r\t\tchar = \'/\' ifTrue: [ \r\t\t\tresult := self divide: stack].\r\t\tchar = \'dup\' ifTrue: [ \r\t\t\tresult := self dup: stack].\r\t\tchar = \'drop\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack pop \r\t\t\t].\r\t\tchar = \'swap\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tstack push: operand1.\r\t\t\tresult := operand2.\r\t\t\t].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^ stack reversed asArray',			#stamp : 'AndyMarks 12/18/2023 21:10',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\r\t"comment stating purpose of instance-side method"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| elements stack |\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\r\telements splitOn: Character space do: [ :char | \r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [ result := char asNumber ].\r\t\tchar = \'+\' ifTrue: [ \r\t\t\tresult := self add: stack].\r\t\tchar = \'-\' ifTrue: [ \r\t\t\tresult := self subtract: stack].\r\t\tchar = \'*\' ifTrue: [ \r\t\t\tresult := self multiply: stack].\r\t\tchar = \'/\' ifTrue: [ \r\t\t\tresult := self divide: stack].\r\t\tchar = \'dup\' ifTrue: [ \r\t\t\tresult := self dup: stack].\r\t\tchar = \'drop\' ifTrue: [ \r\t\t\tself drop: stack.\r\t\t\t].\r\t\tchar = \'swap\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tstack push: operand1.\r\t\t\tresult := operand2.\r\t\t\t].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^ stack reversed asArray',			#stamp : 'AndyMarks 12/18/2023 21:11',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T21:11:11.713511+11:00' ],		#prior : OmReference [ '650' ],		#self : OmReference [ '651' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\r\t"comment stating purpose of instance-side method"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| elements stack |\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\r\telements splitOn: Character space do: [ :char | \r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [ result := char asNumber ].\r\t\tchar = \'+\' ifTrue: [ \r\t\t\tresult := self add: stack].\r\t\tchar = \'-\' ifTrue: [ \r\t\t\tresult := self subtract: stack].\r\t\tchar = \'*\' ifTrue: [ \r\t\t\tresult := self multiply: stack].\r\t\tchar = \'/\' ifTrue: [ \r\t\t\tresult := self divide: stack].\r\t\tchar = \'dup\' ifTrue: [ \r\t\t\tresult := self dup: stack].\r\t\tchar = \'drop\' ifTrue: [ \r\t\t\tself drop: stack.\r\t\t\t].\r\t\tchar = \'swap\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tstack push: operand1.\r\t\t\tresult := operand2.\r\t\t\t].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^ stack reversed asArray',			#stamp : 'AndyMarks 12/18/2023 21:11',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\r\t"comment stating purpose of instance-side method"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| elements stack |\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\r\telements splitOn: Character space do: [ :char | \r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [ result := char asNumber ].\r\t\tchar = \'+\' ifTrue: [ \r\t\t\tresult := self add: stack].\r\t\tchar = \'-\' ifTrue: [ \r\t\t\tresult := self subtract: stack].\r\t\tchar = \'*\' ifTrue: [ \r\t\t\tresult := self multiply: stack].\r\t\tchar = \'/\' ifTrue: [ \r\t\t\tresult := self divide: stack].\r\t\tchar = \'dup\' ifTrue: [ \r\t\t\tresult := self dup: stack].\r\t\tchar = \'drop\' ifTrue: [ \r\t\t\tself drop: stack].\r\t\tchar = \'swap\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tstack push: operand1.\r\t\t\tresult := operand2.\r\t\t\t].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^ stack reversed asArray',			#stamp : 'AndyMarks 12/18/2023 21:11',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T21:12:16.390943+11:00' ],		#prior : OmReference [ '651' ],		#self : OmReference [ '652' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'swap:',			#protocol : #'as yet unclassified',			#sourceCode : 'swap: aStack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| operand1 operand2 |\r\taStack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\taStack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\toperand1 := aStack pop.\r\toperand2 := aStack pop.\r\taStack push: operand1.\r\r\t^operand2.\r',			#stamp : 'AndyMarks 12/18/2023 21:12',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T21:12:34.137293+11:00' ],		#prior : OmReference [ '652' ],		#self : OmReference [ '653' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\r\t"comment stating purpose of instance-side method"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| elements stack |\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\r\telements splitOn: Character space do: [ :char | \r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [ result := char asNumber ].\r\t\tchar = \'+\' ifTrue: [ \r\t\t\tresult := self add: stack].\r\t\tchar = \'-\' ifTrue: [ \r\t\t\tresult := self subtract: stack].\r\t\tchar = \'*\' ifTrue: [ \r\t\t\tresult := self multiply: stack].\r\t\tchar = \'/\' ifTrue: [ \r\t\t\tresult := self divide: stack].\r\t\tchar = \'dup\' ifTrue: [ \r\t\t\tresult := self dup: stack].\r\t\tchar = \'drop\' ifTrue: [ \r\t\t\tself drop: stack].\r\t\tchar = \'swap\' ifTrue: [ \r\t\t\tstack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\t\t\tstack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\t\t\toperand1 := stack pop.\r\t\t\toperand2 := stack pop.\r\t\t\tstack push: operand1.\r\t\t\tresult := operand2.\r\t\t\t].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^ stack reversed asArray',			#stamp : 'AndyMarks 12/18/2023 21:11',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\r\t"comment stating purpose of instance-side method"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| elements stack |\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\r\telements splitOn: Character space do: [ :char | \r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [ result := char asNumber ].\r\t\tchar = \'+\' ifTrue: [ \r\t\t\tresult := self add: stack].\r\t\tchar = \'-\' ifTrue: [ \r\t\t\tresult := self subtract: stack].\r\t\tchar = \'*\' ifTrue: [ \r\t\t\tresult := self multiply: stack].\r\t\tchar = \'/\' ifTrue: [ \r\t\t\tresult := self divide: stack].\r\t\tchar = \'dup\' ifTrue: [ \r\t\t\tresult := self dup: stack].\r\t\tchar = \'drop\' ifTrue: [ \r\t\t\tself drop: stack].\r\t\tchar = \'swap\' ifTrue: [ \r\t\t\tresult := self swap: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^ stack reversed asArray',			#stamp : 'AndyMarks 12/18/2023 21:12',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T21:12:40.418364+11:00' ],		#prior : OmReference [ '653' ],		#self : OmReference [ '654' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\r\t"comment stating purpose of instance-side method"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| elements stack |\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\r\telements splitOn: Character space do: [ :char | \r\t\t| operand1 operand2 result |\r\t\t(NumberParser isNumber: char) ifTrue: [ result := char asNumber ].\r\t\tchar = \'+\' ifTrue: [ \r\t\t\tresult := self add: stack].\r\t\tchar = \'-\' ifTrue: [ \r\t\t\tresult := self subtract: stack].\r\t\tchar = \'*\' ifTrue: [ \r\t\t\tresult := self multiply: stack].\r\t\tchar = \'/\' ifTrue: [ \r\t\t\tresult := self divide: stack].\r\t\tchar = \'dup\' ifTrue: [ \r\t\t\tresult := self dup: stack].\r\t\tchar = \'drop\' ifTrue: [ \r\t\t\tself drop: stack].\r\t\tchar = \'swap\' ifTrue: [ \r\t\t\tresult := self swap: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^ stack reversed asArray',			#stamp : 'AndyMarks 12/18/2023 21:12',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\r\t"comment stating purpose of instance-side method"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| elements stack |\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\r\telements splitOn: Character space do: [ :char | \r\t\t| result |\r\t\t(NumberParser isNumber: char) ifTrue: [ result := char asNumber ].\r\t\tchar = \'+\' ifTrue: [ \r\t\t\tresult := self add: stack].\r\t\tchar = \'-\' ifTrue: [ \r\t\t\tresult := self subtract: stack].\r\t\tchar = \'*\' ifTrue: [ \r\t\t\tresult := self multiply: stack].\r\t\tchar = \'/\' ifTrue: [ \r\t\t\tresult := self divide: stack].\r\t\tchar = \'dup\' ifTrue: [ \r\t\t\tresult := self dup: stack].\r\t\tchar = \'drop\' ifTrue: [ \r\t\t\tself drop: stack].\r\t\tchar = \'swap\' ifTrue: [ \r\t\t\tresult := self swap: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^ stack reversed asArray',			#stamp : 'AndyMarks 12/18/2023 21:12',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T21:13:20.197513+11:00' ],		#prior : OmReference [ '654' ],		#self : OmReference [ '655' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\r\t"comment stating purpose of instance-side method"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| elements stack |\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\r\telements splitOn: Character space do: [ :char | \r\t\t| result |\r\t\t(NumberParser isNumber: char) ifTrue: [ result := char asNumber ].\r\t\tchar = \'+\' ifTrue: [ \r\t\t\tresult := self add: stack].\r\t\tchar = \'-\' ifTrue: [ \r\t\t\tresult := self subtract: stack].\r\t\tchar = \'*\' ifTrue: [ \r\t\t\tresult := self multiply: stack].\r\t\tchar = \'/\' ifTrue: [ \r\t\t\tresult := self divide: stack].\r\t\tchar = \'dup\' ifTrue: [ \r\t\t\tresult := self dup: stack].\r\t\tchar = \'drop\' ifTrue: [ \r\t\t\tself drop: stack].\r\t\tchar = \'swap\' ifTrue: [ \r\t\t\tresult := self swap: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^ stack reversed asArray',			#stamp : 'AndyMarks 12/18/2023 21:12',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\r\t"comment stating purpose of instance-side method"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| elements stack |\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\r\telements splitOn: Character space do: [ :char | \r\t\t| result |\r\t\t(NumberParser isNumber: char) ifTrue: [ result := char asNumber ].\r\t\tchar = \'+\' ifTrue: [result := self add: stack].\r\t\tchar = \'-\' ifTrue: [result := self subtract: stack].\r\t\tchar = \'*\' ifTrue: [result := self multiply: stack].\r\t\tchar = \'/\' ifTrue: [result := self divide: stack].\r\t\tchar = \'dup\' ifTrue: [result := self dup: stack].\r\t\tchar = \'drop\' ifTrue: [self drop: stack].\r\t\tchar = \'swap\' ifTrue: [result := self swap: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^ stack reversed asArray',			#stamp : 'AndyMarks 12/18/2023 21:13',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T21:15:08.391744+11:00' ],		#prior : OmReference [ '655' ],		#self : OmReference [ '656' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\r\t"comment stating purpose of instance-side method"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| elements stack |\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\r\telements splitOn: Character space do: [ :char | \r\t\t| result |\r\t\t(NumberParser isNumber: char) ifTrue: [ result := char asNumber ].\r\t\tchar = \'+\' ifTrue: [result := self add: stack].\r\t\tchar = \'-\' ifTrue: [result := self subtract: stack].\r\t\tchar = \'*\' ifTrue: [result := self multiply: stack].\r\t\tchar = \'/\' ifTrue: [result := self divide: stack].\r\t\tchar = \'dup\' ifTrue: [result := self dup: stack].\r\t\tchar = \'drop\' ifTrue: [self drop: stack].\r\t\tchar = \'swap\' ifTrue: [result := self swap: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^ stack reversed asArray',			#stamp : 'AndyMarks 12/18/2023 21:13',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\r\t"comment stating purpose of instance-side method"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| elements stack |\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\r\telements splitOn: Character space do: [ :char | \r\t\t| result |\r\t\t(NumberParser isNumber: char) ifTrue: [ result := char asNumber ].\r\t\tchar = \'+\' ifTrue: [result := self add: stack].\r\t\tchar = \'-\' ifTrue: [result := self subtract: stack].\r\t\tchar = \'*\' ifTrue: [result := self multiply: stack].\r\t\tchar = \'/\' ifTrue: [result := self divide: stack].\r\t\tchar = \'dup\' ifTrue: [result := self dup: stack].\r\t\tchar = \'drop\' ifTrue: [self drop: stack].\r\t\tchar = \'swap\' ifTrue: [result := self swap: stack].\r\t\tchar = \'over\' ifTrue: [result := self over: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^ stack reversed asArray',			#stamp : 'AndyMarks 12/18/2023 21:15',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T21:15:31.772022+11:00' ],		#prior : OmReference [ '656' ],		#self : OmReference [ '657' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'over:',			#protocol : #'as yet unclassified',			#sourceCode : 'over: aStack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| operand1 operand2 |\r\taStack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\taStack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\toperand1 := aStack pop.\r\toperand2 := aStack pop.\r\taStack push: operand1.\r\r\t^operand2.\r',			#stamp : 'AndyMarks 12/18/2023 21:15',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-18T21:16:16.057397+11:00' ],		#prior : OmReference [ '657' ],		#self : OmReference [ '658' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'over:',			#protocol : #'as yet unclassified',			#sourceCode : 'over: aStack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| operand1 operand2 |\r\taStack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\taStack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\toperand1 := aStack pop.\r\toperand2 := aStack pop.\r\taStack push: operand1.\r\r\t^operand2.\r',			#stamp : 'AndyMarks 12/18/2023 21:15',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'over:',			#protocol : #'as yet unclassified',			#sourceCode : 'over: aStack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| operand1 operand2 |\r\taStack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\taStack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\toperand1 := aStack pop.\r\toperand2 := aStack top.\r\taStack push: operand1.\r\r\t^operand2.\r',			#stamp : 'AndyMarks 12/18/2023 21:16',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T18:27:22.683257+11:00' ],		#prior : OmReference [ '658' ],		#self : OmReference [ '659' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\r\t"comment stating purpose of instance-side method"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| elements stack |\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\r\telements splitOn: Character space do: [ :char | \r\t\t| result |\r\t\t(NumberParser isNumber: char) ifTrue: [ result := char asNumber ].\r\t\tchar = \'+\' ifTrue: [result := self add: stack].\r\t\tchar = \'-\' ifTrue: [result := self subtract: stack].\r\t\tchar = \'*\' ifTrue: [result := self multiply: stack].\r\t\tchar = \'/\' ifTrue: [result := self divide: stack].\r\t\tchar = \'dup\' ifTrue: [result := self dup: stack].\r\t\tchar = \'drop\' ifTrue: [self drop: stack].\r\t\tchar = \'swap\' ifTrue: [result := self swap: stack].\r\t\tchar = \'over\' ifTrue: [result := self over: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^ stack reversed asArray',			#stamp : 'AndyMarks 12/18/2023 21:15',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\r\t"comment stating purpose of instance-side method"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| elements stack |\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\r\telements splitOn: Character space do: [ :word | \r\t\t| result |\r\t\t(NumberParser isNumber: word) ifTrue: [ result := word asNumber ].\r\t\tword = \'+\' ifTrue: [result := self add: stack].\r\t\tword = \'-\' ifTrue: [result := self subtract: stack].\r\t\tword = \'*\' ifTrue: [result := self multiply: stack].\r\t\tword = \'/\' ifTrue: [result := self divide: stack].\r\t\tword = \'dup\' ifTrue: [result := self dup: stack].\r\t\tword = \'drop\' ifTrue: [self drop: stack].\r\t\tword = \'swap\' ifTrue: [result := self swap: stack].\r\t\tword = \'over\' ifTrue: [result := self over: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^ stack reversed asArray',			#stamp : 'AndyMarks 12/19/2023 18:27',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T18:29:20.676363+11:00' ],		#prior : OmReference [ '659' ],		#self : OmReference [ '660' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\r\t"comment stating purpose of instance-side method"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| elements stack |\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\r\telements splitOn: Character space do: [ :word | \r\t\t| result |\r\t\t(NumberParser isNumber: word) ifTrue: [ result := word asNumber ].\r\t\tword = \'+\' ifTrue: [result := self add: stack].\r\t\tword = \'-\' ifTrue: [result := self subtract: stack].\r\t\tword = \'*\' ifTrue: [result := self multiply: stack].\r\t\tword = \'/\' ifTrue: [result := self divide: stack].\r\t\tword = \'dup\' ifTrue: [result := self dup: stack].\r\t\tword = \'drop\' ifTrue: [self drop: stack].\r\t\tword = \'swap\' ifTrue: [result := self swap: stack].\r\t\tword = \'over\' ifTrue: [result := self over: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^ stack reversed asArray',			#stamp : 'AndyMarks 12/19/2023 18:27',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\r\t"comment stating purpose of instance-side method"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| elements stack |\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\r\telements splitOn: Character space do: [ :word | \r\t\t| result wordAsUpper |\r\t\twordAsUpper := word asUppercase.\r\t\t(NumberParser isNumber: word) ifTrue: [ result := word asNumber ].\r\t\tword = \'+\' ifTrue: [result := self add: stack].\r\t\tword = \'-\' ifTrue: [result := self subtract: stack].\r\t\tword = \'*\' ifTrue: [result := self multiply: stack].\r\t\tword = \'/\' ifTrue: [result := self divide: stack].\r\t\twordAsUpper = \'dup\' ifTrue: [result := self dup: stack].\r\t\twordAsUpper = \'drop\' ifTrue: [self drop: stack].\r\t\twordAsUpper = \'swap\' ifTrue: [result := self swap: stack].\r\t\twordAsUpper = \'over\' ifTrue: [result := self over: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^ stack reversed asArray',			#stamp : 'AndyMarks 12/19/2023 18:29',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T18:29:44.868202+11:00' ],		#prior : OmReference [ '660' ],		#self : OmReference [ '661' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\r\t"comment stating purpose of instance-side method"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| elements stack |\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\r\telements splitOn: Character space do: [ :word | \r\t\t| result wordAsUpper |\r\t\twordAsUpper := word asUppercase.\r\t\t(NumberParser isNumber: word) ifTrue: [ result := word asNumber ].\r\t\tword = \'+\' ifTrue: [result := self add: stack].\r\t\tword = \'-\' ifTrue: [result := self subtract: stack].\r\t\tword = \'*\' ifTrue: [result := self multiply: stack].\r\t\tword = \'/\' ifTrue: [result := self divide: stack].\r\t\twordAsUpper = \'dup\' ifTrue: [result := self dup: stack].\r\t\twordAsUpper = \'drop\' ifTrue: [self drop: stack].\r\t\twordAsUpper = \'swap\' ifTrue: [result := self swap: stack].\r\t\twordAsUpper = \'over\' ifTrue: [result := self over: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^ stack reversed asArray',			#stamp : 'AndyMarks 12/19/2023 18:29',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\r\t"comment stating purpose of instance-side method"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| elements stack |\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\r\telements splitOn: Character space do: [ :word | \r\t\t| result wordAsUpper |\r\t\twordAsUpper := word asUppercase.\r\t\t(NumberParser isNumber: word) ifTrue: [ result := word asNumber ].\r\t\tword = \'+\' ifTrue: [result := self add: stack].\r\t\tword = \'-\' ifTrue: [result := self subtract: stack].\r\t\tword = \'*\' ifTrue: [result := self multiply: stack].\r\t\tword = \'/\' ifTrue: [result := self divide: stack].\r\t\twordAsUpper = \'DUP\' ifTrue: [result := self dup: stack].\r\t\twordAsUpper = \'DROP\' ifTrue: [self drop: stack].\r\t\twordAsUpper = \'SWAP\' ifTrue: [result := self swap: stack].\r\t\twordAsUpper = \'OVER\' ifTrue: [result := self over: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^ stack reversed asArray',			#stamp : 'AndyMarks 12/19/2023 18:29',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T18:34:19.167418+11:00' ],		#prior : OmReference [ '661' ],		#self : OmReference [ '662' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'over:',			#protocol : #'as yet unclassified',			#sourceCode : 'over: aStack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| operand1 operand2 |\r\taStack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\taStack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\toperand1 := aStack pop.\r\toperand2 := aStack top.\r\taStack push: operand1.\r\r\t^operand2.\r',			#stamp : 'AndyMarks 12/18/2023 21:16',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'over:',			#protocol : #'as yet unclassified',			#sourceCode : 'over: aStack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| operand1 operand2 |\r\taStack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\taStack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\toperand1 := aStack pop.\r\toperand2 := aStack pop.\r\taStack push: operand1.\r\r\t^operand2.\r',			#stamp : 'AndyMarks 12/19/2023 18:34',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T18:34:19.18305+11:00' ],		#prior : OmReference [ '662' ],		#self : OmReference [ '663' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'over:',			#protocol : #'as yet unclassified',			#sourceCode : 'over: aStack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| operand1 operand2 |\r\taStack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\taStack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\toperand1 := aStack pop.\r\toperand2 := aStack pop.\r\taStack push: operand1.\r\r\t^operand2.\r',			#stamp : 'AndyMarks 12/19/2023 18:34',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'over:',			#protocol : #'instance creation',			#sourceCode : 'over: aStack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| operand1 operand2 |\r\taStack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\taStack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\toperand1 := aStack pop.\r\toperand2 := aStack pop.\r\taStack push: operand1.\r\r\t^operand2.\r',			#stamp : 'AndyMarks 12/19/2023 18:34',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T18:34:59.503555+11:00' ],		#prior : OmReference [ '663' ],		#self : OmReference [ '664' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'doLineOf:',			#protocol : #'instance creation',			#sourceCode : 'doLineOf: elements\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| stack |\r\t\r\tstack := Stack new.\r\t\r\telements splitOn: Character space do: [ :word | \r\t\t| result wordAsUpper |\r\t\twordAsUpper := word asUppercase.\r\t\t(NumberParser isNumber: word) ifTrue: [ result := word asNumber ].\r\t\tword = \'+\' ifTrue: [result := self add: stack].\r\t\tword = \'-\' ifTrue: [result := self subtract: stack].\r\t\tword = \'*\' ifTrue: [result := self multiply: stack].\r\t\tword = \'/\' ifTrue: [result := self divide: stack].\r\t\twordAsUpper = \'DUP\' ifTrue: [result := self dup: stack].\r\t\twordAsUpper = \'DROP\' ifTrue: [self drop: stack].\r\t\twordAsUpper = \'SWAP\' ifTrue: [result := self swap: stack].\r\t\twordAsUpper = \'OVER\' ifTrue: [result := self over: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^stack.',			#stamp : 'AndyMarks 12/19/2023 18:34',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T18:35:13.74003+11:00' ],		#prior : OmReference [ '664' ],		#self : OmReference [ '665' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\r\t"comment stating purpose of instance-side method"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| elements stack |\r\telements := anInstructionArray first.\r\tstack := Stack new.\r\r\telements splitOn: Character space do: [ :word | \r\t\t| result wordAsUpper |\r\t\twordAsUpper := word asUppercase.\r\t\t(NumberParser isNumber: word) ifTrue: [ result := word asNumber ].\r\t\tword = \'+\' ifTrue: [result := self add: stack].\r\t\tword = \'-\' ifTrue: [result := self subtract: stack].\r\t\tword = \'*\' ifTrue: [result := self multiply: stack].\r\t\tword = \'/\' ifTrue: [result := self divide: stack].\r\t\twordAsUpper = \'DUP\' ifTrue: [result := self dup: stack].\r\t\twordAsUpper = \'DROP\' ifTrue: [self drop: stack].\r\t\twordAsUpper = \'SWAP\' ifTrue: [result := self swap: stack].\r\t\twordAsUpper = \'OVER\' ifTrue: [result := self over: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^ stack reversed asArray',			#stamp : 'AndyMarks 12/19/2023 18:29',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\r\t"comment stating purpose of instance-side method"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| elements stack |\r\telements := anInstructionArray first.\r\tstack := self doLineOf: elements.\r\r\t^ stack reversed asArray',			#stamp : 'AndyMarks 12/19/2023 18:35',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T18:35:53.472711+11:00' ],		#prior : OmReference [ '665' ],		#self : OmReference [ '666' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'over:',			#protocol : #'instance creation',			#sourceCode : 'over: aStack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| operand1 operand2 |\r\taStack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\taStack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\toperand1 := aStack pop.\r\toperand2 := aStack pop.\r\taStack push: operand1.\r\r\t^operand2.\r',			#stamp : 'AndyMarks 12/19/2023 18:34',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'over:',			#protocol : #'instance creation',			#sourceCode : 'over: aStack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| operand1 operand2 |\r\taStack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\taStack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\toperand1 := aStack pop.\r\toperand2 := aStack top.\r\taStack push: operand1.\r\r\t^operand2.\r',			#stamp : 'AndyMarks 12/19/2023 18:35',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T18:43:33.351725+11:00' ],		#prior : OmReference [ '666' ],		#self : OmReference [ '667' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\r\t"comment stating purpose of instance-side method"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| elements stack |\r\telements := anInstructionArray first.\r\tstack := self doLineOf: elements.\r\r\t^ stack reversed asArray',			#stamp : 'AndyMarks 12/19/2023 18:35',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\r\t"comment stating purpose of instance-side method"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| stack |\r\tanInstructionArray do: [ :elements |\r\tstack := self doLineOf: elements.\r\t].\r\r\t^ stack reversed asArray',			#stamp : 'AndyMarks 12/19/2023 18:43',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T18:43:44.835214+11:00' ],		#prior : OmReference [ '667' ],		#self : OmReference [ '668' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\r\t"comment stating purpose of instance-side method"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| stack |\r\tanInstructionArray do: [ :elements |\r\tstack := self doLineOf: elements.\r\t].\r\r\t^ stack reversed asArray',			#stamp : 'AndyMarks 12/19/2023 18:43',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\r\t"comment stating purpose of instance-side method"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| stack |\r\tanInstructionArray do: [ :elements |\r\t\tstack := self doLineOf: elements.\r\t\t].\r\r\t^ stack reversed asArray',			#stamp : 'AndyMarks 12/19/2023 18:43',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T18:45:11.029461+11:00' ],		#prior : OmReference [ '668' ],		#self : OmReference [ '669' ]	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #ForthInstruction\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpackage: \'Exercise@Forth\'',				#superclassName : 'Object'			},			#name : #ForthInstruction,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ForthInstruction class\r\tinstanceVariableNames: \'\''				},				#name : #'ForthInstruction class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ForthInstruction,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #'Exercise@Forth',			#package : #'Exercise@Forth',			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T18:45:41.283632+11:00' ],		#prior : OmReference [ '669' ],		#self : OmReference [ '670' ]	},	#content : EpBehaviorNameChange {		#oldName : #ForthInstruction,		#newName : #ForthWord,		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #ForthWord\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpackage: \'Exercise@Forth\'',				#superclassName : 'Object'			},			#name : #ForthWord,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ForthWord class\r\tinstanceVariableNames: \'\''				},				#name : #'ForthWord class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ForthWord,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #'Exercise@Forth',			#package : #'Exercise@Forth',			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T18:46:00.034996+11:00' ],		#prior : OmReference [ '670' ],		#self : OmReference [ '671' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'add:',			#protocol : #adding,			#sourceCode : 'add: aStack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| operand1 operand2 |\t\t\t\r\taStack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\taStack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\toperand1 := aStack pop.\r\toperand2 := aStack pop.\r\r\t^operand1 + operand2.\r',			#stamp : 'AndyMarks 12/18/2023 21:00',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'add:',			#protocol : #'as yet unclassified',			#sourceCode : 'add: aStack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| operand1 operand2 |\t\t\t\r\taStack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\taStack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\toperand1 := aStack pop.\r\toperand2 := aStack pop.\r\r\t^operand1 + operand2.\r',			#stamp : 'AndyMarks 12/18/2023 21:00',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T18:46:00.039255+11:00' ],		#prior : OmReference [ '671' ],		#self : OmReference [ '672' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'add:',			#protocol : #adding,			#sourceCode : 'add: aStack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| operand1 operand2 |\t\t\t\r\taStack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\taStack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\toperand1 := aStack pop.\r\toperand2 := aStack pop.\r\r\t^operand1 + operand2.\r',			#stamp : 'AndyMarks 12/18/2023 21:00',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T18:46:00.046543+11:00' ],		#prior : OmReference [ '672' ],		#self : OmReference [ '673' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForthWord,				#isMetaSide : false			},			#name : #'add:',			#protocol : #adding,			#sourceCode : 'add: aStack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| operand1 operand2 |\t\t\t\r\taStack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\taStack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\toperand1 := aStack pop.\r\toperand2 := aStack pop.\r\r\t^operand1 + operand2.\r',			#stamp : 'AndyMarks 12/19/2023 18:46',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T18:46:00.047501+11:00' ],		#prior : OmReference [ '673' ],		#self : OmReference [ '674' ]	},	#content : EpProtocolRemoval {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Forth\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpackage: \'Exercise@Forth\'',				#superclassName : 'Object'			},			#name : #Forth,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Forth class\r\tinstanceVariableNames: \'\''				},				#name : #'Forth class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Forth,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #'Exercise@Forth',			#package : #'Exercise@Forth',			#sharedPools : OrderedCollection [ ]		},		#protocol : #adding	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T18:46:22.404228+11:00' ],		#prior : OmReference [ '674' ],		#self : OmReference [ '675' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'divide:',			#protocol : #'as yet unclassified',			#sourceCode : 'divide: aStack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| operand1 operand2 |\t\t\t\r\taStack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\taStack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\toperand1 := aStack pop.\r\toperand1 = 0 ifTrue: [ self error: \'divide by zero\' ].\r\toperand2 := aStack pop.\r\r\t^operand2 // operand1.\r',			#stamp : 'AndyMarks 12/18/2023 21:06',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T18:46:22.411581+11:00' ],		#prior : OmReference [ '675' ],		#self : OmReference [ '676' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForthWord,				#isMetaSide : false			},			#name : #'divide:',			#protocol : #'as yet unclassified',			#sourceCode : 'divide: aStack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| operand1 operand2 |\t\t\t\r\taStack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\taStack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\toperand1 := aStack pop.\r\toperand1 = 0 ifTrue: [ self error: \'divide by zero\' ].\r\toperand2 := aStack pop.\r\r\t^operand2 // operand1.\r',			#stamp : 'AndyMarks 12/19/2023 18:46',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T18:46:32.447828+11:00' ],		#prior : OmReference [ '676' ],		#self : OmReference [ '677' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'drop:',			#protocol : #'as yet unclassified',			#sourceCode : 'drop: aStack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\taStack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\taStack pop.\r',			#stamp : 'AndyMarks 12/18/2023 21:10',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T18:46:32.452418+11:00' ],		#prior : OmReference [ '677' ],		#self : OmReference [ '678' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForthWord,				#isMetaSide : false			},			#name : #'drop:',			#protocol : #'as yet unclassified',			#sourceCode : 'drop: aStack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\taStack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\taStack pop.\r',			#stamp : 'AndyMarks 12/19/2023 18:46',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T18:46:42.397581+11:00' ],		#prior : OmReference [ '678' ],		#self : OmReference [ '679' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'dup:',			#protocol : #'as yet unclassified',			#sourceCode : 'dup: aStack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\taStack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\r\t^aStack top.\r',			#stamp : 'AndyMarks 12/18/2023 21:09',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T18:46:42.403294+11:00' ],		#prior : OmReference [ '679' ],		#self : OmReference [ '680' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForthWord,				#isMetaSide : false			},			#name : #'dup:',			#protocol : #'as yet unclassified',			#sourceCode : 'dup: aStack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\taStack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\r\t^aStack top.\r',			#stamp : 'AndyMarks 12/19/2023 18:46',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T18:46:54.037433+11:00' ],		#prior : OmReference [ '680' ],		#self : OmReference [ '681' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'swap:',			#protocol : #'as yet unclassified',			#sourceCode : 'swap: aStack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| operand1 operand2 |\r\taStack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\taStack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\toperand1 := aStack pop.\r\toperand2 := aStack pop.\r\taStack push: operand1.\r\r\t^operand2.\r',			#stamp : 'AndyMarks 12/18/2023 21:12',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T18:46:54.044612+11:00' ],		#prior : OmReference [ '681' ],		#self : OmReference [ '682' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForthWord,				#isMetaSide : false			},			#name : #'swap:',			#protocol : #'as yet unclassified',			#sourceCode : 'swap: aStack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| operand1 operand2 |\r\taStack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\taStack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\toperand1 := aStack pop.\r\toperand2 := aStack pop.\r\taStack push: operand1.\r\r\t^operand2.\r',			#stamp : 'AndyMarks 12/19/2023 18:46',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T18:46:54.047297+11:00' ],		#prior : OmReference [ '682' ],		#self : OmReference [ '683' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'over:',			#protocol : #'instance creation',			#sourceCode : 'over: aStack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| operand1 operand2 |\r\taStack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\taStack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\toperand1 := aStack pop.\r\toperand2 := aStack top.\r\taStack push: operand1.\r\r\t^operand2.\r',			#stamp : 'AndyMarks 12/19/2023 18:35',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'over:',			#protocol : #'as yet unclassified',			#sourceCode : 'over: aStack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| operand1 operand2 |\r\taStack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\taStack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\toperand1 := aStack pop.\r\toperand2 := aStack top.\r\taStack push: operand1.\r\r\t^operand2.\r',			#stamp : 'AndyMarks 12/19/2023 18:35',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T18:46:54.04864+11:00' ],		#prior : OmReference [ '683' ],		#self : OmReference [ '684' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'over:',			#protocol : #'instance creation',			#sourceCode : 'over: aStack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| operand1 operand2 |\r\taStack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\taStack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\toperand1 := aStack pop.\r\toperand2 := aStack top.\r\taStack push: operand1.\r\r\t^operand2.\r',			#stamp : 'AndyMarks 12/19/2023 18:35',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T18:46:54.050617+11:00' ],		#prior : OmReference [ '684' ],		#self : OmReference [ '685' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForthWord,				#isMetaSide : false			},			#name : #'over:',			#protocol : #'instance creation',			#sourceCode : 'over: aStack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| operand1 operand2 |\r\taStack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\taStack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\toperand1 := aStack pop.\r\toperand2 := aStack top.\r\taStack push: operand1.\r\r\t^operand2.\r',			#stamp : 'AndyMarks 12/19/2023 18:46',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T18:46:54.052382+11:00' ],		#prior : OmReference [ '685' ],		#self : OmReference [ '686' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'subtract:',			#protocol : #'as yet unclassified',			#sourceCode : 'subtract: aStack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| operand1 operand2 |\t\t\t\r\taStack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\taStack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\toperand1 := aStack pop.\r\toperand2 := aStack pop.\r\r\t^operand2 - operand1.\r',			#stamp : 'AndyMarks 12/18/2023 21:05',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T18:46:54.05424+11:00' ],		#prior : OmReference [ '686' ],		#self : OmReference [ '687' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForthWord,				#isMetaSide : false			},			#name : #'subtract:',			#protocol : #'as yet unclassified',			#sourceCode : 'subtract: aStack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| operand1 operand2 |\t\t\t\r\taStack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\taStack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\toperand1 := aStack pop.\r\toperand2 := aStack pop.\r\r\t^operand2 - operand1.\r',			#stamp : 'AndyMarks 12/19/2023 18:46',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T18:46:54.055869+11:00' ],		#prior : OmReference [ '687' ],		#self : OmReference [ '688' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'multiply:',			#protocol : #'as yet unclassified',			#sourceCode : 'multiply: aStack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| operand1 operand2 |\t\t\t\r\taStack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\taStack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\toperand1 := aStack pop.\r\toperand2 := aStack pop.\r\r\t^operand2 * operand1.\r',			#stamp : 'AndyMarks 12/18/2023 21:07',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T18:46:54.057643+11:00' ],		#prior : OmReference [ '688' ],		#self : OmReference [ '689' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForthWord,				#isMetaSide : false			},			#name : #'multiply:',			#protocol : #'as yet unclassified',			#sourceCode : 'multiply: aStack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| operand1 operand2 |\t\t\t\r\taStack size < 1 ifTrue: [ self error: \'empty stack\' ].\r\taStack size < 2 ifTrue: [ self error: \'only one value on the stack\' ].\r\toperand1 := aStack pop.\r\toperand2 := aStack pop.\r\r\t^operand2 * operand1.\r',			#stamp : 'AndyMarks 12/19/2023 18:46',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T18:47:19.234692+11:00' ],		#prior : OmReference [ '689' ],		#self : OmReference [ '690' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'doLineOf:',			#protocol : #'instance creation',			#sourceCode : 'doLineOf: elements\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| stack |\r\t\r\tstack := Stack new.\r\t\r\telements splitOn: Character space do: [ :word | \r\t\t| result wordAsUpper |\r\t\twordAsUpper := word asUppercase.\r\t\t(NumberParser isNumber: word) ifTrue: [ result := word asNumber ].\r\t\tword = \'+\' ifTrue: [result := self add: stack].\r\t\tword = \'-\' ifTrue: [result := self subtract: stack].\r\t\tword = \'*\' ifTrue: [result := self multiply: stack].\r\t\tword = \'/\' ifTrue: [result := self divide: stack].\r\t\twordAsUpper = \'DUP\' ifTrue: [result := self dup: stack].\r\t\twordAsUpper = \'DROP\' ifTrue: [self drop: stack].\r\t\twordAsUpper = \'SWAP\' ifTrue: [result := self swap: stack].\r\t\twordAsUpper = \'OVER\' ifTrue: [result := self over: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^stack.',			#stamp : 'AndyMarks 12/19/2023 18:34',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'doLineOf:',			#protocol : #'instance creation',			#sourceCode : 'doLineOf: elements\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| stack |\r\t\r\tstack := Stack new.\r\t\r\telements splitOn: Character space do: [ :word | \r\t\t| result wordAsUpper |\r\t\twordAsUpper := word asUppercase.\r\t\t(NumberParser isNumber: word) ifTrue: [ result := word asNumber ].\r\t\tword = \'+\' ifTrue: [result := ForthWord new add: stack].\r\t\tword = \'-\' ifTrue: [result := self subtract: stack].\r\t\tword = \'*\' ifTrue: [result := self multiply: stack].\r\t\tword = \'/\' ifTrue: [result := self divide: stack].\r\t\twordAsUpper = \'DUP\' ifTrue: [result := self dup: stack].\r\t\twordAsUpper = \'DROP\' ifTrue: [self drop: stack].\r\t\twordAsUpper = \'SWAP\' ifTrue: [result := self swap: stack].\r\t\twordAsUpper = \'OVER\' ifTrue: [result := self over: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^stack.',			#stamp : 'AndyMarks 12/19/2023 18:47',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T18:47:50.944616+11:00' ],		#prior : OmReference [ '690' ],		#self : OmReference [ '691' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'doLineOf:',			#protocol : #'instance creation',			#sourceCode : 'doLineOf: elements\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| stack |\r\t\r\tstack := Stack new.\r\t\r\telements splitOn: Character space do: [ :word | \r\t\t| result wordAsUpper |\r\t\twordAsUpper := word asUppercase.\r\t\t(NumberParser isNumber: word) ifTrue: [ result := word asNumber ].\r\t\tword = \'+\' ifTrue: [result := ForthWord new add: stack].\r\t\tword = \'-\' ifTrue: [result := self subtract: stack].\r\t\tword = \'*\' ifTrue: [result := self multiply: stack].\r\t\tword = \'/\' ifTrue: [result := self divide: stack].\r\t\twordAsUpper = \'DUP\' ifTrue: [result := self dup: stack].\r\t\twordAsUpper = \'DROP\' ifTrue: [self drop: stack].\r\t\twordAsUpper = \'SWAP\' ifTrue: [result := self swap: stack].\r\t\twordAsUpper = \'OVER\' ifTrue: [result := self over: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^stack.',			#stamp : 'AndyMarks 12/19/2023 18:47',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'doLineOf:',			#protocol : #'instance creation',			#sourceCode : 'doLineOf: elements\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| stack |\r\t\r\tstack := Stack new.\r\t\r\telements splitOn: Character space do: [ :word | \r\t\t| result wordAsUpper |\r\t\twordAsUpper := word asUppercase.\r\t\t(NumberParser isNumber: word) ifTrue: [ result := word asNumber ].\r\t\tword = \'+\' ifTrue: [result := ForthWord new add: stack].\r\t\tword = \'-\' ifTrue: [result := ForthWord new subtract: stack].\r\t\tword = \'*\' ifTrue: [result := ForthWord new multiply: stack].\r\t\tword = \'/\' ifTrue: [result := ForthWord new divide: stack].\r\t\twordAsUpper = \'DUP\' ifTrue: [result := ForthWord new dup: stack].\r\t\twordAsUpper = \'DROP\' ifTrue: [ForthWord new drop: stack].\r\t\twordAsUpper = \'SWAP\' ifTrue: [result := ForthWord new swap: stack].\r\t\twordAsUpper = \'OVER\' ifTrue: [result := ForthWord new over: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^stack.',			#stamp : 'AndyMarks 12/19/2023 18:47',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T18:48:21.653792+11:00' ],		#prior : OmReference [ '691' ],		#self : OmReference [ '692' ]	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PackageManifest subclass: #ManifestExerciseForth\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpackage: \'Exercise@Forth\'',				#superclassName : 'PackageManifest'			},			#name : #ManifestExerciseForth,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ManifestExerciseForth class\r\tinstanceVariableNames: \'\''				},				#name : #'ManifestExerciseForth class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ManifestExerciseForth,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #'Exercise@Forth',			#package : #'Exercise@Forth',			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T18:48:21.656399+11:00' ],		#prior : OmReference [ '692' ],		#self : OmReference [ '693' ]	},	#content : EpCategoryAddition {		#classCategoryName : #'Exercise@Forth-Manifest',		#affectedPackageName : #'Exercise@Forth'	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T18:48:21.658998+11:00' ],		#prior : OmReference [ '693' ],		#self : OmReference [ '694' ]	},	#content : EpBehaviorCategoryChange {		#oldCategory : #'Exercise@Forth',		#newCategory : #'Exercise@Forth-Manifest',		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PackageManifest subclass: #ManifestExerciseForth\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpackage: \'Exercise@Forth-Manifest\'',				#superclassName : 'PackageManifest'			},			#name : #ManifestExerciseForth,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ManifestExerciseForth class\r\tinstanceVariableNames: \'\''				},				#name : #'ManifestExerciseForth class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ManifestExerciseForth,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #'Exercise@Forth-Manifest',			#package : #'Exercise@Forth',			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T18:48:21.661064+11:00' ],		#prior : OmReference [ '694' ],		#self : OmReference [ '695' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'PackageManifest subclass: #ManifestExerciseForth\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpackage: \'Exercise@Forth-Manifest\'',				#superclassName : 'PackageManifest'			},			#name : #ManifestExerciseForth,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ManifestExerciseForth class\r\tinstanceVariableNames: \'\''				},				#name : #'ManifestExerciseForth class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ManifestExerciseForth,					#isMetaSide : false				},				#parent : @7,				#content : 'Please describe the package using the class comment of the included manifest class. The manifest class also includes other additional metadata for the package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser',				#stamp : '<historical>'			},			#classVariables : OrderedCollection [ ],			#category : #'Exercise@Forth-Manifest',			#package : #'Exercise@Forth',			#sharedPools : OrderedCollection [ ]		},		#oldComment : '',		#newComment : 'Please describe the package using the class comment of the included manifest class. The manifest class also includes other additional metadata for the package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser',		#oldStamp : '',		#newStamp : '<historical>'	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T18:48:21.664289+11:00' ],		#prior : OmReference [ '695' ],		#self : OmReference [ '696' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ManifestExerciseForth class',				#isMetaSide : true			},			#name : #ruleUsesAddRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleUsesAddRuleV1FalsePositive\r\t^ #()',			#stamp : 'AndyMarks 12/19/2023 18:48',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T18:48:21.668412+11:00' ],		#prior : OmReference [ '696' ],		#self : OmReference [ '697' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ManifestExerciseForth class',				#isMetaSide : true			},			#name : #ruleUsesAddRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleUsesAddRuleV1FalsePositive\r\t^ #()',			#stamp : 'AndyMarks 12/19/2023 18:48',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ManifestExerciseForth class',				#isMetaSide : true			},			#name : #ruleUsesAddRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleUsesAddRuleV1FalsePositive\r\t^ #(#(#(#RGMethodDefinition #(#Forth #doLineOf: #false)) #\'2023-12-19T18:48:21.664784+11:00\') )',			#stamp : 'AndyMarks 12/19/2023 18:48',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T18:50:14.95968+11:00' ],		#prior : OmReference [ '697' ],		#self : OmReference [ '698' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'doLineOf:',			#protocol : #'instance creation',			#sourceCode : 'doLineOf: elements\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| stack |\r\t\r\tstack := Stack new.\r\t\r\telements splitOn: Character space do: [ :word | \r\t\t| result wordAsUpper |\r\t\twordAsUpper := word asUppercase.\r\t\t(NumberParser isNumber: word) ifTrue: [ result := word asNumber ].\r\t\tword = \'+\' ifTrue: [result := ForthWord new add: stack].\r\t\tword = \'-\' ifTrue: [result := ForthWord new subtract: stack].\r\t\tword = \'*\' ifTrue: [result := ForthWord new multiply: stack].\r\t\tword = \'/\' ifTrue: [result := ForthWord new divide: stack].\r\t\twordAsUpper = \'DUP\' ifTrue: [result := ForthWord new dup: stack].\r\t\twordAsUpper = \'DROP\' ifTrue: [ForthWord new drop: stack].\r\t\twordAsUpper = \'SWAP\' ifTrue: [result := ForthWord new swap: stack].\r\t\twordAsUpper = \'OVER\' ifTrue: [result := ForthWord new over: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^stack.',			#stamp : 'AndyMarks 12/19/2023 18:47',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'doLineOf:',			#protocol : #'instance creation',			#sourceCode : 'doLineOf: elements\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| stack |\r\t\r\tstack := Stack new.\r\t\r\telements splitOn: Character space do: [ :word | \r\t\t| result wordAsUpper |\r\t\twordAsUpper := word asUppercase.\r\t\t(NumberParser isNumber: word) ifTrue: [ result := word asNumber ].\r\t\tword = \'+\' ifTrue: [result := ForthWord new add: stack].\r\t\tword = \'-\' ifTrue: [result := ForthWord new subtract: stack].\r\t\tword = \'*\' ifTrue: [result := ForthWord new multiply: stack].\r\t\tword = \'/\' ifTrue: [result := ForthWord new divide: stack].\r\t\twordAsUpper = \'DUP\' ifTrue: [result := ForthWord new dup: stack].\r\t\twordAsUpper = \'DROP\' ifTrue: [ForthWord new drop: stack].\r\t\twordAsUpper = \'SWAP\' ifTrue: [result := ForthWord new swap: stack].\r\t\twordAsUpper = \'OVER\' ifTrue: [result := self over: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^stack.',			#stamp : 'AndyMarks 12/19/2023 18:50',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T18:50:21.839324+11:00' ],		#prior : OmReference [ '698' ],		#self : OmReference [ '699' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'doLineOf:',			#protocol : #'instance creation',			#sourceCode : 'doLineOf: elements\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| stack |\r\t\r\tstack := Stack new.\r\t\r\telements splitOn: Character space do: [ :word | \r\t\t| result wordAsUpper |\r\t\twordAsUpper := word asUppercase.\r\t\t(NumberParser isNumber: word) ifTrue: [ result := word asNumber ].\r\t\tword = \'+\' ifTrue: [result := ForthWord new add: stack].\r\t\tword = \'-\' ifTrue: [result := ForthWord new subtract: stack].\r\t\tword = \'*\' ifTrue: [result := ForthWord new multiply: stack].\r\t\tword = \'/\' ifTrue: [result := ForthWord new divide: stack].\r\t\twordAsUpper = \'DUP\' ifTrue: [result := ForthWord new dup: stack].\r\t\twordAsUpper = \'DROP\' ifTrue: [ForthWord new drop: stack].\r\t\twordAsUpper = \'SWAP\' ifTrue: [result := ForthWord new swap: stack].\r\t\twordAsUpper = \'OVER\' ifTrue: [result := self over: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^stack.',			#stamp : 'AndyMarks 12/19/2023 18:50',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'doLineOf:',			#protocol : #'instance creation',			#sourceCode : 'doLineOf: elements\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| stack |\r\t\r\tstack := Stack new.\r\t\r\telements splitOn: Character space do: [ :word | \r\t\t| result wordAsUpper |\r\t\twordAsUpper := word asUppercase.\r\t\t(NumberParser isNumber: word) ifTrue: [ result := word asNumber ].\r\t\tword = \'+\' ifTrue: [result := ForthWord new add: stack].\r\t\tword = \'-\' ifTrue: [result := ForthWord new subtract: stack].\r\t\tword = \'*\' ifTrue: [result := ForthWord new multiply: stack].\r\t\tword = \'/\' ifTrue: [result := ForthWord new divide: stack].\r\t\twordAsUpper = \'DUP\' ifTrue: [result := ForthWord new dup: stack].\r\t\twordAsUpper = \'DROP\' ifTrue: [ForthWord new drop: stack].\r\t\twordAsUpper = \'SWAP\' ifTrue: [result := ForthWord new swap: stack].\r\t\twordAsUpper = \'OVER\' ifTrue: [result := ForthWord new over: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^stack.',			#stamp : 'AndyMarks 12/19/2023 18:50',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T18:52:04.448842+11:00' ],		#prior : OmReference [ '699' ],		#self : OmReference [ '700' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'doLineOf:',			#protocol : #'instance creation',			#sourceCode : 'doLineOf: elements\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| stack |\r\t\r\tstack := Stack new.\r\t\r\telements splitOn: Character space do: [ :word | \r\t\t| result wordAsUpper |\r\t\twordAsUpper := word asUppercase.\r\t\t(NumberParser isNumber: word) ifTrue: [ result := word asNumber ].\r\t\tword = \'+\' ifTrue: [result := ForthWord new add: stack].\r\t\tword = \'-\' ifTrue: [result := ForthWord new subtract: stack].\r\t\tword = \'*\' ifTrue: [result := ForthWord new multiply: stack].\r\t\tword = \'/\' ifTrue: [result := ForthWord new divide: stack].\r\t\twordAsUpper = \'DUP\' ifTrue: [result := ForthWord new dup: stack].\r\t\twordAsUpper = \'DROP\' ifTrue: [ForthWord new drop: stack].\r\t\twordAsUpper = \'SWAP\' ifTrue: [result := ForthWord new swap: stack].\r\t\twordAsUpper = \'OVER\' ifTrue: [result := ForthWord new over: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^stack.',			#stamp : 'AndyMarks 12/19/2023 18:50',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'doLineOf:',			#protocol : #'instance creation',			#sourceCode : 'doLineOf: elements\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| stack handler |\r\t\r\tstack := Stack new.\r\thandler := ForthWord new.\r\t\r\telements splitOn: Character space do: [ :word | \r\t\t| result wordAsUpper  |\r\t\twordAsUpper := word asUppercase.\r\t\t(NumberParser isNumber: word) ifTrue: [ result := word asNumber ].\r\t\tword = \'+\' ifTrue: [result := handler add: stack].\r\t\tword = \'-\' ifTrue: [result := handler subtract: stack].\r\t\tword = \'*\' ifTrue: [result := handler multiply: stack].\r\t\tword = \'/\' ifTrue: [result := handler divide: stack].\r\t\twordAsUpper = \'DUP\' ifTrue: [result := handler dup: stack].\r\t\twordAsUpper = \'DROP\' ifTrue: [handler drop: stack].\r\t\twordAsUpper = \'SWAP\' ifTrue: [result := handler swap: stack].\r\t\twordAsUpper = \'OVER\' ifTrue: [result := handler over: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^stack.',			#stamp : 'AndyMarks 12/19/2023 18:52',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T18:54:27.305554+11:00' ],		#prior : OmReference [ '700' ],		#self : OmReference [ '701' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'doLineOf:',			#protocol : #'instance creation',			#sourceCode : 'doLineOf: elements\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| stack handler |\r\t\r\tstack := Stack new.\r\thandler := ForthWord new.\r\t\r\telements splitOn: Character space do: [ :word | \r\t\t| result wordAsUpper  |\r\t\twordAsUpper := word asUppercase.\r\t\t(NumberParser isNumber: word) ifTrue: [ result := word asNumber ].\r\t\tword = \'+\' ifTrue: [result := handler add: stack].\r\t\tword = \'-\' ifTrue: [result := handler subtract: stack].\r\t\tword = \'*\' ifTrue: [result := handler multiply: stack].\r\t\tword = \'/\' ifTrue: [result := handler divide: stack].\r\t\twordAsUpper = \'DUP\' ifTrue: [result := handler dup: stack].\r\t\twordAsUpper = \'DROP\' ifTrue: [handler drop: stack].\r\t\twordAsUpper = \'SWAP\' ifTrue: [result := handler swap: stack].\r\t\twordAsUpper = \'OVER\' ifTrue: [result := handler over: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^stack.',			#stamp : 'AndyMarks 12/19/2023 18:52',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'doLineOf:',			#protocol : #'instance creation',			#sourceCode : 'doLineOf: elements\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| stack handler |\r\t\r\tstack := Stack new.\r\thandler := ForthWord new.\r\t\r\telements matchesRegex: \': .* .* ;\'\r\tifTrue: [ ].\r\t\r\telements splitOn: Character space do: [ :word | \r\t\t| result wordAsUpper  |\r\t\twordAsUpper := word asUppercase.\r\t\t(NumberParser isNumber: word) ifTrue: [ result := word asNumber ].\r\t\tword = \'+\' ifTrue: [result := handler add: stack].\r\t\tword = \'-\' ifTrue: [result := handler subtract: stack].\r\t\tword = \'*\' ifTrue: [result := handler multiply: stack].\r\t\tword = \'/\' ifTrue: [result := handler divide: stack].\r\t\twordAsUpper = \'DUP\' ifTrue: [result := handler dup: stack].\r\t\twordAsUpper = \'DROP\' ifTrue: [handler drop: stack].\r\t\twordAsUpper = \'SWAP\' ifTrue: [result := handler swap: stack].\r\t\twordAsUpper = \'OVER\' ifTrue: [result := handler over: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^stack.',			#stamp : 'AndyMarks 12/19/2023 18:54',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T18:56:24.964314+11:00' ],		#prior : OmReference [ '701' ],		#self : OmReference [ '702' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'doLineOf:',			#protocol : #'instance creation',			#sourceCode : 'doLineOf: elements\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| stack handler |\r\t\r\tstack := Stack new.\r\thandler := ForthWord new.\r\t\r\telements matchesRegex: \': .* .* ;\'\r\tifTrue: [ ].\r\t\r\telements splitOn: Character space do: [ :word | \r\t\t| result wordAsUpper  |\r\t\twordAsUpper := word asUppercase.\r\t\t(NumberParser isNumber: word) ifTrue: [ result := word asNumber ].\r\t\tword = \'+\' ifTrue: [result := handler add: stack].\r\t\tword = \'-\' ifTrue: [result := handler subtract: stack].\r\t\tword = \'*\' ifTrue: [result := handler multiply: stack].\r\t\tword = \'/\' ifTrue: [result := handler divide: stack].\r\t\twordAsUpper = \'DUP\' ifTrue: [result := handler dup: stack].\r\t\twordAsUpper = \'DROP\' ifTrue: [handler drop: stack].\r\t\twordAsUpper = \'SWAP\' ifTrue: [result := handler swap: stack].\r\t\twordAsUpper = \'OVER\' ifTrue: [result := handler over: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^stack.',			#stamp : 'AndyMarks 12/19/2023 18:54',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'doLineOf:',			#protocol : #'instance creation',			#sourceCode : 'doLineOf: elements\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| stack handler |\r\t\r\tstack := Stack new.\r\thandler := ForthWord new.\r\t\r\t(elements matchesRegex: \': (.*) (.*) ;\')\r\tifTrue: [ ].\r\t\r\telements splitOn: Character space do: [ :word | \r\t\t| result wordAsUpper  |\r\t\twordAsUpper := word asUppercase.\r\t\t(NumberParser isNumber: word) ifTrue: [ result := word asNumber ].\r\t\tword = \'+\' ifTrue: [result := handler add: stack].\r\t\tword = \'-\' ifTrue: [result := handler subtract: stack].\r\t\tword = \'*\' ifTrue: [result := handler multiply: stack].\r\t\tword = \'/\' ifTrue: [result := handler divide: stack].\r\t\twordAsUpper = \'DUP\' ifTrue: [result := handler dup: stack].\r\t\twordAsUpper = \'DROP\' ifTrue: [handler drop: stack].\r\t\twordAsUpper = \'SWAP\' ifTrue: [result := handler swap: stack].\r\t\twordAsUpper = \'OVER\' ifTrue: [result := handler over: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^stack.',			#stamp : 'AndyMarks 12/19/2023 18:56',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T18:56:49.934137+11:00' ],		#prior : OmReference [ '702' ],		#self : OmReference [ '703' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'doLineOf:',			#protocol : #'instance creation',			#sourceCode : 'doLineOf: elements\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| stack handler |\r\t\r\tstack := Stack new.\r\thandler := ForthWord new.\r\t\r\t(elements matchesRegex: \': (.*) (.*) ;\')\r\tifTrue: [ ].\r\t\r\telements splitOn: Character space do: [ :word | \r\t\t| result wordAsUpper  |\r\t\twordAsUpper := word asUppercase.\r\t\t(NumberParser isNumber: word) ifTrue: [ result := word asNumber ].\r\t\tword = \'+\' ifTrue: [result := handler add: stack].\r\t\tword = \'-\' ifTrue: [result := handler subtract: stack].\r\t\tword = \'*\' ifTrue: [result := handler multiply: stack].\r\t\tword = \'/\' ifTrue: [result := handler divide: stack].\r\t\twordAsUpper = \'DUP\' ifTrue: [result := handler dup: stack].\r\t\twordAsUpper = \'DROP\' ifTrue: [handler drop: stack].\r\t\twordAsUpper = \'SWAP\' ifTrue: [result := handler swap: stack].\r\t\twordAsUpper = \'OVER\' ifTrue: [result := handler over: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^stack.',			#stamp : 'AndyMarks 12/19/2023 18:56',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'doLineOf:',			#protocol : #'instance creation',			#sourceCode : 'doLineOf: elements\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| stack handler |\r\t\r\tstack := Stack new.\r\thandler := ForthWord new.\r\t\r\t(elements matchesRegex: \': (.*) (.*) ;\')\r\t\tifTrue: [ \'found a user defined word\' inspec].\r\t\r\telements splitOn: Character space do: [ :word | \r\t\t| result wordAsUpper  |\r\t\twordAsUpper := word asUppercase.\r\t\t(NumberParser isNumber: word) ifTrue: [ result := word asNumber ].\r\t\tword = \'+\' ifTrue: [result := handler add: stack].\r\t\tword = \'-\' ifTrue: [result := handler subtract: stack].\r\t\tword = \'*\' ifTrue: [result := handler multiply: stack].\r\t\tword = \'/\' ifTrue: [result := handler divide: stack].\r\t\twordAsUpper = \'DUP\' ifTrue: [result := handler dup: stack].\r\t\twordAsUpper = \'DROP\' ifTrue: [handler drop: stack].\r\t\twordAsUpper = \'SWAP\' ifTrue: [result := handler swap: stack].\r\t\twordAsUpper = \'OVER\' ifTrue: [result := handler over: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^stack.',			#stamp : 'AndyMarks 12/19/2023 18:56',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T18:56:56.05333+11:00' ],		#prior : OmReference [ '703' ],		#self : OmReference [ '704' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'doLineOf:',			#protocol : #'instance creation',			#sourceCode : 'doLineOf: elements\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| stack handler |\r\t\r\tstack := Stack new.\r\thandler := ForthWord new.\r\t\r\t(elements matchesRegex: \': (.*) (.*) ;\')\r\t\tifTrue: [ \'found a user defined word\' inspec].\r\t\r\telements splitOn: Character space do: [ :word | \r\t\t| result wordAsUpper  |\r\t\twordAsUpper := word asUppercase.\r\t\t(NumberParser isNumber: word) ifTrue: [ result := word asNumber ].\r\t\tword = \'+\' ifTrue: [result := handler add: stack].\r\t\tword = \'-\' ifTrue: [result := handler subtract: stack].\r\t\tword = \'*\' ifTrue: [result := handler multiply: stack].\r\t\tword = \'/\' ifTrue: [result := handler divide: stack].\r\t\twordAsUpper = \'DUP\' ifTrue: [result := handler dup: stack].\r\t\twordAsUpper = \'DROP\' ifTrue: [handler drop: stack].\r\t\twordAsUpper = \'SWAP\' ifTrue: [result := handler swap: stack].\r\t\twordAsUpper = \'OVER\' ifTrue: [result := handler over: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^stack.',			#stamp : 'AndyMarks 12/19/2023 18:56',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'doLineOf:',			#protocol : #'instance creation',			#sourceCode : 'doLineOf: elements\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| stack handler |\r\t\r\tstack := Stack new.\r\thandler := ForthWord new.\r\t\r\t(elements matchesRegex: \': (.*) (.*) ;\')\r\t\tifTrue: [ \'found a user defined word\' inspect].\r\t\r\telements splitOn: Character space do: [ :word | \r\t\t| result wordAsUpper  |\r\t\twordAsUpper := word asUppercase.\r\t\t(NumberParser isNumber: word) ifTrue: [ result := word asNumber ].\r\t\tword = \'+\' ifTrue: [result := handler add: stack].\r\t\tword = \'-\' ifTrue: [result := handler subtract: stack].\r\t\tword = \'*\' ifTrue: [result := handler multiply: stack].\r\t\tword = \'/\' ifTrue: [result := handler divide: stack].\r\t\twordAsUpper = \'DUP\' ifTrue: [result := handler dup: stack].\r\t\twordAsUpper = \'DROP\' ifTrue: [handler drop: stack].\r\t\twordAsUpper = \'SWAP\' ifTrue: [result := handler swap: stack].\r\t\twordAsUpper = \'OVER\' ifTrue: [result := handler over: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^stack.',			#stamp : 'AndyMarks 12/19/2023 18:56',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T18:58:40.6894+11:00' ],		#prior : OmReference [ '704' ],		#self : OmReference [ '705' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'doLineOf:',			#protocol : #'instance creation',			#sourceCode : 'doLineOf: elements\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| stack handler |\r\t\r\tstack := Stack new.\r\thandler := ForthWord new.\r\t\r\t(elements matchesRegex: \': (.*) (.*) ;\')\r\t\tifTrue: [ \'found a user defined word\' inspect].\r\t\r\telements splitOn: Character space do: [ :word | \r\t\t| result wordAsUpper  |\r\t\twordAsUpper := word asUppercase.\r\t\t(NumberParser isNumber: word) ifTrue: [ result := word asNumber ].\r\t\tword = \'+\' ifTrue: [result := handler add: stack].\r\t\tword = \'-\' ifTrue: [result := handler subtract: stack].\r\t\tword = \'*\' ifTrue: [result := handler multiply: stack].\r\t\tword = \'/\' ifTrue: [result := handler divide: stack].\r\t\twordAsUpper = \'DUP\' ifTrue: [result := handler dup: stack].\r\t\twordAsUpper = \'DROP\' ifTrue: [handler drop: stack].\r\t\twordAsUpper = \'SWAP\' ifTrue: [result := handler swap: stack].\r\t\twordAsUpper = \'OVER\' ifTrue: [result := handler over: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^stack.',			#stamp : 'AndyMarks 12/19/2023 18:56',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'doLineOf:',			#protocol : #'instance creation',			#sourceCode : 'doLineOf: elements\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| stack handler |\r\t\r\tstack := Stack new.\r\thandler := ForthWord new.\r\t\r\t"(elements matchesRegex: \': (.*) (.*) ;\')"\r"\t\tifTrue: [ \'found a user defined word\' inspect]."\r\t\r\telements splitOn: Character space do: [ :word | \r\t\t| result wordAsUpper  |\r\t\twordAsUpper := word asUppercase.\r\t\t(NumberParser isNumber: word) ifTrue: [ result := word asNumber ].\r\t\tword = \'+\' ifTrue: [result := handler add: stack].\r\t\tword = \'-\' ifTrue: [result := handler subtract: stack].\r\t\tword = \'*\' ifTrue: [result := handler multiply: stack].\r\t\tword = \'/\' ifTrue: [result := handler divide: stack].\r\t\twordAsUpper = \'DUP\' ifTrue: [result := handler dup: stack].\r\t\twordAsUpper = \'DROP\' ifTrue: [handler drop: stack].\r\t\twordAsUpper = \'SWAP\' ifTrue: [result := handler swap: stack].\r\t\twordAsUpper = \'OVER\' ifTrue: [result := handler over: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^stack.',			#stamp : 'AndyMarks 12/19/2023 18:58',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T19:00:15.76302+11:00' ],		#prior : OmReference [ '705' ],		#self : OmReference [ '706' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'doLineOf:',			#protocol : #'instance creation',			#sourceCode : 'doLineOf: elements\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| stack handler |\r\t\r\tstack := Stack new.\r\thandler := ForthWord new.\r\t\r\t"(elements matchesRegex: \': (.*) (.*) ;\')"\r"\t\tifTrue: [ \'found a user defined word\' inspect]."\r\t\r\telements splitOn: Character space do: [ :word | \r\t\t| result wordAsUpper  |\r\t\twordAsUpper := word asUppercase.\r\t\t(NumberParser isNumber: word) ifTrue: [ result := word asNumber ].\r\t\tword = \'+\' ifTrue: [result := handler add: stack].\r\t\tword = \'-\' ifTrue: [result := handler subtract: stack].\r\t\tword = \'*\' ifTrue: [result := handler multiply: stack].\r\t\tword = \'/\' ifTrue: [result := handler divide: stack].\r\t\twordAsUpper = \'DUP\' ifTrue: [result := handler dup: stack].\r\t\twordAsUpper = \'DROP\' ifTrue: [handler drop: stack].\r\t\twordAsUpper = \'SWAP\' ifTrue: [result := handler swap: stack].\r\t\twordAsUpper = \'OVER\' ifTrue: [result := handler over: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^stack.',			#stamp : 'AndyMarks 12/19/2023 18:58',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'doLineOf:',			#protocol : #'instance creation',			#sourceCode : 'doLineOf: elements\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| stack handler |\r\t\r\tstack := Stack new.\r\thandler := ForthWord new.\r\t\r\t(elements matchesRegex: \'\\: (.*) (.*) ;\')\r\t\tifTrue: [ \'found a user defined word\' inspect].\r\t\r\telements splitOn: Character space do: [ :word | \r\t\t| result wordAsUpper  |\r\t\twordAsUpper := word asUppercase.\r\t\t(NumberParser isNumber: word) ifTrue: [ result := word asNumber ].\r\t\tword = \'+\' ifTrue: [result := handler add: stack].\r\t\tword = \'-\' ifTrue: [result := handler subtract: stack].\r\t\tword = \'*\' ifTrue: [result := handler multiply: stack].\r\t\tword = \'/\' ifTrue: [result := handler divide: stack].\r\t\twordAsUpper = \'DUP\' ifTrue: [result := handler dup: stack].\r\t\twordAsUpper = \'DROP\' ifTrue: [handler drop: stack].\r\t\twordAsUpper = \'SWAP\' ifTrue: [result := handler swap: stack].\r\t\twordAsUpper = \'OVER\' ifTrue: [result := handler over: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^stack.',			#stamp : 'AndyMarks 12/19/2023 19:00',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T19:02:34.845412+11:00' ],		#prior : OmReference [ '706' ],		#self : OmReference [ '707' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'doLineOf:',			#protocol : #'instance creation',			#sourceCode : 'doLineOf: elements\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| stack handler |\r\t\r\tstack := Stack new.\r\thandler := ForthWord new.\r\t\r\t(elements matchesRegex: \'\\: (.*) (.*) ;\')\r\t\tifTrue: [ \'found a user defined word\' inspect].\r\t\r\telements splitOn: Character space do: [ :word | \r\t\t| result wordAsUpper  |\r\t\twordAsUpper := word asUppercase.\r\t\t(NumberParser isNumber: word) ifTrue: [ result := word asNumber ].\r\t\tword = \'+\' ifTrue: [result := handler add: stack].\r\t\tword = \'-\' ifTrue: [result := handler subtract: stack].\r\t\tword = \'*\' ifTrue: [result := handler multiply: stack].\r\t\tword = \'/\' ifTrue: [result := handler divide: stack].\r\t\twordAsUpper = \'DUP\' ifTrue: [result := handler dup: stack].\r\t\twordAsUpper = \'DROP\' ifTrue: [handler drop: stack].\r\t\twordAsUpper = \'SWAP\' ifTrue: [result := handler swap: stack].\r\t\twordAsUpper = \'OVER\' ifTrue: [result := handler over: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^stack.',			#stamp : 'AndyMarks 12/19/2023 19:00',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'doLineOf:',			#protocol : #'instance creation',			#sourceCode : 'doLineOf: elements\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| stack handler userDefinedWord |\r\t\r\tstack := Stack new.\r\thandler := ForthWord new.\r\tuserDefinedWord := \'\\: (.*) (.*) ;\' asRegex.\r\t\r\t(elements matchesRegex: \'\\: (.*) (.*) ;\')\r\t\tifTrue: [ \'found a user defined word\' inspect].\r\t\r\telements splitOn: Character space do: [ :word | \r\t\t| result wordAsUpper  |\r\t\twordAsUpper := word asUppercase.\r\t\t(NumberParser isNumber: word) ifTrue: [ result := word asNumber ].\r\t\tword = \'+\' ifTrue: [result := handler add: stack].\r\t\tword = \'-\' ifTrue: [result := handler subtract: stack].\r\t\tword = \'*\' ifTrue: [result := handler multiply: stack].\r\t\tword = \'/\' ifTrue: [result := handler divide: stack].\r\t\twordAsUpper = \'DUP\' ifTrue: [result := handler dup: stack].\r\t\twordAsUpper = \'DROP\' ifTrue: [handler drop: stack].\r\t\twordAsUpper = \'SWAP\' ifTrue: [result := handler swap: stack].\r\t\twordAsUpper = \'OVER\' ifTrue: [result := handler over: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^stack.',			#stamp : 'AndyMarks 12/19/2023 19:02',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T19:05:00.685397+11:00' ],		#prior : OmReference [ '707' ],		#self : OmReference [ '708' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'doLineOf:',			#protocol : #'instance creation',			#sourceCode : 'doLineOf: elements\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| stack handler userDefinedWord |\r\t\r\tstack := Stack new.\r\thandler := ForthWord new.\r\tuserDefinedWord := \'\\: (.*) (.*) ;\' asRegex.\r\t\r\t(elements matchesRegex: \'\\: (.*) (.*) ;\')\r\t\tifTrue: [ \'found a user defined word\' inspect].\r\t\r\telements splitOn: Character space do: [ :word | \r\t\t| result wordAsUpper  |\r\t\twordAsUpper := word asUppercase.\r\t\t(NumberParser isNumber: word) ifTrue: [ result := word asNumber ].\r\t\tword = \'+\' ifTrue: [result := handler add: stack].\r\t\tword = \'-\' ifTrue: [result := handler subtract: stack].\r\t\tword = \'*\' ifTrue: [result := handler multiply: stack].\r\t\tword = \'/\' ifTrue: [result := handler divide: stack].\r\t\twordAsUpper = \'DUP\' ifTrue: [result := handler dup: stack].\r\t\twordAsUpper = \'DROP\' ifTrue: [handler drop: stack].\r\t\twordAsUpper = \'SWAP\' ifTrue: [result := handler swap: stack].\r\t\twordAsUpper = \'OVER\' ifTrue: [result := handler over: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^stack.',			#stamp : 'AndyMarks 12/19/2023 19:02',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'doLineOf:',			#protocol : #'instance creation',			#sourceCode : 'doLineOf: elements\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| stack handler userDefinedWord |\r\t\r\tstack := Stack new.\r\thandler := ForthWord new.\r\tuserDefinedWord := \'^\\: (.*) (.*) ;$\' asRegex.\r\t\r\t(elements matchesRegex: userDefinedWord)\r\t\tifTrue: [ \'found a user defined word\' inspect].\r\t\r\telements splitOn: Character space do: [ :word | \r\t\t| result wordAsUpper  |\r\t\twordAsUpper := word asUppercase.\r\t\t(NumberParser isNumber: word) ifTrue: [ result := word asNumber ].\r\t\tword = \'+\' ifTrue: [result := handler add: stack].\r\t\tword = \'-\' ifTrue: [result := handler subtract: stack].\r\t\tword = \'*\' ifTrue: [result := handler multiply: stack].\r\t\tword = \'/\' ifTrue: [result := handler divide: stack].\r\t\twordAsUpper = \'DUP\' ifTrue: [result := handler dup: stack].\r\t\twordAsUpper = \'DROP\' ifTrue: [handler drop: stack].\r\t\twordAsUpper = \'SWAP\' ifTrue: [result := handler swap: stack].\r\t\twordAsUpper = \'OVER\' ifTrue: [result := handler over: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^stack.',			#stamp : 'AndyMarks 12/19/2023 19:05',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T19:05:26.641616+11:00' ],		#prior : OmReference [ '708' ],		#self : OmReference [ '709' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'doLineOf:',			#protocol : #'instance creation',			#sourceCode : 'doLineOf: elements\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| stack handler userDefinedWord |\r\t\r\tstack := Stack new.\r\thandler := ForthWord new.\r\tuserDefinedWord := \'^\\: (.*) (.*) ;$\' asRegex.\r\t\r\t(elements matchesRegex: userDefinedWord)\r\t\tifTrue: [ \'found a user defined word\' inspect].\r\t\r\telements splitOn: Character space do: [ :word | \r\t\t| result wordAsUpper  |\r\t\twordAsUpper := word asUppercase.\r\t\t(NumberParser isNumber: word) ifTrue: [ result := word asNumber ].\r\t\tword = \'+\' ifTrue: [result := handler add: stack].\r\t\tword = \'-\' ifTrue: [result := handler subtract: stack].\r\t\tword = \'*\' ifTrue: [result := handler multiply: stack].\r\t\tword = \'/\' ifTrue: [result := handler divide: stack].\r\t\twordAsUpper = \'DUP\' ifTrue: [result := handler dup: stack].\r\t\twordAsUpper = \'DROP\' ifTrue: [handler drop: stack].\r\t\twordAsUpper = \'SWAP\' ifTrue: [result := handler swap: stack].\r\t\twordAsUpper = \'OVER\' ifTrue: [result := handler over: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^stack.',			#stamp : 'AndyMarks 12/19/2023 19:05',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'doLineOf:',			#protocol : #'instance creation',			#sourceCode : 'doLineOf: elements\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| stack handler |\r\t\r\tstack := Stack new.\r\thandler := ForthWord new.\r\t\r\t(elements matchesRegex: \'^\\: (.*) (.*) ;$\')\r\t\tifTrue: [ \'found a user defined word\' inspect].\r\t\r\telements splitOn: Character space do: [ :word | \r\t\t| result wordAsUpper  |\r\t\twordAsUpper := word asUppercase.\r\t\t(NumberParser isNumber: word) ifTrue: [ result := word asNumber ].\r\t\tword = \'+\' ifTrue: [result := handler add: stack].\r\t\tword = \'-\' ifTrue: [result := handler subtract: stack].\r\t\tword = \'*\' ifTrue: [result := handler multiply: stack].\r\t\tword = \'/\' ifTrue: [result := handler divide: stack].\r\t\twordAsUpper = \'DUP\' ifTrue: [result := handler dup: stack].\r\t\twordAsUpper = \'DROP\' ifTrue: [handler drop: stack].\r\t\twordAsUpper = \'SWAP\' ifTrue: [result := handler swap: stack].\r\t\twordAsUpper = \'OVER\' ifTrue: [result := handler over: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^stack.',			#stamp : 'AndyMarks 12/19/2023 19:05',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T19:11:38.572711+11:00' ],		#prior : OmReference [ '709' ],		#self : OmReference [ '710' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'doLineOf:',			#protocol : #'instance creation',			#sourceCode : 'doLineOf: elements\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| stack handler |\r\t\r\tstack := Stack new.\r\thandler := ForthWord new.\r\t\r\t(elements matchesRegex: \'^\\: (.*) (.*) ;$\')\r\t\tifTrue: [ \'found a user defined word\' inspect].\r\t\r\telements splitOn: Character space do: [ :word | \r\t\t| result wordAsUpper  |\r\t\twordAsUpper := word asUppercase.\r\t\t(NumberParser isNumber: word) ifTrue: [ result := word asNumber ].\r\t\tword = \'+\' ifTrue: [result := handler add: stack].\r\t\tword = \'-\' ifTrue: [result := handler subtract: stack].\r\t\tword = \'*\' ifTrue: [result := handler multiply: stack].\r\t\tword = \'/\' ifTrue: [result := handler divide: stack].\r\t\twordAsUpper = \'DUP\' ifTrue: [result := handler dup: stack].\r\t\twordAsUpper = \'DROP\' ifTrue: [handler drop: stack].\r\t\twordAsUpper = \'SWAP\' ifTrue: [result := handler swap: stack].\r\t\twordAsUpper = \'OVER\' ifTrue: [result := handler over: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^stack.',			#stamp : 'AndyMarks 12/19/2023 19:09',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'doLineOf:',			#protocol : #'instance creation',			#sourceCode : 'doLineOf: elements\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| stack handler |\r\t\r\tstack := Stack new.\r\thandler := ForthWord new.\r\t\r\t(elements matchesRegex: \'^\\: (.*) (.*) ;$\')\r\t\tifTrue: [ \'found a user defined word\' inspect]\r\t\tifFalse: [ self handleLine: elements withStack: stack]\r\t\r\telements splitOn: Character space do: [ :word | \r\t\t| result wordAsUpper  |\r\t\twordAsUpper := word asUppercase.\r\t\t(NumberParser isNumber: word) ifTrue: [ result := word asNumber ].\r\t\tword = \'+\' ifTrue: [result := handler add: stack].\r\t\tword = \'-\' ifTrue: [result := handler subtract: stack].\r\t\tword = \'*\' ifTrue: [result := handler multiply: stack].\r\t\tword = \'/\' ifTrue: [result := handler divide: stack].\r\t\twordAsUpper = \'DUP\' ifTrue: [result := handler dup: stack].\r\t\twordAsUpper = \'DROP\' ifTrue: [handler drop: stack].\r\t\twordAsUpper = \'SWAP\' ifTrue: [result := handler swap: stack].\r\t\twordAsUpper = \'OVER\' ifTrue: [result := handler over: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^stack.',			#stamp : 'AndyMarks 12/19/2023 19:11',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T19:11:55.634862+11:00' ],		#prior : OmReference [ '710' ],		#self : OmReference [ '711' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'doLineOf:',			#protocol : #'instance creation',			#sourceCode : 'doLineOf: elements\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| stack handler |\r\t\r\tstack := Stack new.\r\thandler := ForthWord new.\r\t\r\t(elements matchesRegex: \'^\\: (.*) (.*) ;$\')\r\t\tifTrue: [ \'found a user defined word\' inspect]\r\t\tifFalse: [ self handleLine: elements withStack: stack]\r\t\r\telements splitOn: Character space do: [ :word | \r\t\t| result wordAsUpper  |\r\t\twordAsUpper := word asUppercase.\r\t\t(NumberParser isNumber: word) ifTrue: [ result := word asNumber ].\r\t\tword = \'+\' ifTrue: [result := handler add: stack].\r\t\tword = \'-\' ifTrue: [result := handler subtract: stack].\r\t\tword = \'*\' ifTrue: [result := handler multiply: stack].\r\t\tword = \'/\' ifTrue: [result := handler divide: stack].\r\t\twordAsUpper = \'DUP\' ifTrue: [result := handler dup: stack].\r\t\twordAsUpper = \'DROP\' ifTrue: [handler drop: stack].\r\t\twordAsUpper = \'SWAP\' ifTrue: [result := handler swap: stack].\r\t\twordAsUpper = \'OVER\' ifTrue: [result := handler over: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^stack.',			#stamp : 'AndyMarks 12/19/2023 19:11',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'doLineOf:',			#protocol : #'instance creation',			#sourceCode : 'doLineOf: elements\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| stack handler |\r\t\r\tstack := Stack new.\r\thandler := ForthWord new.\r\t\r\t(elements matchesRegex: \'^\\: (.*) (.*) ;$\')\r\t\tifTrue: [ \'found a user defined word\' inspect]\r\t\tifFalse: [ self handleLine: elements withStack: stack].\r\r\t^stack.',			#stamp : 'AndyMarks 12/19/2023 19:11',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T19:13:15.591938+11:00' ],		#prior : OmReference [ '711' ],		#self : OmReference [ '712' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'doLineOf:',			#protocol : #'instance creation',			#sourceCode : 'doLineOf: elements\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| stack handler |\r\t\r\tstack := Stack new.\r\thandler := ForthWord new.\r\t\r\t(elements matchesRegex: \'^\\: (.*) (.*) ;$\')\r\t\tifTrue: [ \'found a user defined word\' inspect]\r\t\tifFalse: [ self handleLine: elements withStack: stack].\r\r\t^stack.',			#stamp : 'AndyMarks 12/19/2023 19:11',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'doLineOf:',			#protocol : #'instance creation',			#sourceCode : 'doLineOf: elements\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| stack handler |\r\t\r\tstack := Stack new.\r\t\r\t(elements matchesRegex: \'^\\: (.*) (.*) ;$\')\r\t\tifTrue: [ \'found a user defined word\' inspect]\r\t\tifFalse: [ self handleLine: elements withStack: stack].\r\r\t^stack.',			#stamp : 'AndyMarks 12/19/2023 19:13',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T19:13:33.8387+11:00' ],		#prior : OmReference [ '712' ],		#self : OmReference [ '713' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'handleLine:withStack:',			#protocol : #'as yet unclassified',			#sourceCode : 'handleLine: elements withStack: stack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| handler |\t\r\t\thandler := ForthWord new.\r\r\telements splitOn: Character space do: [ :word | \r\t\t| result wordAsUpper  |\r\t\twordAsUpper := word asUppercase.\r\t\t(NumberParser isNumber: word) ifTrue: [ result := word asNumber ].\r\t\tword = \'+\' ifTrue: [result := handler add: stack].\r\t\tword = \'-\' ifTrue: [result := handler subtract: stack].\r\t\tword = \'*\' ifTrue: [result := handler multiply: stack].\r\t\tword = \'/\' ifTrue: [result := handler divide: stack].\r\t\twordAsUpper = \'DUP\' ifTrue: [result := handler dup: stack].\r\t\twordAsUpper = \'DROP\' ifTrue: [handler drop: stack].\r\t\twordAsUpper = \'SWAP\' ifTrue: [result := handler swap: stack].\r\t\twordAsUpper = \'OVER\' ifTrue: [result := handler over: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r',			#stamp : 'AndyMarks 12/19/2023 19:13',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T19:13:38.586776+11:00' ],		#prior : OmReference [ '713' ],		#self : OmReference [ '714' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'handleLine:withStack:',			#protocol : #'as yet unclassified',			#sourceCode : 'handleLine: elements withStack: stack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| handler |\t\r\t\thandler := ForthWord new.\r\r\telements splitOn: Character space do: [ :word | \r\t\t| result wordAsUpper  |\r\t\twordAsUpper := word asUppercase.\r\t\t(NumberParser isNumber: word) ifTrue: [ result := word asNumber ].\r\t\tword = \'+\' ifTrue: [result := handler add: stack].\r\t\tword = \'-\' ifTrue: [result := handler subtract: stack].\r\t\tword = \'*\' ifTrue: [result := handler multiply: stack].\r\t\tword = \'/\' ifTrue: [result := handler divide: stack].\r\t\twordAsUpper = \'DUP\' ifTrue: [result := handler dup: stack].\r\t\twordAsUpper = \'DROP\' ifTrue: [handler drop: stack].\r\t\twordAsUpper = \'SWAP\' ifTrue: [result := handler swap: stack].\r\t\twordAsUpper = \'OVER\' ifTrue: [result := handler over: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r',			#stamp : 'AndyMarks 12/19/2023 19:13',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'handleLine:withStack:',			#protocol : #'as yet unclassified',			#sourceCode : 'handleLine: elements withStack: stack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| handler |\t\r\thandler := ForthWord new.\r\r\telements splitOn: Character space do: [ :word | \r\t\t| result wordAsUpper  |\r\t\twordAsUpper := word asUppercase.\r\t\t(NumberParser isNumber: word) ifTrue: [ result := word asNumber ].\r\t\tword = \'+\' ifTrue: [result := handler add: stack].\r\t\tword = \'-\' ifTrue: [result := handler subtract: stack].\r\t\tword = \'*\' ifTrue: [result := handler multiply: stack].\r\t\tword = \'/\' ifTrue: [result := handler divide: stack].\r\t\twordAsUpper = \'DUP\' ifTrue: [result := handler dup: stack].\r\t\twordAsUpper = \'DROP\' ifTrue: [handler drop: stack].\r\t\twordAsUpper = \'SWAP\' ifTrue: [result := handler swap: stack].\r\t\twordAsUpper = \'OVER\' ifTrue: [result := handler over: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r',			#stamp : 'AndyMarks 12/19/2023 19:13',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T19:13:43.89673+11:00' ],		#prior : OmReference [ '714' ],		#self : OmReference [ '715' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'handleLine:withStack:',			#protocol : #'as yet unclassified',			#sourceCode : 'handleLine: elements withStack: stack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| handler |\t\r\thandler := ForthWord new.\r\r\telements splitOn: Character space do: [ :word | \r\t\t| result wordAsUpper  |\r\t\twordAsUpper := word asUppercase.\r\t\t(NumberParser isNumber: word) ifTrue: [ result := word asNumber ].\r\t\tword = \'+\' ifTrue: [result := handler add: stack].\r\t\tword = \'-\' ifTrue: [result := handler subtract: stack].\r\t\tword = \'*\' ifTrue: [result := handler multiply: stack].\r\t\tword = \'/\' ifTrue: [result := handler divide: stack].\r\t\twordAsUpper = \'DUP\' ifTrue: [result := handler dup: stack].\r\t\twordAsUpper = \'DROP\' ifTrue: [handler drop: stack].\r\t\twordAsUpper = \'SWAP\' ifTrue: [result := handler swap: stack].\r\t\twordAsUpper = \'OVER\' ifTrue: [result := handler over: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r',			#stamp : 'AndyMarks 12/19/2023 19:13',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'handleLine:withStack:',			#protocol : #'as yet unclassified',			#sourceCode : 'handleLine: elements withStack: stack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| handler |\t\r\thandler := ForthWord new.\r\r\telements splitOn: Character space do: [ :word | \r\t\t| result wordAsUpper  |\r\t\twordAsUpper := word asUppercase.\r\t\t(NumberParser isNumber: word) ifTrue: [ result := word asNumber ].\r\t\tword = \'+\' ifTrue: [result := handler add: stack].\r\t\tword = \'-\' ifTrue: [result := handler subtract: stack].\r\t\tword = \'*\' ifTrue: [result := handler multiply: stack].\r\t\tword = \'/\' ifTrue: [result := handler divide: stack].\r\t\twordAsUpper = \'DUP\' ifTrue: [result := handler dup: stack].\r\t\twordAsUpper = \'DROP\' ifTrue: [handler drop: stack].\r\t\twordAsUpper = \'SWAP\' ifTrue: [result := handler swap: stack].\r\t\twordAsUpper = \'OVER\' ifTrue: [result := handler over: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^stack.',			#stamp : 'AndyMarks 12/19/2023 19:13',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T19:14:38.771335+11:00' ],		#prior : OmReference [ '715' ],		#self : OmReference [ '716' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'doLineOf:',			#protocol : #'instance creation',			#sourceCode : 'doLineOf: elements\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| stack handler |\r\t\r\tstack := Stack new.\r\t\r\t(elements matchesRegex: \'^\\: (.*) (.*) ;$\')\r\t\tifTrue: [ \'found a user defined word\' inspect]\r\t\tifFalse: [ self handleLine: elements withStack: stack].\r\r\t^stack.',			#stamp : 'AndyMarks 12/19/2023 19:13',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'doLineOf:',			#protocol : #'instance creation',			#sourceCode : 'doLineOf: elements\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| stack |\r\t\r\tstack := Stack new.\r\t\r\t(elements matchesRegex: \'^\\: (.*) (.*) ;$\')\r\t\tifTrue: [ \'found a user defined word\' inspect]\r\t\tifFalse: [ self handleLine: elements withStack: stack].\r\r\t^stack.',			#stamp : 'AndyMarks 12/19/2023 19:14',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T19:15:26.42627+11:00' ],		#prior : OmReference [ '716' ],		#self : OmReference [ '717' ]	},	#content : EpGenericRefactoring {		#storeString : '(RBRenameArgumentOrTemporaryRefactoring renameTemporaryFrom: (23 to: 40) to: \'instructionLines\' in: Forth selector: #evaluateInstructions:)'	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '717' ],		#self : OmReference [ '718' ],		#time : DateAndTime [ '2023-12-19T19:15:26.45411+11:00' ],		#trigger : @3	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: anInstructionArray\r\r\t"comment stating purpose of instance-side method"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| stack |\r\tanInstructionArray do: [ :elements |\r\t\tstack := self doLineOf: elements.\r\t\t].\r\r\t^ stack reversed asArray',			#stamp : 'AndyMarks 12/19/2023 18:43',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: instructionLines\r\r\t"comment stating purpose of instance-side method"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| stack |\r\tinstructionLines do: [ :elements |\r\t\tstack := self doLineOf: elements.\r\t\t].\r\r\t^ stack reversed asArray',			#stamp : 'AndyMarks 12/19/2023 19:15',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-19T19:16:06.28144+11:00' ],		#prior : OmReference [ '718' ],		#self : OmReference [ '719' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'handleLine:withStack:',			#protocol : #'as yet unclassified',			#sourceCode : 'handleLine: elements withStack: stack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| handler |\t\r\thandler := ForthWord new.\r\r\telements splitOn: Character space do: [ :word | \r\t\t| result wordAsUpper  |\r\t\twordAsUpper := word asUppercase.\r\t\t(NumberParser isNumber: word) ifTrue: [ result := word asNumber ].\r\t\tword = \'+\' ifTrue: [result := handler add: stack].\r\t\tword = \'-\' ifTrue: [result := handler subtract: stack].\r\t\tword = \'*\' ifTrue: [result := handler multiply: stack].\r\t\tword = \'/\' ifTrue: [result := handler divide: stack].\r\t\twordAsUpper = \'DUP\' ifTrue: [result := handler dup: stack].\r\t\twordAsUpper = \'DROP\' ifTrue: [handler drop: stack].\r\t\twordAsUpper = \'SWAP\' ifTrue: [result := handler swap: stack].\r\t\twordAsUpper = \'OVER\' ifTrue: [result := handler over: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^stack.',			#stamp : 'AndyMarks 12/19/2023 19:13',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'handleLine:withStack:',			#protocol : #'process actions',			#sourceCode : 'handleLine: elements withStack: stack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| handler |\t\r\thandler := ForthWord new.\r\r\telements splitOn: Character space do: [ :word | \r\t\t| result wordAsUpper  |\r\t\twordAsUpper := word asUppercase.\r\t\t(NumberParser isNumber: word) ifTrue: [ result := word asNumber ].\r\t\tword = \'+\' ifTrue: [result := handler add: stack].\r\t\tword = \'-\' ifTrue: [result := handler subtract: stack].\r\t\tword = \'*\' ifTrue: [result := handler multiply: stack].\r\t\tword = \'/\' ifTrue: [result := handler divide: stack].\r\t\twordAsUpper = \'DUP\' ifTrue: [result := handler dup: stack].\r\t\twordAsUpper = \'DROP\' ifTrue: [handler drop: stack].\r\t\twordAsUpper = \'SWAP\' ifTrue: [result := handler swap: stack].\r\t\twordAsUpper = \'OVER\' ifTrue: [result := handler over: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^stack.',			#stamp : 'AndyMarks 12/19/2023 19:13',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-20T08:36:52.955452+11:00' ],		#prior : OmReference [ '719' ],		#self : OmReference [ '720' ]	},	#content : EpGenericRefactoring {		#storeString : '(RBRenameArgumentOrTemporaryRefactoring renameTemporaryFrom: (179 to: 186) to: \'instruction\' in: Forth selector: #evaluateInstructions:)'	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '720' ],		#self : OmReference [ '721' ],		#time : DateAndTime [ '2023-12-20T08:36:52.983388+11:00' ],		#trigger : @3	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: instructionLines\r\r\t"comment stating purpose of instance-side method"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| stack |\r\tinstructionLines do: [ :elements |\r\t\tstack := self doLineOf: elements.\r\t\t].\r\r\t^ stack reversed asArray',			#stamp : 'AndyMarks 12/19/2023 19:15',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: instructionLines\r\r\t"comment stating purpose of instance-side method"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| stack |\r\tinstructionLines do: [ :instruction |\r\t\tstack := self doLineOf: instruction.\r\t\t].\r\r\t^ stack reversed asArray',			#stamp : 'AndyMarks 12/20/2023 08:36',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-20T08:37:16.898781+11:00' ],		#prior : OmReference [ '721' ],		#self : OmReference [ '722' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: instructionLines\r\r\t"comment stating purpose of instance-side method"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| stack |\r\tinstructionLines do: [ :instruction |\r\t\tstack := self doLineOf: instruction.\r\t\t].\r\r\t^ stack reversed asArray',			#stamp : 'AndyMarks 12/20/2023 08:36',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: instructionArray\r\r\t"comment stating purpose of instance-side method"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| stack |\r\tinstructionArray do: [ :elements |\r\t\tstack := self doLineOf: elements.\r\t\t].\r\r\t^ stack reversed asArray',			#stamp : 'AndyMarks 12/20/2023 08:37',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-20T08:37:39.923311+11:00' ],		#prior : OmReference [ '722' ],		#self : OmReference [ '723' ]	},	#content : EpGenericRefactoring {		#storeString : '(RBRenameArgumentOrTemporaryRefactoring renameTemporaryFrom: (179 to: 186) to: \'instruction\' in: Forth selector: #evaluateInstructions:)'	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '723' ],		#self : OmReference [ '724' ],		#time : DateAndTime [ '2023-12-20T08:37:39.931374+11:00' ],		#trigger : @3	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: instructionArray\r\r\t"comment stating purpose of instance-side method"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| stack |\r\tinstructionArray do: [ :elements |\r\t\tstack := self doLineOf: elements.\r\t\t].\r\r\t^ stack reversed asArray',			#stamp : 'AndyMarks 12/20/2023 08:37',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: instructionArray\r\r\t"comment stating purpose of instance-side method"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| stack |\r\tinstructionArray do: [ :instruction |\r\t\tstack := self doLineOf: instruction.\r\t\t].\r\r\t^ stack reversed asArray',			#stamp : 'AndyMarks 12/20/2023 08:37',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-20T08:38:06.232488+11:00' ],		#prior : OmReference [ '724' ],		#self : OmReference [ '725' ]	},	#content : EpRenameMethodRefactoring {		#oldSelector : #'doLineOf:',		#newSelector : #'evaluateInstruction:',		#affectedClassName : 'RBMessageNode(self doLineOf: instruction)'	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '725' ],		#self : OmReference [ '726' ],		#time : DateAndTime [ '2023-12-20T08:38:06.248664+11:00' ],		#trigger : @3	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstruction:',			#protocol : #'instance creation',			#sourceCode : 'evaluateInstruction: elements\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| stack |\r\t\r\tstack := Stack new.\r\t\r\t(elements matchesRegex: \'^\\: (.*) (.*) ;$\')\r\t\tifTrue: [ \'found a user defined word\' inspect]\r\t\tifFalse: [ self handleLine: elements withStack: stack].\r\r\t^stack.',			#stamp : 'AndyMarks 12/20/2023 08:38',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '726' ],		#self : OmReference [ '727' ],		#time : DateAndTime [ '2023-12-20T08:38:06.25252+11:00' ],		#trigger : OmReference [ '725' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ManifestExerciseForth class',				#isMetaSide : true			},			#name : #ruleUsesAddRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleUsesAddRuleV1FalsePositive\r\t^ #(#(#(#RGMethodDefinition #(#Forth #doLineOf: #false)) #\'2023-12-19T18:48:21.664784+11:00\') )',			#stamp : 'AndyMarks 12/19/2023 18:48',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ManifestExerciseForth class',				#isMetaSide : true			},			#name : #ruleUsesAddRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleUsesAddRuleV1FalsePositive\r\t^ #(#(#(#RGMethodDefinition #(#Forth #evaluateInstruction: #false)) #\'2023-12-19T18:48:21.664784+11:00\') )',			#stamp : 'AndyMarks 12/20/2023 08:38',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '727' ],		#self : OmReference [ '728' ],		#time : DateAndTime [ '2023-12-20T08:38:06.256527+11:00' ],		#trigger : OmReference [ '725' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: instructionArray\r\r\t"comment stating purpose of instance-side method"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| stack |\r\tinstructionArray do: [ :instruction |\r\t\tstack := self doLineOf: instruction.\r\t\t].\r\r\t^ stack reversed asArray',			#stamp : 'AndyMarks 12/20/2023 08:37',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: instructionArray\r\r\t"comment stating purpose of instance-side method"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| stack |\r\tinstructionArray do: [ :instruction |\r\t\tstack := self evaluateInstruction: instruction.\r\t\t].\r\r\t^ stack reversed asArray',			#stamp : 'AndyMarks 12/20/2023 08:38',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '728' ],		#self : OmReference [ '729' ],		#time : DateAndTime [ '2023-12-20T08:38:06.294834+11:00' ],		#trigger : OmReference [ '725' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'doLineOf:',			#protocol : #'instance creation',			#sourceCode : 'doLineOf: elements\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| stack |\r\t\r\tstack := Stack new.\r\t\r\t(elements matchesRegex: \'^\\: (.*) (.*) ;$\')\r\t\tifTrue: [ \'found a user defined word\' inspect]\r\t\tifFalse: [ self handleLine: elements withStack: stack].\r\r\t^stack.',			#stamp : 'AndyMarks 12/19/2023 19:14',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'doLineOf:',			#protocol : #'as yet unclassified',			#sourceCode : 'doLineOf: elements\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| stack |\r\t\r\tstack := Stack new.\r\t\r\t(elements matchesRegex: \'^\\: (.*) (.*) ;$\')\r\t\tifTrue: [ \'found a user defined word\' inspect]\r\t\tifFalse: [ self handleLine: elements withStack: stack].\r\r\t^stack.',			#stamp : 'AndyMarks 12/19/2023 19:14',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '729' ],		#self : OmReference [ '730' ],		#time : DateAndTime [ '2023-12-20T08:38:06.299587+11:00' ],		#trigger : OmReference [ '725' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'doLineOf:',			#protocol : #'instance creation',			#sourceCode : 'doLineOf: elements\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| stack |\r\t\r\tstack := Stack new.\r\t\r\t(elements matchesRegex: \'^\\: (.*) (.*) ;$\')\r\t\tifTrue: [ \'found a user defined word\' inspect]\r\t\tifFalse: [ self handleLine: elements withStack: stack].\r\r\t^stack.',			#stamp : 'AndyMarks 12/19/2023 19:14',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-20T08:38:27.767829+11:00' ],		#prior : OmReference [ '730' ],		#self : OmReference [ '731' ]	},	#content : EpGenericRefactoring {		#storeString : '(RBRenameArgumentOrTemporaryRefactoring renameTemporaryFrom: (22 to: 29) to: \'instruction\' in: Forth selector: #evaluateInstruction:)'	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '731' ],		#self : OmReference [ '732' ],		#time : DateAndTime [ '2023-12-20T08:38:27.792031+11:00' ],		#trigger : @3	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstruction:',			#protocol : #'instance creation',			#sourceCode : 'evaluateInstruction: elements\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| stack |\r\t\r\tstack := Stack new.\r\t\r\t(elements matchesRegex: \'^\\: (.*) (.*) ;$\')\r\t\tifTrue: [ \'found a user defined word\' inspect]\r\t\tifFalse: [ self handleLine: elements withStack: stack].\r\r\t^stack.',			#stamp : 'AndyMarks 12/20/2023 08:38',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstruction:',			#protocol : #'instance creation',			#sourceCode : 'evaluateInstruction: instruction\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| stack |\r\t\r\tstack := Stack new.\r\t\r\t(instruction matchesRegex: \'^\\: (.*) (.*) ;$\')\r\t\tifTrue: [ \'found a user defined word\' inspect]\r\t\tifFalse: [ self handleLine: instruction withStack: stack].\r\r\t^stack.',			#stamp : 'AndyMarks 12/20/2023 08:38',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-20T08:39:38.05943+11:00' ],		#prior : OmReference [ '732' ],		#self : OmReference [ '733' ]	},	#content : EpRenameMethodRefactoring {		#oldSelector : #'handleLine:withStack:',		#newSelector : #'evaluateInstruction:withStack:',		#affectedClassName : 'RBMessageNode(self handleLine: instruction withStack: stack)'	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '733' ],		#self : OmReference [ '734' ],		#time : DateAndTime [ '2023-12-20T08:39:38.080419+11:00' ],		#trigger : @3	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstruction:withStack:',			#protocol : #'process actions',			#sourceCode : 'evaluateInstruction: elements withStack: stack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| handler |\t\r\thandler := ForthWord new.\r\r\telements splitOn: Character space do: [ :word | \r\t\t| result wordAsUpper  |\r\t\twordAsUpper := word asUppercase.\r\t\t(NumberParser isNumber: word) ifTrue: [ result := word asNumber ].\r\t\tword = \'+\' ifTrue: [result := handler add: stack].\r\t\tword = \'-\' ifTrue: [result := handler subtract: stack].\r\t\tword = \'*\' ifTrue: [result := handler multiply: stack].\r\t\tword = \'/\' ifTrue: [result := handler divide: stack].\r\t\twordAsUpper = \'DUP\' ifTrue: [result := handler dup: stack].\r\t\twordAsUpper = \'DROP\' ifTrue: [handler drop: stack].\r\t\twordAsUpper = \'SWAP\' ifTrue: [result := handler swap: stack].\r\t\twordAsUpper = \'OVER\' ifTrue: [result := handler over: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^stack.',			#stamp : 'AndyMarks 12/20/2023 08:39',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '734' ],		#self : OmReference [ '735' ],		#time : DateAndTime [ '2023-12-20T08:39:38.086061+11:00' ],		#trigger : OmReference [ '733' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstruction:',			#protocol : #'instance creation',			#sourceCode : 'evaluateInstruction: instruction\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| stack |\r\t\r\tstack := Stack new.\r\t\r\t(instruction matchesRegex: \'^\\: (.*) (.*) ;$\')\r\t\tifTrue: [ \'found a user defined word\' inspect]\r\t\tifFalse: [ self handleLine: instruction withStack: stack].\r\r\t^stack.',			#stamp : 'AndyMarks 12/20/2023 08:38',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstruction:',			#protocol : #'instance creation',			#sourceCode : 'evaluateInstruction: instruction\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| stack |\r\t\r\tstack := Stack new.\r\t\r\t(instruction matchesRegex: \'^\\: (.*) (.*) ;$\')\r\t\tifTrue: [ \'found a user defined word\' inspect]\r\t\tifFalse: [ self evaluateInstruction: instruction withStack: stack].\r\r\t^stack.',			#stamp : 'AndyMarks 12/20/2023 08:39',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '735' ],		#self : OmReference [ '736' ],		#time : DateAndTime [ '2023-12-20T08:39:38.123297+11:00' ],		#trigger : OmReference [ '733' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'handleLine:withStack:',			#protocol : #'process actions',			#sourceCode : 'handleLine: elements withStack: stack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| handler |\t\r\thandler := ForthWord new.\r\r\telements splitOn: Character space do: [ :word | \r\t\t| result wordAsUpper  |\r\t\twordAsUpper := word asUppercase.\r\t\t(NumberParser isNumber: word) ifTrue: [ result := word asNumber ].\r\t\tword = \'+\' ifTrue: [result := handler add: stack].\r\t\tword = \'-\' ifTrue: [result := handler subtract: stack].\r\t\tword = \'*\' ifTrue: [result := handler multiply: stack].\r\t\tword = \'/\' ifTrue: [result := handler divide: stack].\r\t\twordAsUpper = \'DUP\' ifTrue: [result := handler dup: stack].\r\t\twordAsUpper = \'DROP\' ifTrue: [handler drop: stack].\r\t\twordAsUpper = \'SWAP\' ifTrue: [result := handler swap: stack].\r\t\twordAsUpper = \'OVER\' ifTrue: [result := handler over: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^stack.',			#stamp : 'AndyMarks 12/19/2023 19:13',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'handleLine:withStack:',			#protocol : #'as yet unclassified',			#sourceCode : 'handleLine: elements withStack: stack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| handler |\t\r\thandler := ForthWord new.\r\r\telements splitOn: Character space do: [ :word | \r\t\t| result wordAsUpper  |\r\t\twordAsUpper := word asUppercase.\r\t\t(NumberParser isNumber: word) ifTrue: [ result := word asNumber ].\r\t\tword = \'+\' ifTrue: [result := handler add: stack].\r\t\tword = \'-\' ifTrue: [result := handler subtract: stack].\r\t\tword = \'*\' ifTrue: [result := handler multiply: stack].\r\t\tword = \'/\' ifTrue: [result := handler divide: stack].\r\t\twordAsUpper = \'DUP\' ifTrue: [result := handler dup: stack].\r\t\twordAsUpper = \'DROP\' ifTrue: [handler drop: stack].\r\t\twordAsUpper = \'SWAP\' ifTrue: [result := handler swap: stack].\r\t\twordAsUpper = \'OVER\' ifTrue: [result := handler over: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^stack.',			#stamp : 'AndyMarks 12/19/2023 19:13',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#prior : OmReference [ '736' ],		#self : OmReference [ '737' ],		#time : DateAndTime [ '2023-12-20T08:39:38.128198+11:00' ],		#trigger : OmReference [ '733' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'handleLine:withStack:',			#protocol : #'process actions',			#sourceCode : 'handleLine: elements withStack: stack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| handler |\t\r\thandler := ForthWord new.\r\r\telements splitOn: Character space do: [ :word | \r\t\t| result wordAsUpper  |\r\t\twordAsUpper := word asUppercase.\r\t\t(NumberParser isNumber: word) ifTrue: [ result := word asNumber ].\r\t\tword = \'+\' ifTrue: [result := handler add: stack].\r\t\tword = \'-\' ifTrue: [result := handler subtract: stack].\r\t\tword = \'*\' ifTrue: [result := handler multiply: stack].\r\t\tword = \'/\' ifTrue: [result := handler divide: stack].\r\t\twordAsUpper = \'DUP\' ifTrue: [result := handler dup: stack].\r\t\twordAsUpper = \'DROP\' ifTrue: [handler drop: stack].\r\t\twordAsUpper = \'SWAP\' ifTrue: [result := handler swap: stack].\r\t\twordAsUpper = \'OVER\' ifTrue: [result := handler over: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^stack.',			#stamp : 'AndyMarks 12/19/2023 19:13',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-20T08:40:11.513123+11:00' ],		#prior : OmReference [ '737' ],		#self : OmReference [ '738' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstruction:',			#protocol : #'instance creation',			#sourceCode : 'evaluateInstruction: instruction\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| stack |\r\t\r\tstack := Stack new.\r\t\r\t(instruction matchesRegex: \'^\\: (.*) (.*) ;$\')\r\t\tifTrue: [ \'found a user defined word\' inspect]\r\t\tifFalse: [ self evaluateInstruction: instruction withStack: stack].\r\r\t^stack.',			#stamp : 'AndyMarks 12/20/2023 08:39',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstruction:',			#protocol : #'instance creation',			#sourceCode : 'evaluateInstruction: instruction\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| stack |\r\t\r\tstack := Stack new.\r\t\r\t(instruction matchesRegex: \'^\\: (.*) (.*) ;$\')\r\t\tifTrue: [ self defineCommand: instruction withStack: stack]\r\t\tifFalse: [ self evaluateInstruction: instruction withStack: stack].\r\r\t^stack.',			#stamp : 'AndyMarks 12/20/2023 08:40',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-20T08:41:01.296817+11:00' ],		#prior : OmReference [ '738' ],		#self : OmReference [ '739' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'defineCommand:withStack:',			#protocol : #'process actions',			#sourceCode : 'defineCommand: definition withStack: stack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r',			#stamp : 'AndyMarks 12/20/2023 08:41',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-20T08:41:24.076138+11:00' ],		#prior : OmReference [ '739' ],		#self : OmReference [ '740' ]	},	#content : EpProtocolRemoval {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Forth\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpackage: \'Exercise@Forth\'',				#superclassName : 'Object'			},			#name : #Forth,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Forth class\r\tinstanceVariableNames: \'\''				},				#name : #'Forth class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Forth,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #'Exercise@Forth',			#package : #'Exercise@Forth',			#sharedPools : OrderedCollection [ ]		},		#protocol : #'instance creation'	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-20T08:41:24.089026+11:00' ],		#prior : OmReference [ '740' ],		#self : OmReference [ '741' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstruction:',			#protocol : #'instance creation',			#sourceCode : 'evaluateInstruction: instruction\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| stack |\r\t\r\tstack := Stack new.\r\t\r\t(instruction matchesRegex: \'^\\: (.*) (.*) ;$\')\r\t\tifTrue: [ self defineCommand: instruction withStack: stack]\r\t\tifFalse: [ self evaluateInstruction: instruction withStack: stack].\r\r\t^stack.',			#stamp : 'AndyMarks 12/20/2023 08:40',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstruction:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstruction: instruction\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| stack |\r\t\r\tstack := Stack new.\r\t\r\t(instruction matchesRegex: \'^\\: (.*) (.*) ;$\')\r\t\tifTrue: [ self defineCommand: instruction withStack: stack]\r\t\tifFalse: [ self evaluateInstruction: instruction withStack: stack].\r\r\t^stack.',			#stamp : 'AndyMarks 12/20/2023 08:40',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-20T08:42:52.476484+11:00' ],		#prior : OmReference [ '741' ],		#self : OmReference [ '742' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'defineCommand:withStack:',			#protocol : #'process actions',			#sourceCode : 'defineCommand: definition withStack: stack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r',			#stamp : 'AndyMarks 12/20/2023 08:41',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'defineCommand:withStack:',			#protocol : #'process actions',			#sourceCode : 'defineCommand: definition withStack: stack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| commandName commandBody |\r\t',			#stamp : 'AndyMarks 12/20/2023 08:42',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-20T19:51:58.406007+11:00' ],		#prior : OmReference [ '742' ],		#self : OmReference [ '743' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'defineCommand:withStack:',			#protocol : #'process actions',			#sourceCode : 'defineCommand: definition withStack: stack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| commandName commandBody |\r\t',			#stamp : 'AndyMarks 12/20/2023 08:42',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'defineCommand:withStack:',			#protocol : #'process actions',			#sourceCode : 'defineCommand: definition withStack: stack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| command commandName commandBody |\r\t\r\tcommand := \'[\\w\\-]+\' asRegex.\r\tcommandName := (command matchesIn: definition) first.\r\tcommandBody := (command matchesIn: definition) rest.\r\t\r\t',			#stamp : 'AndyMarks 12/20/2023 19:51',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-20T19:54:23.419164+11:00' ],		#prior : OmReference [ '743' ],		#self : OmReference [ '744' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'defineCommand:withStack:',			#protocol : #'process actions',			#sourceCode : 'defineCommand: definition withStack: stack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| command commandName commandBody |\r\t\r\tcommand := \'[\\w\\-]+\' asRegex.\r\tcommandName := (command matchesIn: definition) first.\r\tcommandBody := (command matchesIn: definition) rest.\r\t\r\t',			#stamp : 'AndyMarks 12/20/2023 19:51',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'defineCommand:withStack:',			#protocol : #'process actions',			#sourceCode : 'defineCommand: definition withStack: stack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| command commandName commandBody |\r\t\r\tcommand := \'[\\w\\-]+\' asRegex.\r\tcommandName := (command matchesIn: definition) first.\r\r\t\r\t',			#stamp : 'AndyMarks 12/20/2023 19:54',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-23T08:50:03.945095+11:00' ],		#prior : OmReference [ '744' ],		#self : OmReference [ '745' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'defineCommand:withStack:',			#protocol : #'process actions',			#sourceCode : 'defineCommand: definition withStack: stack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| command commandName commandBody |\r\t\r\tcommand := \'[\\w\\-]+\' asRegex.\r\tcommandName := (command matchesIn: definition) first.\r\r\t\r\t',			#stamp : 'AndyMarks 12/20/2023 19:54',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'defineCommand:withStack:',			#protocol : #'process actions',			#sourceCode : 'defineCommand: definition withStack: stack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| command commandName commandBody |\r\t\r\tcommand := \'([\\w\\-]+)\\s([\\w\\s]+)\' asRegex.\r\tcommand search: definition.\r\tcommandName := command subexpression: 2.\r\tcommandBody := command subexpression: 3.\r\t\r\t',			#stamp : 'AndyMarks 12/23/2023 08:50',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-23T08:50:51.947411+11:00' ],		#prior : OmReference [ '745' ],		#self : OmReference [ '746' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'defineCommand:withStack:',			#protocol : #'process actions',			#sourceCode : 'defineCommand: definition withStack: stack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| command commandName commandBody |\r\t\r\tcommand := \'([\\w\\-]+)\\s([\\w\\s]+)\' asRegex.\r\tcommand search: definition.\r\tcommandName := command subexpression: 2.\r\tcommandBody := command subexpression: 3.\r\t\r\t',			#stamp : 'AndyMarks 12/23/2023 08:50',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'defineCommand:withStack:',			#protocol : #'process actions',			#sourceCode : 'defineCommand: definition withStack: stack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| command commandName commandBody |\r\t\r\tcommand := \'([\\w\\-]+)\\s([\\w\\s]+)\' asRegex.\r\tcommand search: definition.\r\tcommandName := command subexpression: 2.\r\tcommandBody := command subexpression: 3.\r\t\r\tcommandBody inspect.\r\t\r\t',			#stamp : 'AndyMarks 12/23/2023 08:50',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-23T08:52:14.472414+11:00' ],		#prior : OmReference [ '746' ],		#self : OmReference [ '747' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Forth\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpackage: \'Exercise@Forth\'',				#superclassName : 'Object'			},			#name : #Forth,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Forth class\r\tinstanceVariableNames: \'\''				},				#name : #'Forth class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Forth,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #'Exercise@Forth',			#package : #'Exercise@Forth',			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Forth\r\tinstanceVariableNames: \'userDefinedWords\'\r\tclassVariableNames: \'\'\r\tpackage: \'Exercise@Forth\'',				#superclassName : 'Object'			},			#name : #Forth,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Forth,						#isMetaSide : false					},					#name : #userDefinedWords,					#parent : @21				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Forth class\r\tinstanceVariableNames: \'\''				},				#name : #'Forth class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @21			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Forth,					#isMetaSide : false				},				#parent : @21,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #'Exercise@Forth',			#package : #'Exercise@Forth',			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-23T08:52:59.84975+11:00' ],		#prior : OmReference [ '747' ],		#self : OmReference [ '748' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #new,			#protocol : #'as yet unclassified',			#sourceCode : 'new\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\tuserDefinedWords = Dictionary new.\r\t\r\t^self.',			#stamp : 'AndyMarks 12/23/2023 08:52',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-23T08:52:59.85975+11:00' ],		#prior : OmReference [ '748' ],		#self : OmReference [ '749' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #new,			#protocol : #'as yet unclassified',			#sourceCode : 'new\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\tuserDefinedWords = Dictionary new.\r\t\r\t^self.',			#stamp : 'AndyMarks 12/23/2023 08:52',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'new\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\tuserDefinedWords = Dictionary new.\r\t\r\t^self.',			#stamp : 'AndyMarks 12/23/2023 08:52',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-23T08:53:08.45502+11:00' ],		#prior : OmReference [ '749' ],		#self : OmReference [ '750' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'new\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\tuserDefinedWords = Dictionary new.\r\t\r\t^self.',			#stamp : 'AndyMarks 12/23/2023 08:52',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'new\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\tuserDefinedWords := Dictionary new.\r\t\r\t^self.',			#stamp : 'AndyMarks 12/23/2023 08:53',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-23T08:55:22.250002+11:00' ],		#prior : OmReference [ '750' ],		#self : OmReference [ '751' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'defineCommand:withStack:',			#protocol : #'process actions',			#sourceCode : 'defineCommand: definition withStack: stack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| command commandName commandBody |\r\t\r\tcommand := \'([\\w\\-]+)\\s([\\w\\s]+)\' asRegex.\r\tcommand search: definition.\r\tcommandName := command subexpression: 2.\r\tcommandBody := command subexpression: 3.\r\t\r\tcommandBody inspect.\r\t\r\t',			#stamp : 'AndyMarks 12/23/2023 08:50',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'defineCommand:withStack:',			#protocol : #'process actions',			#sourceCode : 'defineCommand: definition withStack: stack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| command commandName commandBody |\r\t\r\tcommand := \'([\\w\\-]+)\\s([\\w\\s]+)\' asRegex.\r\tcommand search: definition.\r\tcommandName := command subexpression: 2.\r\tcommandBody := command subexpression: 3.\r\t\r\tuserDefinedWords add: commandName -> commandBody .\r\tcommandBody inspect.\r\t\r\t',			#stamp : 'AndyMarks 12/23/2023 08:55',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-23T08:55:25.759818+11:00' ],		#prior : OmReference [ '751' ],		#self : OmReference [ '752' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'defineCommand:withStack:',			#protocol : #'process actions',			#sourceCode : 'defineCommand: definition withStack: stack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| command commandName commandBody |\r\t\r\tcommand := \'([\\w\\-]+)\\s([\\w\\s]+)\' asRegex.\r\tcommand search: definition.\r\tcommandName := command subexpression: 2.\r\tcommandBody := command subexpression: 3.\r\t\r\tuserDefinedWords add: commandName -> commandBody .\r\tcommandBody inspect.\r\t\r\t',			#stamp : 'AndyMarks 12/23/2023 08:55',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'defineCommand:withStack:',			#protocol : #'process actions',			#sourceCode : 'defineCommand: definition withStack: stack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| command commandName commandBody |\r\t\r\tcommand := \'([\\w\\-]+)\\s([\\w\\s]+)\' asRegex.\r\tcommand search: definition.\r\tcommandName := command subexpression: 2.\r\tcommandBody := command subexpression: 3.\r\t\r\tuserDefinedWords add: commandName -> commandBody .\r\t\r\t',			#stamp : 'AndyMarks 12/23/2023 08:55',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-23T08:59:58.089082+11:00' ],		#prior : OmReference [ '752' ],		#self : OmReference [ '753' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstruction:withStack:',			#protocol : #'process actions',			#sourceCode : 'evaluateInstruction: elements withStack: stack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| handler |\t\r\thandler := ForthWord new.\r\r\telements splitOn: Character space do: [ :word | \r\t\t| result wordAsUpper  |\r\t\twordAsUpper := word asUppercase.\r\t\t(NumberParser isNumber: word) ifTrue: [ result := word asNumber ].\r\t\tword = \'+\' ifTrue: [result := handler add: stack].\r\t\tword = \'-\' ifTrue: [result := handler subtract: stack].\r\t\tword = \'*\' ifTrue: [result := handler multiply: stack].\r\t\tword = \'/\' ifTrue: [result := handler divide: stack].\r\t\twordAsUpper = \'DUP\' ifTrue: [result := handler dup: stack].\r\t\twordAsUpper = \'DROP\' ifTrue: [handler drop: stack].\r\t\twordAsUpper = \'SWAP\' ifTrue: [result := handler swap: stack].\r\t\twordAsUpper = \'OVER\' ifTrue: [result := handler over: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^stack.',			#stamp : 'AndyMarks 12/20/2023 08:39',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstruction:withStack:',			#protocol : #'process actions',			#sourceCode : 'evaluateInstruction: elements withStack: stack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| handler |\t\r\thandler := ForthWord new.\r\r\telements splitOn: Character space do: [ :word | \r\t\t| result wordAsUpper  |\r\t\twordAsUpper := word asUppercase.\r\t\t(NumberParser isNumber: word) ifTrue: [ result := word asNumber ].\r\t\tuserDefinedWords includesKey: word ifTrue: [ result := handler processUserDefinedWord: word].\r\t\tword = \'+\' ifTrue: [result := handler add: stack].\r\t\tword = \'-\' ifTrue: [result := handler subtract: stack].\r\t\tword = \'*\' ifTrue: [result := handler multiply: stack].\r\t\tword = \'/\' ifTrue: [result := handler divide: stack].\r\t\twordAsUpper = \'DUP\' ifTrue: [result := handler dup: stack].\r\t\twordAsUpper = \'DROP\' ifTrue: [handler drop: stack].\r\t\twordAsUpper = \'SWAP\' ifTrue: [result := handler swap: stack].\r\t\twordAsUpper = \'OVER\' ifTrue: [result := handler over: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^stack.',			#stamp : 'AndyMarks 12/23/2023 08:59',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-23T09:00:08.460135+11:00' ],		#prior : OmReference [ '753' ],		#self : OmReference [ '754' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'processUserDefinedWord:',			#protocol : #'as yet unclassified',			#sourceCode : 'processUserDefinedWord: word\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r',			#stamp : 'AndyMarks 12/23/2023 09:00',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-23T09:00:43.099504+11:00' ],		#prior : OmReference [ '754' ],		#self : OmReference [ '755' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'processUserDefinedWord:',			#protocol : #'as yet unclassified',			#sourceCode : 'processUserDefinedWord: word\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r',			#stamp : 'AndyMarks 12/23/2023 09:00',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'processUserDefinedWord:',			#protocol : #'process actions',			#sourceCode : 'processUserDefinedWord: word\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r',			#stamp : 'AndyMarks 12/23/2023 09:00',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-23T09:01:44.682938+11:00' ],		#prior : OmReference [ '755' ],		#self : OmReference [ '756' ]	},	#content : EpProtocolRemoval {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Forth\r\tinstanceVariableNames: \'userDefinedWords\'\r\tclassVariableNames: \'\'\r\tpackage: \'Exercise@Forth\'',				#superclassName : 'Object'			},			#name : #Forth,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Forth,						#isMetaSide : false					},					#name : #userDefinedWords,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Forth class\r\tinstanceVariableNames: \'\''				},				#name : #'Forth class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Forth,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #'Exercise@Forth',			#package : #'Exercise@Forth',			#sharedPools : OrderedCollection [ ]		},		#protocol : #'instance creation'	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-23T09:01:44.696848+11:00' ],		#prior : OmReference [ '756' ],		#self : OmReference [ '757' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'new\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\tuserDefinedWords := Dictionary new.\r\t\r\t^self.',			#stamp : 'AndyMarks 12/23/2023 08:53',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #new,			#protocol : #initialization,			#sourceCode : 'new\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\tuserDefinedWords := Dictionary new.\r\t\r\t^self.',			#stamp : 'AndyMarks 12/23/2023 08:53',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-23T09:02:59.376693+11:00' ],		#prior : OmReference [ '757' ],		#self : OmReference [ '758' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #new,			#protocol : #initialization,			#sourceCode : 'new\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\tuserDefinedWords := Dictionary new.\r\t\r\t^self.',			#stamp : 'AndyMarks 12/23/2023 08:53',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #new,			#protocol : #initialization,			#sourceCode : 'new\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\tuserDefinedWords := Dictionary new.\r',			#stamp : 'AndyMarks 12/23/2023 09:02',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-23T09:04:48.157378+11:00' ],		#prior : OmReference [ '758' ],		#self : OmReference [ '759' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstruction:withStack:',			#protocol : #'process actions',			#sourceCode : 'evaluateInstruction: elements withStack: stack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| handler |\t\r\thandler := ForthWord new.\r\r\telements splitOn: Character space do: [ :word | \r\t\t| result wordAsUpper  |\r\t\twordAsUpper := word asUppercase.\r\t\t(NumberParser isNumber: word) ifTrue: [ result := word asNumber ].\r\t\tuserDefinedWords includesKey: word ifTrue: [ result := handler processUserDefinedWord: word].\r\t\tword = \'+\' ifTrue: [result := handler add: stack].\r\t\tword = \'-\' ifTrue: [result := handler subtract: stack].\r\t\tword = \'*\' ifTrue: [result := handler multiply: stack].\r\t\tword = \'/\' ifTrue: [result := handler divide: stack].\r\t\twordAsUpper = \'DUP\' ifTrue: [result := handler dup: stack].\r\t\twordAsUpper = \'DROP\' ifTrue: [handler drop: stack].\r\t\twordAsUpper = \'SWAP\' ifTrue: [result := handler swap: stack].\r\t\twordAsUpper = \'OVER\' ifTrue: [result := handler over: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^stack.',			#stamp : 'AndyMarks 12/23/2023 08:59',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstruction:withStack:',			#protocol : #'process actions',			#sourceCode : 'evaluateInstruction: elements withStack: stack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| handler |\t\r\thandler := ForthWord new.\r\r\telements splitOn: Character space do: [ :word | \r\t\t| result wordAsUpper  |\r\t\twordAsUpper := word asUppercase.\r\t\t(NumberParser isNumber: word) ifTrue: [ result := word asNumber ].\r\t\t(userDefinedWords includesKey: word) ifTrue: [ result := handler processUserDefinedWord: word].\r\t\tword = \'+\' ifTrue: [result := handler add: stack].\r\t\tword = \'-\' ifTrue: [result := handler subtract: stack].\r\t\tword = \'*\' ifTrue: [result := handler multiply: stack].\r\t\tword = \'/\' ifTrue: [result := handler divide: stack].\r\t\twordAsUpper = \'DUP\' ifTrue: [result := handler dup: stack].\r\t\twordAsUpper = \'DROP\' ifTrue: [handler drop: stack].\r\t\twordAsUpper = \'SWAP\' ifTrue: [result := handler swap: stack].\r\t\twordAsUpper = \'OVER\' ifTrue: [result := handler over: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^stack.',			#stamp : 'AndyMarks 12/23/2023 09:04',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-23T09:05:54.110698+11:00' ],		#prior : OmReference [ '759' ],		#self : OmReference [ '760' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstruction:withStack:',			#protocol : #'process actions',			#sourceCode : 'evaluateInstruction: elements withStack: stack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| handler |\t\r\thandler := ForthWord new.\r\r\telements splitOn: Character space do: [ :word | \r\t\t| result wordAsUpper  |\r\t\twordAsUpper := word asUppercase.\r\t\t(NumberParser isNumber: word) ifTrue: [ result := word asNumber ].\r\t\t(userDefinedWords includesKey: word) ifTrue: [ result := handler processUserDefinedWord: word].\r\t\tword = \'+\' ifTrue: [result := handler add: stack].\r\t\tword = \'-\' ifTrue: [result := handler subtract: stack].\r\t\tword = \'*\' ifTrue: [result := handler multiply: stack].\r\t\tword = \'/\' ifTrue: [result := handler divide: stack].\r\t\twordAsUpper = \'DUP\' ifTrue: [result := handler dup: stack].\r\t\twordAsUpper = \'DROP\' ifTrue: [handler drop: stack].\r\t\twordAsUpper = \'SWAP\' ifTrue: [result := handler swap: stack].\r\t\twordAsUpper = \'OVER\' ifTrue: [result := handler over: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^stack.',			#stamp : 'AndyMarks 12/23/2023 09:04',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstruction:withStack:',			#protocol : #'process actions',			#sourceCode : 'evaluateInstruction: elements withStack: stack\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| handler |\t\r\thandler := ForthWord new.\r\r\telements splitOn: Character space do: [ :word | \r\t\t| result wordAsUpper  |\r\t\twordAsUpper := word asUppercase.\r\t\t(NumberParser isNumber: word) ifTrue: [ result := word asNumber ].\r\t\t"(userDefinedWords includesKey: word) ifTrue: [ result := handler processUserDefinedWord: word]."\r\t\tword = \'+\' ifTrue: [result := handler add: stack].\r\t\tword = \'-\' ifTrue: [result := handler subtract: stack].\r\t\tword = \'*\' ifTrue: [result := handler multiply: stack].\r\t\tword = \'/\' ifTrue: [result := handler divide: stack].\r\t\twordAsUpper = \'DUP\' ifTrue: [result := handler dup: stack].\r\t\twordAsUpper = \'DROP\' ifTrue: [handler drop: stack].\r\t\twordAsUpper = \'SWAP\' ifTrue: [result := handler swap: stack].\r\t\twordAsUpper = \'OVER\' ifTrue: [result := handler over: stack].\r\r\t\tresult ifNotNil: [ stack push: result ] ].\r\r\t^stack.',			#stamp : 'AndyMarks 12/23/2023 09:05',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-23T09:06:18.292032+11:00' ],		#prior : OmReference [ '760' ],		#self : OmReference [ '761' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Forth\r\tinstanceVariableNames: \'userDefinedWords\'\r\tclassVariableNames: \'\'\r\tpackage: \'Exercise@Forth\'',				#superclassName : 'Object'			},			#name : #Forth,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Forth,						#isMetaSide : false					},					#name : #userDefinedWords,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Forth class\r\tinstanceVariableNames: \'\''				},				#name : #'Forth class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Forth,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #'Exercise@Forth',			#package : #'Exercise@Forth',			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Forth\r\tinstanceVariableNames: \'userDefinedWords stack\'\r\tclassVariableNames: \'\'\r\tpackage: \'Exercise@Forth\'',				#superclassName : 'Object'			},			#name : #Forth,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Forth,						#isMetaSide : false					},					#name : #userDefinedWords,					#parent : @23				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Forth,						#isMetaSide : false					},					#name : #stack,					#parent : @23				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Forth class\r\tinstanceVariableNames: \'\''				},				#name : #'Forth class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @23			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Forth,					#isMetaSide : false				},				#parent : @23,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #'Exercise@Forth',			#package : #'Exercise@Forth',			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-23T09:06:18.321903+11:00' ],		#prior : OmReference [ '761' ],		#self : OmReference [ '762' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #new,			#protocol : #initialization,			#sourceCode : 'new\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\tuserDefinedWords := Dictionary new.\r',			#stamp : 'AndyMarks 12/23/2023 09:04',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #new,			#protocol : #initialization,			#sourceCode : 'new\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\tuserDefinedWords := Dictionary new.\r\tstack := Stack new.\r',			#stamp : 'AndyMarks 12/23/2023 09:06',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-23T09:06:34.959483+11:00' ],		#prior : OmReference [ '762' ],		#self : OmReference [ '763' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstruction:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstruction: instruction\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t| stack |\r\t\r\tstack := Stack new.\r\t\r\t(instruction matchesRegex: \'^\\: (.*) (.*) ;$\')\r\t\tifTrue: [ self defineCommand: instruction withStack: stack]\r\t\tifFalse: [ self evaluateInstruction: instruction withStack: stack].\r\r\t^stack.',			#stamp : 'AndyMarks 12/20/2023 08:40',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstruction:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstruction: instruction\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t(instruction matchesRegex: \'^\\: (.*) (.*) ;$\')\r\t\tifTrue: [ self defineCommand: instruction withStack: stack]\r\t\tifFalse: [ self evaluateInstruction: instruction withStack: stack].\r\r\t^stack.',			#stamp : 'AndyMarks 12/23/2023 09:06',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-23T09:10:00.482514+11:00' ],		#prior : OmReference [ '763' ],		#self : OmReference [ '764' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstruction:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstruction: instruction\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t(instruction matchesRegex: \'^\\: (.*) (.*) ;$\')\r\t\tifTrue: [ self defineCommand: instruction withStack: stack]\r\t\tifFalse: [ self evaluateInstruction: instruction withStack: stack].\r\r\t^stack.',			#stamp : 'AndyMarks 12/23/2023 09:06',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstruction:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstruction: instruction\r\t"comment stating purpose of instance-side method"\r\t"scope: class-variables  &  instance-variables"\t\r\r\t(instruction matchesRegex: \'^\\: (.*) (.*) ;$\')\r\t\tifTrue: [ self defineCommand: instruction withStack: stack]\r\t\tifFalse: [ self evaluateInstruction: instruction].\r\r\t^stack.',			#stamp : 'AndyMarks 12/23/2023 09:10',			#package : #'Exercise@Forth'		}	}}OmEntry {	#tags : {		#author : 'AndyMarks',		#time : DateAndTime [ '2023-12-23T09:10:15.279494+11:00' ],		#prior : OmReference [ '764' ],		#self : OmReference [ '765' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: instructionArray\r\r\t"comment stating purpose of instance-side method"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| stack |\r\tinstructionArray do: [ :instruction |\r\t\tstack := self evaluateInstruction: instruction.\r\t\t].\r\r\t^ stack reversed asArray',			#stamp : 'AndyMarks 12/20/2023 08:38',			#package : #'Exercise@Forth'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Forth,				#isMetaSide : false			},			#name : #'evaluateInstructions:',			#protocol : #evaluating,			#sourceCode : 'evaluateInstructions: instructionArray\r\r\t"comment stating purpose of instance-side method"\r\r\t"scope: class-variables  &  instance-variables"\r\r\tinstructionArray do: [ :instruction |\r\t\tstack := self evaluateInstruction: instruction.\r\t\t].\r\r\t^ stack reversed asArray',			#stamp : 'AndyMarks 12/23/2023 09:10',			#package : #'Exercise@Forth'		}	}}