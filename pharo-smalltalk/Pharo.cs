----QUIT----2023-03-15T12:25:06.404843+01:00 Pharo10-SNAPSHOT-64bit-179ef65.image priorSource: 0!----QUIT----2023-03-15T12:25:36.467018+01:00 Pharo10-SNAPSHOT-64bit-179ef65.image priorSource: 0!----QUIT/NOSAVE----2023-12-03T10:35:44.738044+11:00 Pharo.image priorSource: 99!!BaselineOfExercism commentStamp: '' prior: 0!Project baseline to load entire Exercism Pharo track, including all its dependencies!!BaselineOfExercism class methodsFor: 'baselines'!exerciseGoldenTestPackageNames	"Answer the list of exercise package names used for golden tests executed by Exercism's test runner"	^ #('Exercise@ExampleAllFail' 'Exercise@ExampleAllPass' 'Exercise@ExampleAllRaiseError' 'Exercise@ExampleEmptySolutionClass' 'Exercise@ExampleEmptySolutionFile' 'Exercise@ExampleErrorFailPass' 'Exercise@ExampleExtensionMethod' 'Exercise@ExampleSyntaxError' 'Exercise@ExampleTypoInMethodName')! !!BaselineOfExercism class methodsFor: 'baselines'!exercisePackageNames	"Answer the list of exercise package names (as we don't yet have proper projects)"	^ #('Exercise@Acronym' 'Exercise@Allergies' 'Exercise@Anagram' 'Exercise@ArmstrongNumbers' 'Exercise@AtbashCipher' 'Exercise@Binary' 'Exercise@BinarySearchTree' 'Exercise@Bowling' 'Exercise@CircularBuffer' 'Exercise@Clock' 'Exercise@CollatzConjecture' 'Exercise@Darts' 'Exercise@Diamond' 'Exercise@Die' 'Exercise@Etl' 'Exercise@FlattenArray' 'Exercise@Forth' 'Exercise@GradeSchool' 'Exercise@Grains' 'Exercise@Hamming' 'Exercise@HelloWorld' 'Exercise@HighScores' 'Exercise@IsbnVerifier' 'Exercise@Isogram' 'Exercise@Leap' 'Exercise@Luhn' 'Exercise@MatchingBrackets' 'Exercise@Matrix' 'Exercise@Minesweeper' 'Exercise@Pangram' 'Exercise@Proverb' 'Exercise@Raindrops' 'Exercise@ResistorColorDuo' 'Exercise@ReverseString' 'Exercise@RobotSimulator' 'Exercise@RomanNumerals' 'Exercise@SecretHandshake' 'Exercise@Sieve' 'Exercise@SimpleCipher' 'Exercise@SpaceAge' 'Exercise@SumOfMultiples' 'Exercise@Tournament' 'Exercise@TwelveDays' 'Exercise@TwoFer' 'Exercise@Welcome' 'Exercise@WordCount')! !!BaselineOfExercism class methodsFor: 'baselines'!exerciseTestPackageNames	"Answer the list of exercise package names used for testing (as we don't yet have proper projects)"	^ #('ExercismTests-ExerciseEmpty' 'ExercismTests-ExerciseMany' 'ExercismTests-ExerciseNormal' 'ExercismTests-ExerciseExtension')! !!BaselineOfExercism methodsFor: 'baselines'!baseline: spec	<baseline>	spec		for: #common		do: [ self setExercismLogo.			self setUpDependencies: spec.			self setUpExercisesFor: spec.			self setUpGoldenTestsFor: spec.			spec				package: 'ExercismTools';				package: 'ExercismMocking' with: [ spec requires: #('Mocketry') ];				package: 'ExercismTests'					with: [ spec						requires:							#('ExercismTools' 'ExercismMocking')								, self class exerciseTestPackageNames ];				package: 'ExercismSystemTests'					with: [ spec requires: #('ExercismTests') ];				package: 'ExercismWIP'					with: [ spec requires: #('ExercismTools') ];				package: 'ExercismDev'					with: [ spec						requires:							#('ExercismTools' 'OSSubprocess' 'OSWinSubprocess')								, self class exercisePackageNames	"For shelling out to configlet" ];				package: 'ExercismTestRunner'					with:						[ spec requires: #('ExercismTools') , self class exercisePackageNames ];				package: 'ExercismTestRunnerTests'					with: [ spec requires: #('ExercismTestRunner' 'ExercismTests') ];				package: 'ExercismV3';				group: 'default' with: #('ExercismTools' 'Exercise@Welcome');				group: 'mentor' with: #('ExercismDev');				group: 'dev'					with: #('ExercismDev' 'ExercismWIP' 'ExercismSystemTests');				group: 'testRunner' with: #('ExercismTestRunner');				group: 'testRunnerTests' with: #('ExercismTestRunnerTests'), self class exerciseGoldenTestPackageNames;				group: 'v3' with: #('ExercismV3')			].			spec for: #'pharo9.x' do: [ 				spec package: 'ExercismTools' with: [ spec includes: #('ExercismPharo90') ].				spec package: 'ExercismPharo90' ].			spec for: #'pharo11.x' do: [				"ExercismTools must be loaded prior compatibilty package, to overwrite original class definition of ExTonelWriter"				spec package: 'ExercismTools' with: [ spec includes: #('ExercismPharo110') ].				spec package: 'ExercismPharo110' with: [ spec requires: 'ExercismTools' ]			]		! !!BaselineOfExercism methodsFor: 'baselines'!projectClass	^ MetacelloCypressBaselineProject! !!BaselineOfExercism methodsFor: 'baselines'!setExercismLogo	| exercismLogo |	exercismLogo := (AlphaImageMorph		withForm:		(ZnEasy		getPng:			'https://user-images.githubusercontent.com/38899847/48952150-634e9b80-eefe-11e8-890e-7a233d56df65.png'))		layout: #scaledAspect;		extent: 100 @ 100;		position: 10 @ 135;		lock.	World addMorph: exercismLogo! !!BaselineOfExercism methodsFor: 'baselines'!setUpDependencies: spec	spec 		baseline: 'OSSubprocess' 		with: [spec repository: 'github://pharo-contributions/OSSubprocess:master/repository'].		spec 		baseline: 'OSWinSubprocess' 		with: [spec repository: 'github://pharo-contributions/OSWinSubprocess:master/repository'].						spec    	baseline: 'Mocketry'    	with: [ spec repository: 'github://dionisiydk/Mocketry:v6.0.x' ].		spec    	baseline: 'Ring2'    	with: [ spec repository: 'github://pavel-krivanek/Ring2'; loads: #(calypso)].! !!BaselineOfExercism methodsFor: 'baselines'!setUpExercisesFor: spec	self class exercisePackageNames, self class exerciseTestPackageNames 		do:			[ :name | spec package: name with: [ spec requires: #('ExercismTools') ] ]! !!BaselineOfExercism methodsFor: 'baselines'!setUpGoldenTestsFor: spec		self class exerciseGoldenTestPackageNames 		do:			[ :name | spec package: name with: [ spec requires: #('ExercismTools') ] ]! !"BaselineOfExercism"!!TExercise commentStamp: '' prior: 0!# TExerciseI am a trait containing methods for getting exercise meta data fromobjects that play the role of a Exercism version 3 exercise.## UsageMy methods reference instance variables and methods that must be implemented by objects that use me. ## Instance Variables These will need to be initialized in the using classes `#initialize` method.- solutionId - customData: An `Array`. This can be safely initialized empty.- isActive: A `Boolean`. Is the exercise active (not depricated or for testing).- isCustom: A `Boolean`. `true` if `customData` is not empty.- uuid: A `String`. The exercises unique ID in the Execism project.- version- aliasesAndHints: An `Array`. This can be safely initialized empty.## Methods### `#configuredExerciseMetadata`Must answer the configured exercise meta data for this exercise, an `ExercismExercise`.!!ExercismTest commentStamp: '' prior: 0!I am the root of Exercism test examples but also provide a hook to specify some simple exercise metadata that can be used to generate the exercism config.json file (used by the platform to unlock exercises for users as they progress).!!ExercismHintTwoFerReuseRule commentStamp: '' prior: 0!The TwoFer exercise introduces you to calling between methods.For practice, your '#who'  method should reuse your  '#who:'  method. !!ClyExercismMenuGroup commentStamp: '' prior: 0!# ClyExercismMenuGroupI am the group of Exercism menu item commands. My class can be used togroup Exercism specific menu items.I am used in `ClyExercismExerciseCommand class>>#packageContextMenuActivation`and `ClyExercismExerciseCommand class >>#tagContextMenuActivation`. !!ClyExercismCommand commentStamp: '' prior: 0!# ClyExercismCommandI provide menu facilities for Exercism that should only appear in the context of an Exercism package (and not in other browser packages).I am an abstract class.## DesignI follow the Command Pattern of Object Oriented Design. I do one task on recieving the `#execute` message, which must be implemented by subclasses. All other methods should be about setting up the staterequred for the `#execute` method to carry out its task.The `#execute` method is written further up the inheritance hierarchyat `CmdCommand>>#execute`.## Instance Variables- browser: ClyPackageContextOfFullBrowser, the context of of a browser instance containing packages.- selectedItem: RPackage, the selected package in the browser context.!!ClyExercismExerciseCommand commentStamp: '' prior: 0!# ClyExercismExerciseCommandI am the Abstract super class of all Exercism exercise menu commands.Menu items subclassing me should only appear on exercise package tagsin the browser.## GUI Menu Subclasses of me are grouped into a browser menu under the name "Exercism" when activating a menu on a package or tag. This submenuis created by the class methods `#packageContextMenuActivation` and`#tagContextMenuActivation`.## Error reportingSubclasess may use `#reportError:for:` to report errors. In one error case the exercise may be missing metadata and will need to be upgraded in the users Exercism profile and re-fetched.In another error case the exercise may not be found. The likely problem is that the exercise name is misspelled or does not exist inthe Pharo-Smalltalk language track. !!ClyExercismFetchCommand commentStamp: '' prior: 0!# ClyExercismFetchCommandI am a browser menu item command that initiates a fetch operation to get a specific exercise from Exercism.io.## Command ExecutionI implement the `#execute` method. On receiving this message I start the fetch operation to get an exercise, and report the success or errorof the operation via the UI.I send a message to `ExercismManager default` to fetch the exercise.On successful retrieval of an exercise I will open a browser window onthat exercises test case.I may signal an `ExDomainError` if I could not retrieve an exercise fromthe `ExercismManager` submission.If the `ExercismManager` signals an `ExDomainError` I will report theerror with `ClyExercismExerciseCommand>>#reportError:for:`.## World MenuOn my class side is `#worldMenuCommandOn:`. This method adds a "Fetchnew exercise..." command to the World menu under the "Exercism" section.!!ClyExercismProgressCommand commentStamp: '' prior: 0!# ClyExercisProgressCommandI am a browser menu item command that initiates an operation to viewthe users progress of an exercise on the Exercism website.## Command ExecutionIn my `#execute` method I send a message to `ExercismManager default`to view the selected exercise in the browser on the Exercism website.## World MenuOn my class side `#worldMenuCommandOn:` creates an entry labeled "ViewTrack Progress" for me in the World menu under the "Exercism" section.!!ClyExercismShareCommand commentStamp: '' prior: 0!# ClyExercismShareCommandI am a browser menu item command. I can be used to share the code of an exercise solution by creating an anonymous web link to `dpaste.com`.## Enabling SharingSharing will not be possible unless the class method `#hasComfirmedSharing:` is used to set the class variable of the same name to `true`.## Command ExecutionIn my `#execute` method I initiate and handle the result of the sharing operation. I send a message to `ExercismManager default` tostart the sharing.I may report an `ExercismError` signaled my `ExercismManager` using`ClyExercismExerciseCommand>>#reportError:for:`. I may use the samemessage to report an error if the exercise name can't be found.On a successful operation I will copy the dpase.com URL to theclipboard and open the webbrowser on the URL.!!ClyExercismSubmitCommand commentStamp: '' prior: 0!# ClyExercismSubmitCommandI am a browser menu item command. I initiate submitting the selectedexercise solution to the Exercism website.## Command ExecutionOn recieving the message `#execute` I initiate the submit operation bysending the message `#submitToExercism:` to `ExercismManager default`.This will submit my selected exercise.If an `ExercismError` is signaled I will report the error with`#reportError:for:`. !!STONJSONWriter commentStamp: '' prior: 0!I am a simple JSON writer that lets you specify configuation in JSON like:data := { 	'id'-> 123. 	'language' -> 'english'.	'exercises' -> {		'name' -> 'hello'.		'topics' -> #('a' 'b' 'c') }	}. 	String streamContents: [ :stream |	(STONJSONWriter on: stream) nextPut: data  ].It is assumed that key order is important and so all Dictionaries are converted to OrderedDictionary when writing out the JSON!!ExercismError commentStamp: '' prior: 0!I am a hierarchy of Exercism errors, so its east to catch them!!ExUnauthorized commentStamp: '' prior: 0!I am an authorisation error for Exercism!!ExTonelWriter commentStamp: '' prior: 0!I am a TonelWriter that provides finer level control of writing Tonel files for Exercism!!StaticTextMorph commentStamp: '' prior: 0!Provide a non editable text morph suitable for hosting a clickable URL!!ExercismExercise commentStamp: '' prior: 0!I am the meta data for an exercise, and am typically created from the #excerise method on any of the specified ExercismTest tests (which are a type of SUnit test).Of note is that the exercise submission id is stored as a class instance variable on ExercismTest.!!MockExercismExercise commentStamp: '' prior: 0!# MockExercismExerciseI am a subclass of `ExercismExercise` exclusively for use in testing. I override `#allExercises`to return a small number of exercises instead of all the exercises in production,which can grow in number. This is to help keep tests fast and predictable.## Overridden Methods### `#allExercises`Answers a small constant number of exercises.!!ExercismHttpClient commentStamp: '' prior: 0!I am a wrapper over a ZnClient to streamline the HTTP interactions with exercism, and to also make it re-testable.!!ExercismHttpCommand commentStamp: '' prior: 0!I am the root of Http commands that will use a (now) seperate httpClient object to fetch/put solution data!!ExercismDownloadCommand commentStamp: '' prior: 0!I am the command for dowloading an exercise and installing it in the image!!ExercismSubmitCommand commentStamp: '' prior: 0!I am a command for submitting an exercise. !!ExercismManager commentStamp: '' prior: 0!I am  responsible for managing the interaction with the lower level Exercism command line tool.!!ExercismSubmission commentStamp: '' prior: 0!I am a wrapper over the exercism json submission data. Crucially I have a solutionId that is needed when submitting exercises that have been downloaded.!!TExercise classTrait methodsFor: 'helper'!createExerciseAfter: anotherTestCase	"Helper method to create an exercise meta data object"		^ (ExercismExercise for: self)		unlockedBy: 			((anotherTestCase notNil and: [ anotherTestCase isObsolete not ])				ifTrue: [ [ anotherTestCase exercise ] on: SubclassResponsibility do: [ nil ] ]				ifFalse: [ nil ]);		yourself ! !!TExercise classTrait methodsFor: 'config'!customData	^ customData! !!TExercise classTrait methodsFor: 'config'!exercise	^ self configuredExerciseMetadata! !!TExercise classTrait methodsFor: 'generator'!generator	^ aliasesAndHints! !!TExercise classTrait methodsFor: 'config'!isActive	^ isActive! !!TExercise classTrait methodsFor: 'config'!isCustom	^ customData notEmpty ! !!TExercise classTrait methodsFor: 'accessing'!solutionId 	^ solutionId ifNil: [ ExSolutionIdError signal: 'Missing exercise solutionId' ]! !!TExercise classTrait methodsFor: 'accessing'!solutionId: anObject	solutionId := anObject ! !!TExercise classTrait methodsFor: 'config'!uuid	^ uuid! !!TExercise classTrait methodsFor: 'config'!version	^ version! !!UITheme methodsFor: '*ExercismTools'!newStaticTextIn: aThemedMorph text: aStringOrText	"Answer a new text."	"Derived from newTextIn:text: - changed from locked to disabled"    	^StaticTextMorph new		wrapFlag: true;		contents: aStringOrText;		font: self textFont;		autoFit: true;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap! !!UITheme methodsFor: '*ExercismTools'!textEntryIn: aThemedMorph formattedText: formattedText title: aString entryText: defaultEntryText	"Answer the result of a text entry dialog (a string or nil if cancelled)	with the given label and title."	"Derived from textEntryIn:text:title:entryText: but calling #formattedText: not #text:"	self questionSound play.	^(aThemedMorph openModal: (		TextEntryDialogWindow new			textFont: self textFont;			title: aString;			formattedText: formattedText;			entryText: defaultEntryText)) entryText! !!MCClassDefinition methodsFor: '*ExercismTools'!exTonelFilename	^ClassDescription exTonelClassFilenameFor: self className ! !!TestResult methodsFor: '*ExercismTools'!exercismEnvironmentInfoOn: aStream	aStream 	 	nextPutAll: 'Used OS/Platform: ';		nextPutAll: Smalltalk os platformName; space;		nextPutAll: Smalltalk os version; space;		nextPutAll: Smalltalk os subtype;		crlf;		nextPutAll: 'Image version: ';		nextPutAll: SystemVersion current version; space;		nextPutAll: 'build: ';		nextPutAll: SystemVersion current build asString;		nextPutAll: (Smalltalk vm is32bit 			ifTrue: [ ' (32 Bit)' ]			ifFalse: [ ' (64 Bit)' ]).	aStream 		crlf;		nextPutAll: 'VM version: ';		nextPutAll: Smalltalk vm interpreterSourceVersion		 ! !!TestResult methodsFor: '*ExercismTools'!exercismSummary	^String streamContents: [ :s | s 		nextPutAll: 'Tested on: ';		nextPutAll: self timeStamp asLocalStringYMDHM;		crlf;		nextPutAll: self runCount printString;		nextPutAll: ' run, ';		nextPutAll: self expectedPassCount printString;		nextPutAll: ' passes, ';		nextPutAll: self skippedCount printString;		nextPutAll: ' skipped, ';		nextPutAll: self unexpectedFailureCount printString;		nextPutAll: ' failures, ';		nextPutAll: self unexpectedErrorCount printString;		nextPutAll:' errors.';		crlf.		self exercismEnvironmentInfoOn: s.	]! !!ExercismTest class methodsFor: 'helper'!createExerciseAfter: anotherTestCase	"protocol: #helper"	"Helper method to create an exercise meta data object"	^ (ExercismExercise for: self)		unlockedBy:			((anotherTestCase notNil and: [ anotherTestCase isObsolete not ])				ifTrue: [ [anotherTestCase exercise] on: SubclassResponsibility do: [ nil ] ]				ifFalse: [ nil ]);		yourself! !!ExercismTest class methodsFor: 'config'!customData	^{}! !!ExercismTest class methodsFor: 'config'!exercise	"Answer the configured exercise meta data for this exercise, an ExercismExercise	e.g.		^(self createExerciseAfter: HelloWorldTest)		isCore: false;		difficulty: 1;		topics: #('strings' 'iteration' 'parsing');		yourself	"		self subclassResponsibility 				! !!ExercismTest class methodsFor: 'generator'!generator	"Answer code generator aliases/hints"		^{}! !!ExercismTest class methodsFor: 'config'!isActive	"Answer true if an exercise is active (not deprecated or for testing)"		^true! !!ExercismTest class methodsFor: 'config'!isCustom	^self customData notEmpty! !!ExercismTest class methodsFor: 'accessing'!solutionId	^ solutionId ifNil: [ ExSolutionIdError signal: 'Missing exercise solutionId' ]! !!ExercismTest class methodsFor: 'accessing'!solutionId: anObject	solutionId := anObject! !!ExercismTest class methodsFor: 'config'!uuid	"Answer a fixed String, the unique UUID for this exercise so the Exercism platform can identify it.	The id should be like: 'b5812b5e-2788-4ea6-b948-bfe54edeb0da' "		^self subclassResponsibility ! !!ExercismTest class methodsFor: 'config'!version	"Answer the exercise version number string this test was derived from"		^self subclassResponsibility  ! !!ExercismTest methodsFor: 'assertions'!assert: aNumber closeEnoughTo: aNumber2 by: decimalPlaces	"Assert that two numbers are the same when rounded to decimalPlaces places"	self		assert: (aNumber asFloat round: decimalPlaces)		equals: (aNumber2 asFloat round: decimalPlaces)! !!ExercismTest methodsFor: 'verify'!verifySolution: aClass avoidsSelector: aSelector	| badSelector | 	badSelector := aClass methods detect: [ :m | m ast sentMessages includes: aSelector ] ifNone: [ ^self ].		self fail: 'Your code in ', badSelector name, ' uses the library method #', aSelector, ' - try writing a different solution that avoids it'! !!ZnMimePart class methodsFor: '*ExercismTools'!exercismFieldName: fieldName fileName: fileName entity: entity	"Copied from ZnMimePart class >> fieldName:fileName:entity:	 with space added after 'form-data;' as required by Exercism server, 	 otherwise we get Response(500 INTERNAL SERVER ERROR).	 Space added after second semi-colon just for looks."		"Pathnames are often silenty encoded using UTF-8,	this is a no-op for ASCII, but will fail on Latin-1 and others"	| encodedFileName |	encodedFileName := fileName utf8Encoded asString.	^ self new		setContentDisposition: 'form-data; name="', fieldName, '"; filename="', encodedFileName, '"';		entity: entity;		yourself! !!ClassDescription class methodsFor: '*ExercismTools'!exTonelClassFilenameFor: aName	^aName, '.class.st'! !!ClassDescription class methodsFor: '*ExercismTools'!exTonelExtensionFilenameFor: aName	^aName, '.extension.st'! !!ClassDescription methodsFor: '*ExercismTools'!exPrintOutCategoriesFor: aClass on: aWriteStream	aClass methods ifEmpty: [ ^self ].		aWriteStream 		nextPutAll: (aClass isClassSide ifTrue: [ '"[class'] ifFalse: [  '"[instance']);	 	nextPutAll: ' methods]"'; cr.		aClass organization categories asSortedCollection 		do: [ :heading | 			aWriteStream				nextPutAll: '"category: ';				nextPutAll: heading;				nextPutAll: '"';				cr.							aClass exPrintOutLocalMethodsInCategory: heading on: aWriteStream ]! !!ClassDescription methodsFor: '*ExercismTools'!exPrintOutExtensionsFor: aRPackage on: aWriteStream	aRPackage exPrintOutExtensionsFor: self on: aWriteStream. ! !!ClassDescription methodsFor: '*ExercismTools'!exPrintOutLocalMethodsInCategory: aSymbol on: aWriteStream	"Print out methods for this category."	aWriteStream cr.		(self selectorsToFileOutCategory: aSymbol)		do: [ :sel | self exPrintOutMethod: sel on: aWriteStream ]	! !!ClassDescription methodsFor: '*ExercismTools'!exPrintOutMethod: selector on: aWriteStream	"Print the source code for selector onto the WriteStream."	| method source |	method := self		compiledMethodAt: selector		ifAbsent: [ ^ aWriteStream				nextPutAll: selector;				cr;				tab;				nextPutAll: '"** ERROR: SOURCE IS MISSING ** ".';				cr;				cr ].				source := method sourceCode trimBoth.		aWriteStream nextPutAll: source.		source last = $.		ifFalse: [ aWriteStream nextPut: $. ].			aWriteStream		cr;		cr! !!ClassDescription methodsFor: '*ExercismTools'!exPrintOutOn: aWriteStream	"Print a description of the receiver on aWriteStream."	aWriteStream		nextPutAll: '"-- #', self name, ' (class) --"'; cr; cr;		nextPutAll: self definition; 		nextPut: $.; cr; cr.		self hasComment ifTrue: [ 		aWriteStream nextPut: $".		self comment trimBoth encodeDoublingDoubleQuotesOn: aWriteStream.		aWriteStream nextPut: $"; cr; cr ].		self exPrintOutCategoriesFor: self class on: aWriteStream.	self exPrintOutCategoriesFor: self on: aWriteStream! !!MCMethodDefinition methodsFor: '*ExercismTools'!exTonelFilename	^ClassDescription exTonelExtensionFilenameFor: self className ! !!ExercismHintRule methodsFor: 'accessing'!group	^'Exercism Hint'! !!ExercismHintRule methodsFor: 'accessing'!severity	^ #warning! !!ExercismHintTwoFerReuseRule class methodsFor: 'testing-interest'!checksMethod	^true! !!ExercismHintTwoFerReuseRule methodsFor: 'accessing'!basicCheck: compiledMethod	compiledMethod methodClass name = #TwoFer ifTrue: [ 		|literals|		literals := compiledMethod sourceCode parseLiterals.		literals first = #who ifTrue: [ ^ (literals includes: #who:) not ].		].	^false! !!ExercismHintTwoFerReuseRule methodsFor: 'accessing'!name	^ 'Exercism: Method #who should reuse method #who: '! !!TextEntryDialogWindow methodsFor: '*ExercismTools'!formattedText: formattedText	"Set the text."	"Derived from MessageDialogWindow>>text: but dont' clear any formating"	formattedText		addAttribute: TextAlignment centered.	self textMorph newContents: formattedText! !!TextEntryDialogWindow methodsFor: '*ExercismTools'!newText: aStringOrText	"Answer a new text."	"Overrides MessageDialog>>newText, but change from locked to disabled"	^self theme		newStaticTextIn: self		text: aStringOrText! !!RPackageTag methodsFor: '*ExercismTools'!definedClasses	^ self classes! !!RPackageTag methodsFor: '*ExercismTools'!exerciseName	"Provided for legacy compatibility"	^self name asString! !!RPackageTag methodsFor: '*ExercismTools'!promoteAsExercismRPackage	"This method converts this rpackage tag into an rpackage compatible with exercism"	|  tagName pkgName promotedName pkg |		tagName := self name.	pkgName := self packageName.	promotedName := self categoryName.		self promoteAsRPackage.		pkg := RPackageOrganizer default packageNamed: promotedName.	pkg renameTo: pkgName, '@', tagName! !!RPackageTag methodsFor: '*ExercismTools'!root	^self package! !!RPackageTag methodsFor: '*ExercismTools'!snapshot	| parentSnapshot |		parentSnapshot := (MCPackage named: self package name) snapshot.		^ MCSnapshot		fromDefinitions:			(parentSnapshot definitions				select:					[ :mc | mc className isNil or: [ mc actualClass category endsWith: self name ] ])! !!RPackage methodsFor: '*ExercismTools'!exPrintOutExtensionsFor: aClass on: aWriteStream	| selectors |	(selectors := self extensionSelectorsForClass: aClass) ifEmpty: [  ^self ].		aWriteStream 		nextPutAll: '"-- #'; 		nextPutAll: aClass name; 		nextPutAll: ' (extension) --"'; 		cr; cr.		selectors do: [ :sel |  		aClass exPrintOutMethod: sel on: aWriteStream ]! !!RPackage methodsFor: '*ExercismTools'!exerciseName	^ (self name allRegexMatches: '\w+') last! !!RPackage methodsFor: '*ExercismTools'!root	^self! !!RPackage methodsFor: '*ExercismTools'!snapshot	| pkgSnapshot extensions |	pkgSnapshot := (MCPackage named: self name) snapshot.		extensions := self extensionMethods		collect: [ :extension | extension asRingDefinition asMCMethodDefinition  ].			^ MCSnapshot fromDefinitions: pkgSnapshot definitions , extensions! !!MorphicUIManager methodsFor: '*ExercismTools'!requestText: formattedText initialAnswer: defaultAnswer title: aTitle	"Derived from #request:initialAnswer:title: but only for formatted text not strings	to avoid overriding formatting."		"Create an instance of me whose question is queryString with the given 	initial answer. Answer the string the user accepts.	The title serves for the window that is opened	Answer the empty string if the user cancels.	Allow for interception with a ProvideAnswerNotification handler."		|modalMorph|	(ProvideAnswerNotification signal: formattedText) ifNotNil: [:answer |		^answer == #default ifTrue: [defaultAnswer] ifFalse: [answer]].	modalMorph := self modalMorph.	^(modalMorph theme 		textEntryIn: modalMorph		formattedText: formattedText		title: aTitle		entryText: defaultAnswer)! !!ClyExercismMenuGroup methodsFor: 'accessing'!name	^'Exercism'! !!ClyExercismMenuGroup methodsFor: 'accessing'!order	^1! !!ClyExercismCommand class methodsFor: 'activation'!canBeExecutedInContext: aToolContext	^ (super canBeExecutedInContext: aToolContext)		and: [ self isExercismTagIn: aToolContext ]! !!ClyExercismCommand class methodsFor: 'testing'!isAbstract		^self == ClyExercismCommand! !!ClyExercismCommand class methodsFor: 'testing'!isExercismTagIn: aToolContext		^false! !!ClyExercismCommand methodsFor: 'accessing'!browser	^ browser! !!ClyExercismCommand methodsFor: 'accessing'!browser: anObject	browser := anObject! !!ClyExercismCommand methodsFor: 'execution'!prepareFullExecutionInContext: aToolContext	super prepareFullExecutionInContext: aToolContext.	self selectedItem: (self selectedItemIn: aToolContext).	self browser: aToolContext tool! !!ClyExercismCommand methodsFor: 'accessing'!selectedItem	^ selectedItem! !!ClyExercismCommand methodsFor: 'accessing'!selectedItem: anObject	selectedItem := anObject! !!ClyExercismCommand methodsFor: 'accessing'!selectedItemIn: aToolContext	^ aToolContext lastSelectedClassGroup! !!ClyExercismExerciseCommand class methodsFor: 'activation'!contextMenuOrder	<classAnnotationDependency>			^1! !!ClyExercismExerciseCommand class methodsFor: 'testing'!isAbstract		^self == ClyExercismExerciseCommand! !!ClyExercismExerciseCommand class methodsFor: 'activation'!isExercismTagIn: aToolContext	^ aToolContext lastSelectedClassGroup name ~= ExercismManager legacyPackagePrefix		and: [ aToolContext lastSelectedClassGroup classes				detect: [ :any | 					(any package name beginsWith: ExercismManager exercisePrefix , '@')						or: [ (any package name beginsWith: ExercismManager legacyPackagePrefix , '-')							or: [ any package name = ExercismManager legacyPackagePrefix ] ] ]				ifFound: [ true ]				ifNone: [ false ] ]! !!ClyExercismExerciseCommand class methodsFor: 'activation'!packageContextMenuActivation	"We can use a second annotation to give a similar menu to the Package item"	<classAnnotation>		^ CmdContextMenuActivation		byItemOf: ClyExercismMenuGroup		order: self contextMenuOrder		for: RPackage asCalypsoItemContext! !!ClyExercismExerciseCommand class methodsFor: 'activation'!tagContextMenuActivation	<classAnnotation>		^ CmdContextMenuActivation		byItemOf: ClyExercismMenuGroup		order: self contextMenuOrder		for: ClyTaggedClassGroup asCalypsoItemContext! !!ClyExercismExerciseCommand methodsFor: 'execution'!reportError: anError for: exerciseId	| msg |	msg := exerciseId		ifNil: [ anError messageText, '!!' ]		ifNotNil: [ 			((Smalltalk hasClassNamed: exerciseId kebabAsCamelCase)				ifTrue:					[ 'Exercise "{1}" is missing metadata!! You need to upgrade it in Exercism and re-fetch!!' ]				ifFalse:					[ 'Exercise "{1}" not found!! Please check the Exercism website for valid exercises!!' ])				format: {exerciseId} ].	^ UIManager default abort: msg! !!ClyExercismFetchCommand class methodsFor: 'activation'!contextMenuOrder		^5! !!ClyExercismFetchCommand class methodsFor: 'world menu'!worldMenuCommandOn: aBuilder	<worldMenu>		| templateCommand browser |		templateCommand := self new 		packages: { self package }; 		yourself.		(aBuilder item: templateCommand defaultMenuItemName)		parent: #Exercism;		order: 1;		action: [ 			browser := Smalltalk tools browser openOnPackage: ExercismManager.			templateCommand browser: browser.			templateCommand execute ];		iconName: templateCommand defaultMenuIconName;		help: templateCommand description		"withSeparatorAfter"! !!ClyExercismFetchCommand methodsFor: 'accessing'!defaultMenuIconName	^#book! !!ClyExercismFetchCommand methodsFor: 'accessing'!defaultMenuItemName	^'Fetch new exercise...'! !!ClyExercismFetchCommand methodsFor: 'accessing'!description 	^'Fetch a named Exercism exercise to begin solving it'! !!ClyExercismFetchCommand methodsFor: 'execution'!execute	| submission |	[		submission := ExercismManager default			fetchFromExercismTo: self packages first.					submission ifNotNil: [			UIManager default inform: 'Success, Happy Coding'.			submission exercise 				ifNil: [ 					ExDomainError signal: 'Missing exercise meta-data' ]				ifNotNil: [ :exercise |					self browser selectClass: exercise testCase ]]	 ] 		on: ExDomainError do: [ :ex | 			self reportError: ex for: (submission ifNotNil: [ :s | s exerciseId ]) ]! !!ClyExercismProgressCommand class methodsFor: 'activation'!contextMenuOrder		^15! !!ClyExercismProgressCommand class methodsFor: 'world menu'!worldMenuCommandOn: aBuilder	<worldMenu>		| templateCommand |		templateCommand := self new.	(aBuilder item: templateCommand defaultMenuItemName)		parent: #Exercism;		order: 1;		action: [ templateCommand execute ];		iconName: templateCommand defaultMenuIconName;		help: templateCommand description;		withSeparatorAfter! !!ClyExercismProgressCommand methodsFor: 'accessing'!defaultMenuIconName	^#home! !!ClyExercismProgressCommand methodsFor: 'accessing'!defaultMenuItemName	^'View Track Progress'! !!ClyExercismProgressCommand methodsFor: 'accessing'!description 	^'Open your Exercism track progress in a web browser'! !!ClyExercismProgressCommand methodsFor: 'execution'!execute	ExercismManager default viewOnExercism: self selectedItem! !!ClyExercismShareCommand class methodsFor: 'activation'!contextMenuOrder		^15! !!ClyExercismShareCommand class methodsFor: 'accessing'!hasConfirmedSharing	^ hasConfirmedSharing ifNil: [ false ]! !!ClyExercismShareCommand class methodsFor: 'accessing'!hasConfirmedSharing: aBoolean	^hasConfirmedSharing := aBoolean! !!ClyExercismShareCommand methodsFor: 'internal'!confirmSharing	self class hasConfirmedSharing		ifTrue: [ ^ true ].			^ (UIManager default		proceed:			'Please confirm you are happy to anonymously store your exercise code, on a temporary (7 day) random url at dpaste.com.\Exercism and Pharo.org are not associated with this service, it is provided as a convenience to help users\more easily discuss ideas with a wider community.' withCRs)		ifTrue: [ self class hasConfirmedSharing: true ]		ifFalse: [ false ]! !!ClyExercismShareCommand methodsFor: 'accessing'!defaultMenuIconName	^#publish! !!ClyExercismShareCommand methodsFor: 'accessing'!defaultMenuItemName	^'Share on web...'! !!ClyExercismShareCommand methodsFor: 'accessing'!description 	^'Create a web link to anonymously share your proposed solution on dpaste.com to discuss with others'! !!ClyExercismShareCommand methodsFor: 'execution'!execute	| exerciseName result url |	exerciseName := self selectedItem exerciseName.	self confirmSharing ifTrue: [ 	[ UIManager default 		informUser: 'Sharing...'		during: [			result := ExercismManager default				shareExerciseDPaste: 					(ExercismExercise						find: exerciseName						ifAbsent: [ :name | ^ self reportError: nil for: name asKebabCase ])].	result		ifNotNil: [ 			url := result.			UIManager default				inform: ('Successfully shared to: "{1}"!!' format: {url}).			Clipboard clipboardText: url.			WebBrowser openOn: url.			 ] 	]		on: ExercismError 		do: [ :ex | self reportError: ex for: nil ] ]! !!ClyExercismSubmitCommand class methodsFor: 'activation'!contextMenuOrder		^10! !!ClyExercismSubmitCommand methodsFor: 'accessing'!defaultMenuIconName	^#smallExport! !!ClyExercismSubmitCommand methodsFor: 'accessing'!defaultMenuItemName	^'Submit exercise...'! !!ClyExercismSubmitCommand methodsFor: 'accessing'!description 	^'Sumbit your proposed solution to Exercism for mentor review'! !!ClyExercismSubmitCommand methodsFor: 'execution'!execute	| exerciseName result |	exerciseName := self selectedItem exerciseName.	[ result := ExercismManager default		submitToExercism:			(ExercismExercise				find: exerciseName				ifAbsent: [ :name | ^ self reportError: nil for: name asKebabCase ]).	result		ifNotNil: [ UIManager default				inform: ('Successfully submitted "{1}"!!' format: {exerciseName}) ] 	]		on: ExercismError 		do: [ :ex | self reportError: ex for: nil ]! !!STONJSONWriter class methodsFor: 'instance creation'!on: writeStream	^ (super on: writeStream)			jsonMode: true;			prettyPrint: true;			newLine: String lf;			yourself! !!STONJSONWriter class methodsFor: 'instance creation'!streamContentsOf: anObject	"Answer a String, the results of streaming the writer contents for anObject (simple conveniance method)"		^String streamContents: [ :stream |			(self on: stream) nextPut: anObject ]! !!STONJSONWriter methodsFor: 'writing'!newlineIndent	"Override to adopt a json space identation convention"	prettyPrint		ifTrue: [ writeStream nextPutAll: newLine.			level timesRepeat: [ writeStream space: 2 ] ]! !!STONJSONWriter methodsFor: 'writing'!writeAssociation: association	"Overriden to support associations"		self 		encodeKey: association key 		value: association value! !!STONJSONWriter methodsFor: 'writing'!writeObject: anObject do: block	"Overridden to support Collections and Dictionaries"		jsonMode ifTrue: [ 		(anObject isKindOf: OrderedCollection)			ifTrue: [ ^self writeList: anObject ].		(anObject isKindOf: OrderedDictionary)			ifTrue: [ ^self writeMap: anObject ].		(anObject isKindOf: Dictionary)			ifTrue: [ ^self writeMap: anObject asOrderedDictionary ]].			super writeObject: anObject do: block ! !!ExUnauthorized class methodsFor: 'instance-creation'!signalBadToken: tokenStringOrNil	^ self new		token: tokenStringOrNil;		signal! !!ExUnauthorized methodsFor: 'accessing'!token	^ token! !!ExUnauthorized methodsFor: 'accessing'!token: anObject	token := anObject! !!TonelReader class methodsFor: '*ExercismTools'!fromExerciseDirectory: aDirectory	"set exercise directory where all source files of exercise occur"	^ self new		exerciseDirectory: aDirectory;		yourself ! !!TonelReader methodsFor: '*ExercismTools'!exerciseDirectory: aDirReference	packageDirectory := aDirReference! !!ExTonelWriter methodsFor: '*ExercismTools'!mappedSnapshot: aSnapshot	"extracted from #writeSnapshot: to customise behavior"		|tonelMap extensionDefinitions|	snapshot := aSnapshot.	tonelMap := Dictionary new.			"Tonel export classes with their methods, mapped from their filename to content streams"	(snapshot definitions select: #isClassDefinition)		do: [ :classDef |  |filename tonelStream|			filename := classDef exTonelFilename.			tonelStream := WriteStream on: String new.	 		self writeClass: classDef on: tonelStream.	  		tonelMap at: filename put: tonelStream ].		"... and method extensions"	extensionDefinitions := (snapshot definitions select: [ :each | 		each isMethodDefinition and: [ each isExtensionMethod ] ]) removeDuplicates.	extensionDefinitions do: [ :methodDef | |filename|		filename := methodDef exTonelFilename.		tonelMap at: filename ifAbsentPut: [ 			(WriteStream on: String new) nextPutAll: 'Extension { #name : #', methodDef className, ' }' ; lf; yourself ].		self writeMethodDefinition: methodDef on: (tonelMap at: filename). 		].	^tonelMap! !!ExTonelWriter methodsFor: 'private'!obtainPackageDir: aDefinition	"Overridden to allow a specific directory to be supplied"		^self sourceDirectory ifNil: [ super obtainPackageDir: aDefinition ]! !!ExTonelWriter methodsFor: 'accessing'!sourceDirectory	^ sourceDirectory! !!ExTonelWriter methodsFor: 'accessing'!sourceDirectory: anObject	sourceDirectory := anObject! !!ExTonelWriter methodsFor: '*ExercismTools'!writeClass: aClassDefinition on: aStream	"Not clear on whether this is an override and still needed? ~tma~"		self writeClassDefinition: aClassDefinition on: aStream.	self writeClassSideMethodDefinitions: aClassDefinition on: aStream.	self writeInstanceSideMethodDefinitions: aClassDefinition on: aStream ! !!TonelParser methodsFor: '*ExercismTools'!documentFrom: aString	self stream: aString readStream.	^self document! !!StaticTextMorph methodsFor: 'testing'!enabled	^false! !!ExercismExercise class methodsFor: 'instance creation'!allExercises	^ ExercismTest allSubclasses		select: [ :class | class class includesSelector: #exercise ]		thenCollect: [ :class | class exercise ]! !!ExercismExercise class methodsFor: 'instance creation'!bonusExercises	"self bonusExercises"	^ (self allExercises		reject:			[ :exercise | exercise isCore or: [ exercise isActive not ] ])		asSortedCollection: [ :a :b | a name < b name ]! !!ExercismExercise class methodsFor: 'instance creation'!coreExercises	^(self allExercises select: [:e | e isCore and: [e isActive]])		asSortedCollection: [ :a :b | a isFirst or: [a isFollowedBy: b ]]! !!ExercismExercise class methodsFor: 'instance creation'!exerciseNameFrom: packageOrTag	"Answer the name of the exercise given its storage RPackage or tag"				^($@ split: packageOrTag name) last asKebabCase.! !!ExercismExercise class methodsFor: 'instance creation'!find: exercismName ifAbsent: aBlock	| kebabedName |	kebabedName := exercismName asKebabCase.	^ self allExercises		detect: [ :ex | ex name = kebabedName ]		ifNone: [ aBlock cull: exercismName ]! !!ExercismExercise class methodsFor: 'instance creation'!for: anExercismTestCase	^self new		testCase: anExercismTestCase;		yourself! !!ExercismExercise methodsFor: 'comparing'!= anObject	"Answer whether the receiver and anObject represent the same object."	self == anObject		ifTrue: [ ^ true ].	self class = anObject class		ifFalse: [ ^ false ].	^ self uuid = anObject uuid! !!ExercismExercise methodsFor: 'converting'!asJsonData	"Answer a collection of attributes"		^{ 'slug' -> self name.		'uuid' -> self uuid.		'core' -> self isCore.		'auto_approve' -> self isAutoApproved.		'unlocked_by' -> self unlockReference.		'difficulty' -> self difficulty.		'topics' -> self topics } asOrderedDictionary ! !!ExercismExercise methodsFor: 'accessing'!descriptionText	"Answer the String, that is the hint text for exerciems (this is the text afer the markdown heading ## Hint"	| text offset |	text := self testCase comment.	(offset := text findString: self hintMarker) = 0 ifTrue: [ ^ text ].		^(text truncateTo: offset - 1) trimBoth	! !!ExercismExercise methodsFor: 'accessing'!difficulty	^ difficulty! !!ExercismExercise methodsFor: 'accessing'!difficulty: anInteger	difficulty := anInteger! !!ExercismExercise methodsFor: 'accessing'!exerciseClass	"Answer the main solution class, by convention this is the name of the exercise"		^ self testCase		ifNil: [ nil ]		ifNotNil:			[ :test | Smalltalk classNamed: self exerciseClassName ]! !!ExercismExercise methodsFor: 'accessing'!exerciseClassName 	^self testCase name withoutSuffix: 'Test'! !!ExercismExercise methodsFor: 'accessing'!exercisePackage	^self testCase package! !!ExercismExercise methodsFor: 'internal'!exercisePackageContainer	"Answer the package or legacy tag, that containts the exercise - must conform to #classes, #snapshot protocols"		| pkg |		^ (pkg := self exercisePackage) = ExercismManager legacyExercismPackage		ifTrue: [ pkg classTagForClass: self testCase ]		ifFalse: [ pkg ]! !!ExercismExercise methodsFor: 'navigating'!followedBy"testcase : ^self unlockedBy ifNil: ['' ] ifNotNil: [ :parent | parent followedBy ]"	^ self class coreExercises detect: [ :ex | ex isUnlockedBy: self ] ifNone: [  nil ]! !!ExercismExercise methodsFor: 'gt-inspector'!gtInspectorDetailsIn: composite	<gtInspectorPresentationOrder: 30>	^ composite table		title: 'Exercism';		display: [ 					{'exercise' -> self name.					'core' -> true.					'difficulty' -> self difficulty.					'unlocks' -> self unlockedExercises.					'topics' -> self topics.					'tests' -> self testCase.					'solution' -> self exerciseClass.					'uuid' -> self uuid.					'followed by' -> self followedBy.					'hint' -> self hintText.					 } ];		column: 'Property' evaluated: #key;		column: 'Value' evaluated: [:v | 			v key = 'unlocks' ifTrue: [v value asCommaString ] ifFalse: [ v value ]];		send: #value! !!ExercismExercise methodsFor: 'comparing'!hash	"Answer an integer value that is related to the identity of the receiver."	^ self class hash bitXor: self uuid hash! !!ExercismExercise methodsFor: 'accessing'!hintMarker	^ '## Hint'! !!ExercismExercise methodsFor: 'accessing'!hintText	"Answer the String, that is the hint text for exerciems (this is the text afer the markdown heading ## Hint"	| hintIndex |	self testCase comment		ifNotNil: [ :comment | 			| hintMarker |			hintMarker := self hintMarker.			hintIndex := comment findString: hintMarker.			hintIndex > 0				ifTrue: [ ^ (comment allButFirst: hintIndex + hintMarker size) trimBoth ] ].	^ ''! !!ExercismExercise methodsFor: 'accessing'!id 	^self name! !!ExercismExercise methodsFor: 'initialization'!initialize	super initialize.	self		isCore: false;		isDeprecated: false;		isAutoApproved: false;		topics: #()! !!ExercismExercise methodsFor: 'accessing'!isActive	^self testCase isActive ! !!ExercismExercise methodsFor: 'accessing'!isAutoApproved	^ isAutoApproved! !!ExercismExercise methodsFor: 'accessing'!isAutoApproved: anObject	isAutoApproved := anObject! !!ExercismExercise methodsFor: 'accessing'!isCore	^ isCore! !!ExercismExercise methodsFor: 'accessing'!isCore: aBoolean	isCore := aBoolean! !!ExercismExercise methodsFor: 'accessing'!isDefined	^self exerciseClass notNil! !!ExercismExercise methodsFor: 'accessing'!isDeprecated	^ isDeprecated! !!ExercismExercise methodsFor: 'accessing'!isDeprecated: anObject	isDeprecated := anObject! !!ExercismExercise methodsFor: 'accessing'!isEmpty	^self solutionClasses isEmpty! !!ExercismExercise methodsFor: 'comparing'!isFirst	^ self unlockedBy isNil! !!ExercismExercise methodsFor: 'comparing'!isFollowedBy: anExercismExercise	self isFirst ifTrue: [ ^ self ~= anExercismExercise ].	anExercismExercise isFirst ifTrue: [ ^ false ].			^ (anExercismExercise isUnlockedBy: self)		ifTrue: [ true ]		ifFalse: [ self isFollowedBy: anExercismExercise unlockedBy ]! !!ExercismExercise methodsFor: 'comparing'!isUnlockedBy: anExercise	^ self unlockedBy		ifNil: [ false ]		ifNotNil: [ :exercise | exercise = anExercise ]! !!ExercismExercise methodsFor: 'accessing'!name 	^self exerciseClassName asKebabCase ! !!ExercismExercise methodsFor: 'printing'!printOn: aStream		aStream		nextPutAll: 'Exercise(';		nextPutAll: self name.	self isCore		ifTrue: [ aStream nextPut: $* ].	self isDefined		ifTrue: [ aStream				space;				print: self difficulty ]		ifFalse: [ aStream nextPut: $? ].	aStream nextPut: $)! !!ExercismExercise methodsFor: 'removing'!removeSolutionClasses	"Solution classes with implemented solution to be removed - utilized by TestRunner before importing student solution"		^self solutionClasses do: [:solutionClass | solutionClass  removeFromSystem]! !!ExercismExercise methodsFor: 'accessing'!snapshot	"Answer the MCSnapshot for the exercise"		^self exercisePackageContainer snapshot! !!ExercismExercise methodsFor: 'accessing'!solutionClasses	"Answer the classes that are submitted to Exercism"		^self exercisePackageContainer classes reject: [ :c | c isKindOf: ExercismTest class ]! !!ExercismExercise methodsFor: 'accessing'!solutionId	^self testCase solutionId! !!ExercismExercise methodsFor: 'accessing'!solutionSources	"Answer a Dictionary of filename to source code mappings for the solution that will be saved on Exercism. Exercism web interface displays files in order of upload."		| packageFileMap testResult resultDictionary solutionClassNames solutionFileNames |		packageFileMap := ExTonelWriter new mappedSnapshot: self snapshot.		"Exclude non-solution classes, i.e. filter out tests"	solutionClassNames := self solutionClasses collect: [ :c | c name ].	solutionFileNames := packageFileMap keys select: [ :filename | 		solutionClassNames includes: (filename findTokens: '.') first ]. 	"Sort classes before extensions, then sort by class name"	solutionFileNames sort: [ :filenameA :filenameB | |tokensA tokensB|		tokensA := filenameA findTokens: '.'.		tokensB := filenameB findTokens: '.'.		(tokensA second, tokensA first) < (tokensB second, tokensB first) ].	"Summarise test results to show with solution"	testResult := [ self testCase suite run] on: Error do: [ TestResult new ].		"Build result in the order we want files displayed by Exercism web interface"	resultDictionary := OrderedDictionary new.	solutionFileNames do: [ :filename | 		resultDictionary at: filename put: ( packageFileMap at: filename) contents ].	resultDictionary at: 'TestResults.txt' put: testResult exercismSummary.	^ resultDictionary! !!ExercismExercise methodsFor: 'storing'!storeSolutionId: anId	^self testCase solutionId: anId! !!ExercismExercise methodsFor: 'accessing'!testCase	^ testCase! !!ExercismExercise methodsFor: 'accessing'!testCase: anExercismTest	testCase := anExercismTest! !!ExercismExercise methodsFor: 'accessing'!topics	^ topics! !!ExercismExercise methodsFor: 'accessing'!topics: aStringArray	topics := aStringArray! !!ExercismExercise methodsFor: 'accessing'!trackId	^ExercismManager trackId! !!ExercismExercise methodsFor: 'accessing'!unlockReference	"Answer the String unlock reference for a non-core exercise, otherwise nil"	^ self isCore		ifTrue: [ nil ]		ifFalse: [ self unlockedBy ifNotNil: [:parent | parent name ]]! !!ExercismExercise methodsFor: 'accessing'!unlockedBy	^ unlockedBy ! !!ExercismExercise methodsFor: 'accessing'!unlockedBy: anExercismExercise	unlockedBy := anExercismExercise! !!ExercismExercise methodsFor: 'accessing'!unlockedExercises	^self class bonusExercises select: [ :e | e isUnlockedBy: self ]! !!ExercismExercise methodsFor: 'accessing'!uuid	^self testCase uuid! !!ExercismExercise methodsFor: 'verifying'!verifySolutionForSubmission	<todo>! !!ExercismExercise methodsFor: 'accessing'!version	^self testCase version! !!ExercismExercise methodsFor: 'accessing'!wordifiedName	"Answer the english readable name of the exercise"	^ String		streamContents: [ :aStream | 			self exerciseClassName 				doWithIndex: [ :char :i | 					(char isUppercase and: [ i > 1 ])						ifTrue: [ aStream space ].					aStream nextPut: char ] ]! !!MockExercismExercise class methodsFor: 'instance creation'!allExercises 	^ { TwoFerTest exercise } asOrderedCollection ! !!ExercismHttpClient class methodsFor: 'accessing'!configureToken: your_CLI_token    "Get your_CLI_token at https://exercism.io/my/settings"    ApiToken := your_CLI_token! !!ExercismHttpClient class methodsFor: 'testing'!hasToken    ^ApiToken notNil ! !!ExercismHttpClient class methodsFor: 'accessing'!hostName	^ 'api.exercism.io'! !!ExercismHttpClient class methodsFor: 'instance creation'!new	^self newHost: self hostName! !!ExercismHttpClient class methodsFor: 'instance creation'!newHost: hostName	^self basicNew		initialize;		hostName: hostName;		yourself! !!ExercismHttpClient class methodsFor: 'caching'!promptForToken	| url linkText requestText initialAnswer title newToken  |	url := 'https://exercism.org/settings/api_cli'.		linkText := url asText		addAttribute: (TextAction new actOnClickBlock: [WebBrowser openOn: url]);		addAttribute: TextColor blue;		addAttribute: TextEmphasis underlined.		  	requestText := 'CLI token available at  ' asText, linkText.	initialAnswer := ApiToken ifNil: [ '' ]. 	title := (initialAnswer ifEmpty: [ '' ] ifNotEmpty: [ 'Unauthorized or Invalid token. ' ]) , 		'Please enter your Exercism student token'.			newToken := MorphicUIManager default requestText: requestText initialAnswer: initialAnswer title: title.	newToken ifNil: [ ^false ].	(newToken = ApiToken)  ifTrue: [ ^false ].		ExercismHttpClient configureToken: newToken.	^true "retry"! !!ExercismHttpClient class methodsFor: 'caching'!reset	ApiToken := nil	! !!ExercismHttpClient class methodsFor: 'accessing'!solutionPath    ^'/v1/solutions'! !!ExercismHttpClient class methodsFor: 'accessing'!token	^ ApiToken ifNil: [  'not-configured' ]! !!ExercismHttpClient class methodsFor: 'testing'!verifyToken	self hasToken ifFalse: [ ExUnauthorized signal ].	^ true! !!ExercismHttpClient methodsFor: 'internal'!addFormEntity: fieldName data: dataDictionary 	| multiPartFormDataEntity solutionEntity solutionPart |		multiPartFormDataEntity := ZnMultiPartFormDataEntity new.	dataDictionary keysAndValuesDo: [ :key :value| 		solutionEntity := ZnByteArrayEntity bytes: value.		solutionPart := ZnMimePart exercismFieldName: fieldName 				fileName: key entity: solutionEntity.						multiPartFormDataEntity addPart: solutionPart ].			self zincClient entity: multiPartFormDataEntity ! !!ExercismHttpClient methodsFor: 'internal'!createZnClient	^ ZnClient new		https;		host: self hostName;		yourself! !!ExercismHttpClient methodsFor: 'internal'!get	"Answer the result of an HTTP GET command, thows an Exception if 401 response"	| result |	result := self zincClient get.	self responseCode = 401		ifTrue: [ self signalUnauthorized ].	^ result! !!ExercismHttpClient methodsFor: 'public'!getLatestExercise: exerciseId for: trackName	^self getResource: (self solutionPathFor: '/latest') with: {		'track_id'-> trackName.		'exercise_id' -> exerciseId }! !!ExercismHttpClient methodsFor: 'public'!getResource: filePath	^ self getResource: filePath with: #()! !!ExercismHttpClient methodsFor: 'public'!getResource: filePath with: queryMap	self path: filePath.		queryMap asDictionary keysAndValuesDo: [ :key :value |		self queryAt: key put: value  ].		^ self get! !!ExercismHttpClient methodsFor: 'public'!getSpecifiedExercise: uuid	^self getResource: (self solutionPathFor: uuid) ! !!ExercismHttpClient methodsFor: 'accessing'!hostName	^ hostName! !!ExercismHttpClient methodsFor: 'accessing'!hostName: hostNameString	hostName := hostNameString! !!ExercismHttpClient methodsFor: 'internal'!parameterString	^ String		streamContents: [ :s | 			self zincClient request requestLine uri query 			ifNotNil: [ :q |				q associations do: [ :params | 					s						nextPutAll: params key asString;						nextPutAll: ': ';						nextPutAll: params value ] 				separatedBy: [ s nextPutAll: ', ' ]]]! !!ExercismHttpClient methodsFor: 'internal'!patch	| response status statusCode successCodes |		response := self zincClient patch.		status := self zincClient response statusLine.	statusCode := self responseCode.		successCodes := {201 -> 'SUCCESS'. 400 -> 'NO CHANGES'} asDictionary.		(successCodes includesKey: statusCode)		ifTrue: [ 				self inform: 'Exercism Submit - ' , (successCodes at: statusCode) value. 				^response ].			statusCode = 401 ifTrue: [ 		ExUnauthorized signalBadToken: ApiToken ].		self error:			'Exercism Submit - UNKNOWN ERROR (' , 			statusCode printString, ' ' , status reason , ')'! !!ExercismHttpClient methodsFor: 'public'!patchSolution: solutionIdString with: solutionDataMap		^self		path: (self solutionPathFor: solutionIdString);		addFormEntity: 'files[]' data: solutionDataMap;		patch! !!ExercismHttpClient methodsFor: 'internal'!path: aString	self zincClient path: aString! !!ExercismHttpClient methodsFor: 'internal'!post	"Answer the result of an HTTP GET command, thows an Exception if 401 response"	| result |	result := self zincClient post.	self responseCode = 401		ifTrue: [ self signalUnauthorized ].	^ result! !!ExercismHttpClient methodsFor: 'internal'!promptForToken 	^self class promptForToken! !!ExercismHttpClient methodsFor: 'internal'!queryAt: stringId put: stringValue	self zincClient queryAt: stringId put: stringValue		! !!ExercismHttpClient methodsFor: 'public'!responseCode	^ self zincClient response code! !!ExercismHttpClient methodsFor: 'internal'!signalUnauthorized	ExUnauthorized signalBadToken: ApiToken! !!ExercismHttpClient methodsFor: 'internal'!solutionPathFor: aString	"Answer a path string that accounts for missing or extra / path characters"		^ String		streamContents: [ :s | 			s				nextPutAll: self class solutionPath exPathString;				nextPutAll:					(aString first = Path delimiter						ifTrue: [ aString allButFirst ]						ifFalse: [ aString ]) ]! !!ExercismHttpClient methodsFor: 'internal'!username: nameString password: pwdString	self zincClient username: nameString password: pwdString! !!ExercismHttpClient methodsFor: 'public'!verifyToken	^ self class verifyToken! !!ExercismHttpClient methodsFor: 'accessing'!zincClient	^ (zincClient ifNil: [ zincClient := self createZnClient ])		headerAt: 'Authorization' put: 'Bearer ' , self class token;		yourself! !!ExercismDownloadCommand class methodsFor: 'command'!from: aClient track: trackId exercise: exerciseId	^(self client: aClient)		track: trackId exercise: exerciseId;		yourself! !!ExercismDownloadCommand class methodsFor: 'command'!track: trackId exercise: exerciseId	^ self from: ExercismHttpClient new track: trackId exercise: exerciseId! !!ExercismDownloadCommand methodsFor: 'execution'!execute	^ self		executeCheckingToken: [ | submission |						submission := self fetchLatestSubmission.			self fetchExerciseFilesFor: submission. 			self installExerciseFor: submission.			submission storeSolutionId.			submission ]! !!ExercismDownloadCommand methodsFor: 'internal'!installExerciseFor: submission		"submission will put sources to memory directory and load definitions from snapshot"	submission installDefinitionsFromSnapshot.	SystemAnnouncer uniqueInstance		announce: (RPackageRegistered to: submission exercise exercisePackage).	! !!ExercismDownloadCommand methodsFor: 'internal'!retrieveLatestData	| responseString |			responseString := self httpClient getLatestExercise: exerciseId for: trackName.	^ STON fromString: responseString! !!ExercismDownloadCommand methodsFor: 'accessing'!track: aStringTrackName exercise: aStringExerciseId	trackName := aStringTrackName.	exerciseId := aStringExerciseId asKebabCase.! !!ExercismFetchCommand methodsFor: 'internal'!fetchExerciseFilesFor: submission	submission		populateFileContentsWith: [ :filename | self httpClient getResource: filename ]! !!ExercismFetchCommand methodsFor: 'internal'!fetchLatestSubmission	| response |		response := self retrieveLatestData.		response		at: 'error'		ifPresent: [ :error | ExDomainError signal: (error at: 'message'), (' ({1})' format: {self httpClient parameterString} ) ].			^ExercismSubmission data: response! !!ExercismFetchCommand methodsFor: 'internal'!retrieveLatestData	^self subclassResponsibility ! !!ExercismHttpCommand class methodsFor: 'private'!client: anHttpClient	^self new		httpClient: anHttpClient;		yourself! !!ExercismHttpCommand methodsFor: 'execution'!execute	"Execute the command, answers true if successful"		^self subclassResponsibility ! !!ExercismHttpCommand methodsFor: 'execution'!executeCheckingToken: aBlock	"Evaluate aBlock, after verifying the api token"	^ [ 		self httpClient verifyToken.		aBlock value 	]		on: ExUnauthorized  		do: [ :error | 			self httpClient promptForToken				ifTrue: [ error retry ]				ifFalse: [ self inform: 'Operation Aborted!!'.					nil ] ]! !!ExercismHttpCommand methodsFor: 'accessing'!httpClient	"Anser the HttpRetriever used to marshal http requests"		^ httpClient! !!ExercismHttpCommand methodsFor: 'accessing'!httpClient: anHttpClient	"Set the HttpRetriever used to marshal http requests"		httpClient := anHttpClient! !!ExercismSubmitCommand class methodsFor: 'command'!exercise: anExercismExercise	"Submit an exercism package"	^ self from: ExercismHttpClient new exercise: anExercismExercise 		! !!ExercismSubmitCommand class methodsFor: 'command'!from: anHttpClient exercise: exercise	"Submit an exercism package"	"By default, don't submit TestCases with the solution"	exercise verifySolutionForSubmission.			^(self client: anHttpClient)		exercise: exercise;		yourself! !!ExercismSubmitCommand methodsFor: 'execution'!execute	^ [ self		executeCheckingToken: [ self httpClient				patchSolution: self exercise solutionId				with: self exercise solutionSources ] ]		on: ExSolutionIdError		do: [ :error | 			| submission |			submission := (ExercismDownloadCommand				track: self exercise trackId				exercise: self exercise name) fetchLatestSubmission.			submission storeSolutionId.			error retry ]! !!ExercismSubmitCommand methodsFor: 'accessing'!exercise	^ exercise! !!ExercismSubmitCommand methodsFor: 'accessing'!exercise: anExercismExercise	exercise := anExercismExercise! !!ExercismManager class methodsFor: 'instance creation'!default	"answer a defulat manager"		^self new! !!ExercismManager class methodsFor: 'exercism'!disableStudentCritics	ReUtilityMethodsRule enabled: false.	ReTestClassNotInPackageWithTestEndingNameRule enabled: false	! !!ExercismManager class methodsFor: 'config'!exercisePrefix	^ 'Exercise'! !!ExercismManager class methodsFor: 'exercism'!isUserMode	"Answer true if exercism is loaded in a clean image with no dev tools"		^ ((IceRepository registry collect: [ :repo | repo name ])) asArray		= #('iceberg' 'pharo' 'pharo-smalltalk')		and: [ (RPackageOrganizer default				packageNamed: 'ExercismDev'				ifAbsent: [ nil ]) isNil ]! !!ExercismManager class methodsFor: 'config'!legacyExercismPackage	"Answer the default exercism package, or nil if missing"	| packageOrganiser |		packageOrganiser := RPackageOrganizer default.	^ packageOrganiser		packageNamed: self legacyPackagePrefix 		ifAbsent: [ nil ]! !!ExercismManager class methodsFor: 'config'!legacyPackagePrefix	^ 'Exercism'! !!ExercismManager class methodsFor: 'cache'!solutionData	^ SolutionData ifNil: [ SolutionData := Dictionary new ]! !!ExercismManager class methodsFor: 'config'!trackId	^'pharo-smalltalk'! !!ExercismManager class methodsFor: 'config'!trackVersionString	^ 2 asString! !!ExercismManager class methodsFor: 'exercism'!upgrade	"upgrade an environment (called from ugrade instructions)"	self disableStudentCritics.	World closeUnchangedWindows.! !!ExercismManager class methodsFor: 'exercism'!welcome	"Setup the initial environment for a new user"	| browser |			"If in usermode, hide the repositories so solutions aren't easily visible with a git compare"	self isUserMode		ifTrue: [ 			IceRepository reset.			self disableStudentCritics ].	"Select, package and then method so it scrolls nicely into view"	browser := Smalltalk tools browser openOnPackage: WelcomeTest package.	browser		"selectPackage: Welcome package;"		selectMethod: (WelcomeTest methodNamed: #testWelcome)! !!ExercismManager class methodsFor: 'world menu'!worldMenuCommandOn: aBuilder	<worldMenu>	(aBuilder item: #Exercism)		order: 4.0;		target: self;		help: 'Tools to support Exercism'! !!ExercismManager methodsFor: 'exercism'!fetchFromExercismTo: package	"Prompt the user for an exercise to fetch, install it, and if successful, answer the loaded exercise"	| exerciseName result |	exerciseName := (UIManager default		request: 'Enter a valid exercism exercise (e.g. hello-world):')		ifNil: [ ^ nil ]		ifNotNil: [ :value | self parseTokenNamed: 'exercise' from: value ].	UIManager default inform: 'Loading: ' , exerciseName.	result := (ExercismDownloadCommand		track: self class trackId		exercise: exerciseName) execute.	^ result! !!ExercismManager methodsFor: 'helpers'!parseTokenNamed: tokenName from: aString 	| parsedTokens exerciseOffset |	parsedTokens := aString findTokens: '= '.	parsedTokens size = 1 ifTrue: [ ^parsedTokens first ].		(exerciseOffset := parsedTokens indexOf: '--',tokenName ) > 1 ifTrue: [ 		^parsedTokens at: exerciseOffset + 1 ].		^nil! !!ExercismManager methodsFor: 'exercism'!shareExerciseDPaste: exercise	| source |		source := String		streamContents: [ :s | 			s nextPutAll: '"This is a sample Pharo Exercism solution (see: https://exercism.io/my/tracks/pharo-smalltalk)'; 			cr; 			nextPutAll: 'For the reference exercise, refer to: https://github.com/exercism/pharo-smalltalk/tree/master/exercises/', exercise name, '"'; 			cr; cr.						(exercise solutionClasses asSortedCollection: [ :a :b | a name <= b name ]) do: [ :class |					(exercise exercisePackage extendsClass: class)						ifTrue: [ 							class exPrintOutExtensionsFor: exercise exercisePackage on: s ] 						ifFalse: [ 							class exPrintOutOn: s ] ] ].	^ ZnClient new		systemPolicy;		beOneShot;		url: 'http://dpaste.com/api/v2/';		addPart: (ZnMimePart fieldName: 'title' value: 'Pharo Exercism for: ', exercise name);		addPart: (ZnMimePart fieldName: 'syntax' value: 'smalltalk');		addPart: (ZnMimePart fieldName: 'expiry_days' value: '7');		addPart: (ZnMimePart fieldName: 'content' value: source);		post! !!ExercismManager methodsFor: 'exercism'!shareExerciseStfx: package	| source |	package = self class legacyExercismPackage		ifTrue: [ self error: 'Select the sub-package with your solution!!' ].			source := String		streamContents: [ :s | 			package solutionSources				keysAndValuesDo: [ :filename :code | 					s << $" << filename << $".					s cr; cr;						nextPutAll: code;						cr; cr ] ].					^ ZnClient new		systemPolicy;		beOneShot;		url: 'http://ws.stfx.eu';		contents: source;		post! !!ExercismManager methodsFor: 'exercism'!submitToExercism: packageOrTag			(packageOrTag  = self class legacyExercismPackage) 		ifTrue: [ self error: 'Select the sub-package with your solution!!' ].					^(ExercismSubmitCommand exercise: packageOrTag) execute.	! !!ExercismManager methodsFor: 'exercism'!viewOnExercism: packageOrTag	WebBrowser openOn: 'https://exercism.org/tracks/pharo'! !!ExercismSubmission class methodsFor: 'accessing'!baseUrlKey	^ 'file_download_base_url'! !!ExercismSubmission class methodsFor: 'accessing'!data: exercismDataDictionary	^ self new		exercismData:			(exercismDataDictionary				at: 'solution'				ifAbsent: [ exercismDataDictionary ]);		yourself! !!ExercismSubmission class methodsFor: 'accessing'!error: aString	^self new 		exercismData: { 'exercise' ->> {'id' -> '' }} asDictionary;		errorMessage: aString;		yourself! !!ExercismSubmission methodsFor: 'accessing'!baseUrl 	^(self exercismData at: self class baseUrlKey) exPathString.! !!ExercismSubmission methodsFor: 'accessing'!contentData	^ contentData! !!ExercismSubmission methodsFor: 'accessing'!contentData: anObject	contentData := anObject! !!ExercismSubmission methodsFor: 'accessing'!contentsFor: aString ifAbsent: anObject 	^self contentData at: aString! !!ExercismSubmission methodsFor: 'internal'!createSnapshotFromDefinitions	"return MC snapshot from definitions that can be loaded or submitted"	^ MCSnapshot fromDefinitions: self definitionsToLoadFromDirectory! !!ExercismSubmission methodsFor: 'internal'!definitionsToLoadFromDirectory		"reader will return definitions to be loaded from directory containing package directory and .st files with classes"	| tonelReader | 	tonelReader := TonelReader on: self latestExercisePackageSourceDir fileName: self exercisePackageName.	tonelReader loadDefinitions.	^ tonelReader definitions.! !!ExercismSubmission methodsFor: 'accessing'!errorMessage 	^self exercismData at: 'error' ifAbsent: [ '' ]! !!ExercismSubmission methodsFor: 'accessing'!errorMessage: aString 	self exercismData at: 'error' put: aString! !!ExercismSubmission methodsFor: 'storing'!exercise	"Answer the ExercismExercise associated with this submission"		^ExercismExercise find: self exerciseId ifAbsent: [nil]! !!ExercismSubmission methodsFor: 'accessing'!exerciseClassName 	^self exerciseId kebabAsCamelCase ! !!ExercismSubmission methodsFor: 'accessing'!exerciseId	^(self exercismData at: 'exercise') at: 'id'! !!ExercismSubmission methodsFor: 'internal'!exercisePackageName	^ ExercismManager exercisePrefix, '@', self exerciseClassName ! !!ExercismSubmission methodsFor: 'accessing'!exercismData	^ exercismData! !!ExercismSubmission methodsFor: 'accessing'!exercismData: anObject	exercismData := anObject! !!ExercismSubmission methodsFor: 'accessing'!filenames	^self exercismData at: 'files'! !!ExercismSubmission methodsFor: 'accessing'!initialize 	super initialize.	self contentData: Dictionary new.! !!ExercismSubmission methodsFor: 'internal'!installDefinitionsFromSnapshot	"tonel reader will load definitions from directory containing package directory and .st files with classes, creates MC snapshot and install package with exercise to default package organizer"		self createSnapshotFromDefinitions install! !!ExercismSubmission methodsFor: 'storing'!isValid	"Answer true if the submission resulted in a valid exercise"		^(self exercismData includesKey: 'error') not and: [ self exercise notNil ]! !!ExercismSubmission methodsFor: 'internal'!latestExercisePackageSourceDir	"return memory file reference with retreived latest exercise souuces - needed for tonel reader"	|memFileRef packageDir|	memFileRef := FileSystem memory root.	packageDir := (memFileRef / self exercisePackageName) ensureCreateDirectory.	self sourceFilenamesWithContentsDo: [:fileName :sourceString |		"do write files here"		|sourceFile|		sourceFile := packageDir / fileName.		sourceFile writeStreamDo: [:aStream | aStream nextPutAll: sourceString ]	].	^ memFileRef ! !!ExercismSubmission methodsFor: 'retrieving'!populateFileContentsWith: aBlockClosure	self sourceFilenames		do: [ :filename | 			| fileContent |			fileContent := aBlockClosure value:				self baseUrl , filename.			fileContent				ifNotNil: [ self contentData at: filename put: fileContent ] ]! !!ExercismSubmission methodsFor: 'accessing'!solutionId	^self exercismData at: 'id'! !!ExercismSubmission methodsFor: 'accessing'!sourceFilenames		^self filenames select: [:filename | filename endsWith: '.st' ]! !!ExercismSubmission methodsFor: 'retrieving'!sourceFilenamesWithContentsDo: aBlockClosure	self contentData		keysAndValuesDo:			[ :filename :contents | aBlockClosure value: filename value: contents ]! !!ExercismSubmission methodsFor: 'storing'!storeSolutionId	self exercise ifNotNil: [:exercise | exercise storeSolutionId: self solutionId]! !!ExercismSubmission methodsFor: 'accessing'!user	^(self exercismData at: 'user') at: 'handle'! !!WorldMorph methodsFor: '*ExercismTools'!openModal: aSystemWindow	|modalMorph|	modalMorph := self submorphs detect: #isSystemWindow ifNone: [ self error: 'Could not find a system window to open a modal dialog.' ].	^ modalMorph openModal: aSystemWindow! !!String methodsFor: '*ExercismTools'!->> aCollectionOfAssociations	"Similar to -> but converts aCollection to anOrderedDictionary, useful when building JSON structures"	^self -> aCollectionOfAssociations asOrderedDictionary ! !!String methodsFor: '*ExercismTools'!asKebabCase	"Answer a String that converts the CamelCase input to camel-case kebab output 	used by exercism"	^ self class		streamContents: [ :kebabStream |			self uncapitalized				do: [ :char |					char isUppercase						ifTrue: [ kebabStream nextPut: $- ].					kebabStream nextPut: char asLowercase ] ]! !!String methodsFor: '*ExercismTools'!asSentenceCase	"Converts string of selector name to human readable sentence."	^ self class		streamContents: [ :aStream |			self do: [ :char |					char isUppercase						ifTrue: [ aStream nextPut: Character space ].					aStream nextPut: char asLowercase ] ]! !!String methodsFor: '*ExercismTools'!encodeDoublingDoubleQuotesOn: s	"Print inside string quotes, doubling inbedded quotes."	self		do: [ :c | 			c = $"				ifTrue: [ s << $" ].			s << c ]! !!String methodsFor: '*ExercismTools'!exPathString	"Answer the receiver as a valid path, with a trailing /"	^ String		streamContents: [ :s | 			s nextPutAll: self.			self last = $/				ifFalse: [ s nextPut: $/ ] ]! !!String methodsFor: '*ExercismTools'!kebabAsCamelCase	"Answer a String that converts the CamelCase input to camel-case kebab output 	used by exercism"	^ (self copyReplaceAll: {$-} with: {Character space}) asCamelCase.! !"ExercismTools"!!WelcomeTest commentStamp: '' prior: 0!To start your Exercism journey, right click on the Exercise@Welcome package (or use the top level Exercism menu) and select 'Exercism | Fetch new exercise', and then type: hello-world.Note: Each exercise will have some instructions in its test Comment tab, so be sure to read them when starting a new challenge.!!WelcomeTest class methodsFor: 'config'!followedBy 	^'HelloWorld'! !!WelcomeTest methodsFor: 'tests'!testWelcome	"This is a sample Pharo test fixture. 		TIP 1: Try running this test by clicking on the gray orb next to the method name above.	TIP 2: Click to the class Comment tab for more information on getting started."		self assert: #('Welcome' 'to' 'Pharo') size equals: 3! !"Exercise@Welcome"!!HelloWorldTest commentStamp: '' prior: 0!# Hello WorldThe classical introductory exercise. Just say "Hello, World!!".["Hello, World!!"](http://en.wikipedia.org/wiki/%22Hello,_world!!%22_program) isthe traditional first program for beginning programming in a new languageor environment.The objectives are simple:- Write a function that returns the string "Hello, World!!".- Run the test suite and make sure that it succeeds.- Submit your solution and check it at the website.If everything goes well, you will be ready to fetch your first real exercise## HintIf you are editting this file in a text editor and not in Pharo - please review the [Getting Started](https://exercism.io/tracks/pharo/installation) section. While you can use a text editor, the Pharo IDE is partly what makes the language so special.In Pharo you can run code (including tests) with broken methods and missing classes.  When the VM encounters broken code, it raises a debugger which lets you explore the problem a little better.  You then have the option to press the Create button to add a missing class or method, as well as correct any code that causes an error. When you do so, the debugger will backup and let you resume execution with your new changes.Try doing this with your HelloWorld example, by simply running any one of the unit test methods.!!HelloWorldTest class methodsFor: 'config'!exercise	"Answer the configured exercise meta data for this exercise, an ExercismExercise.	HelloWorld is a special case as it's the first exercise"		^(ExercismExercise for: self) 		isCore: true;		isAutoApproved: true;		difficulty: 1;		topics: #('introduction' 'strings');		yourself! !!HelloWorldTest class methodsFor: 'config'!uuid	"Answer a unique id for this exercise"	^'a1812b5e-2788-4ea6-b948-bfe54edeb0da'! !!HelloWorldTest class methodsFor: 'config'!version	"Answer the exercise version number string this test was derived from"		^'1.1.0'  ! !!HelloWorldTest methodsFor: 'testing'!testHello	self assert: HelloWorld sayHello equals: 'Hello, World!!'! !!HelloWorld class methodsFor: 'example'!sayHello	^ 'Goodbye, Mars!!'! !!HelloWorld methodsFor: 'as yet unclassified' stamp: 'AndyMarks 12/3/2023 10:50'!sayHello	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"					^'Hello world!!'.! !!HelloWorld methodsFor: 'example' stamp: 'AndyMarks 12/3/2023 10:50' prior: 33629014!sayHello	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"					^'Hello, World!!'.! !HelloWorld removeSelector: #sayHello!!HelloWorld class methodsFor: 'example' stamp: 'AndyMarks 12/3/2023 10:53' prior: 33628899!sayHello	^ 'Hello, World!!'! !!TwoFerTest commentStamp: '' prior: 0!# Two Fer`Two-fer` or `2-fer` is short for two for one. One for you and one for me.Given a name, return a string with the message:```textOne for X, one for me.```Where X is the given name.However, if the name is missing, return the string:```textOne for you, one for me.```Here are some examples:|Name    | String to return |:------:|:-----------------: |Alice   | One for Alice, one for me. |Bob     | One for Bob, one for me.|        | One for you, one for me.|Zaphod  | One for Zaphod, one for me.## HintIn Pharo, classes are objects that can have instance and class methods, however unlike HelloWorld the tests for TwoFer have been written to call instance methods. Typically class methods are used for constructing new objects (like a contructor in other languages).While referring to methods, its useful to know that a method which has no parameters, is called a unary method, and a method taking multiple parameters, each deliniated by a word ending with a ':', is called a keyword method.There is also a third type of method, binary, which takes only 1 parameter and uses a symbol(s) for a name (typically a mathematical one like: +, -, & etc).!!TwoFerTest class methodsFor: 'config'!exercise	"Answer the configured exercise meta data for this exercise, an ExercismExercise"		^(self createExerciseAfter: HelloWorldTest)		isCore: true;		difficulty: 1;		topics: #('strings' 'text-formatting' 'refactoring');		yourself	! !!TwoFerTest class methodsFor: 'config'!uuid	"Answer a unique id for this exercise"	^'9806fcc0-8505-4012-bd64-3f7468014df5'! !!TwoFerTest class methodsFor: 'config'!version	"Answer the exercise version number string this test was derived from"		^'1.2.0'! !!TwoFerTest methodsFor: 'running'!setUp	super setUp.	twoFer := TwoFer new.! !!TwoFerTest methodsFor: 'tests'!testANameGiven	self assert: (twoFer who: 'Alice') equals: 'One for Alice, one for me.'! !!TwoFerTest methodsFor: 'tests'!testAnotherNameGiven	self assert: (twoFer who: 'Bob') equals: 'One for Bob, one for me.' ! !!TwoFerTest methodsFor: 'tests'!testNoNameGiven	self assert: twoFer who equals: 'One for you, one for me.' 	! !Object subclass: #TwoFer		instanceVariableNames: '' 		classVariableNames: ''		category: 'Exercise@TwoFer'!!TwoFer methodsFor: 'as yet unclassified' stamp: 'AndyMarks 12/3/2023 11:01'!who	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"					^'One for you, one for me.'.! !!TwoFer methodsFor: 'accessing' stamp: 'AndyMarks 12/3/2023 11:02' prior: 33631946!who	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"					^self who: ''.! !!TwoFer methodsFor: 'accessing' stamp: 'AndyMarks 12/3/2023 11:03' prior: 33632172!who	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"					^'One for you, one for me.'.! !!TwoFer methodsFor: 'accessing' stamp: 'AndyMarks 12/3/2023 11:04'!who:	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"					name.   ^'One for Alice, one for me.'.! !!TwoFer methodsFor: 'accessing' stamp: 'AndyMarks 12/3/2023 11:05' prior: 33632594!who:	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"					name.   ^'One for ', name, ', one for me.'.! !!TwoFer methodsFor: 'accessing' stamp: 'AndyMarks 12/3/2023 11:05' prior: 33632384!who	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"					^self who: 'me'.! !!TwoFer methodsFor: 'accessing' stamp: 'AndyMarks 12/3/2023 11:05' prior: 33633075!who	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"					^self who: 'you'.! !!TwoFer methodsFor: 'accessing' stamp: 'AndyMarks 12/3/2023 11:10' prior: 33633289!who	"default argument implementation of #who:"	"scope: class-variables  &  instance-variables"					^self who: 'you'.! !!TwoFer methodsFor: 'accessing' stamp: 'AndyMarks 12/3/2023 11:13' prior: 33632832!who:	"returns a "	"scope: class-variables  &  instance-variables"					name.	   ^'One for ', name, ', one for me.'.! !!TwoFer methodsFor: 'accessing' stamp: 'AndyMarks 12/3/2023 11:14' prior: 33633712!who: aName	"returns a "	"scope: class-variables  &  instance-variables"		   ^'One for ', aName, ', one for me.'.! !!LeapTest commentStamp: '' prior: 0!# LeapGiven a year, report if it is a leap year.The tricky thing here is that a leap year in the Gregorian calendar occurs:```texton every year that is evenly divisible by 4  except every year that is evenly divisible by 100    unless the year is also evenly divisible by 400```For example, 1997 is not a leap year, but 1996 is.  1900 is not a leapyear, but 2000 is.## NotesThough our exercise adopts some very simple rules, there is more tolearn!!For a delightful, four minute explanation of the whole leap yearphenomenon, go watch [this youtube video][video].[video]: http://www.youtube.com/watch?v=xX96xng7sAE## HintThe tests for this exercise (and future exercises), are prefix numbered like 'test00_'. This is not a normal convention in Pharo, however to ease the study of the language it is useful to present tests in a deterministic order.For this exercise, study the 'arithmetic' method category for class Number, as well as how boolean operators are also defined as messages. Notice how "and:" and "or:" are implented in the classes True and False. You can use the context menu item "senders of..." to view how other parts of Pharo use these operators.You may also find something useful trying... `World > Tools > Finder > Examples > 20 . 4 . true`<br> which is asking Pharo which operations between the first and second elements result in the third.<br> [View demo][demo][demo]: https://github.com/exercism/pharo-smalltalk/raw/master/docs/images/Hint-Finder-Leap.gif!!LeapTest class methodsFor: 'config'!exercise	"Answer the configured exercise meta data for this exercise, an ExercismExercise"		^(self createExerciseAfter: TwoFerTest)		isCore: true;		difficulty: 1;		topics: #('math' 'conditionals' 'logic');		yourself					! !!LeapTest class methodsFor: 'config'!uuid	"Answer a unique id for this exercise"	^'82b07f5c-119c-4250-8c07-a0a7e1a95458'! !!LeapTest class methodsFor: 'config'!version	"Generated from specification: 25 February 2019"	^'1.5.1'! !!LeapTest methodsFor: 'running'!setUp	super setUp.	leapCalculator := Leap new! !!LeapTest methodsFor: 'tests'!test01_YearNotDivisibleBy4CommonYear	| result |	result := leapCalculator leapYear: 2015 .	self assert: result equals: false! !!LeapTest methodsFor: 'tests'!test02_YearDivisibleBy2NotDivisibleBy4CommonYear	| result |	result := leapCalculator leapYear: 1970 .	self assert: result equals: false! !!LeapTest methodsFor: 'tests'!test03_YearDivisibleBy4NotDivisibleBy100LeapYear	| result |	result := leapCalculator leapYear: 1996 .	self assert: result equals: true! !!LeapTest methodsFor: 'tests'!test04_YearDivisibleBy100NotDivisibleBy400CommonYear	| result |	result := leapCalculator leapYear: 2100 .	self assert: result equals: false! !!LeapTest methodsFor: 'tests'!test05_YearDivisibleBy400LeapYear	| result |	result := leapCalculator leapYear: 2000 .	self assert: result equals: true! !!LeapTest methodsFor: 'tests'!test06_YearDivisibleBy200NotDivisibleBy400CommonYear	| result |	result := leapCalculator leapYear: 1800 .	self assert: result equals: false! !!LeapTest methodsFor: 'extra'!testMisuseOfSelector	self verifySolution: leapCalculator class avoidsSelector: #isLeapYear! !Object subclass: #Leap		instanceVariableNames: '' 		classVariableNames: ''		category: 'Exercise@Leap'!!Leap methodsFor: 'as yet unclassified' stamp: 'AndyMarks 12/3/2023 11:18'!leapYear: aYear	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"					^false.! !!Leap methodsFor: 'queries' stamp: 'AndyMarks 12/3/2023 11:25' prior: 33637515!leapYear: aYear	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"					| divisibleBy4 divisibleby100 divisibleBy400 |		^false.! !!Leap methodsFor: 'queries' stamp: 'AndyMarks 12/3/2023 11:25' prior: 33637728!leapYear: aYear	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"					| divisibleBy4 divisibleby100 divisibleBy400 |		divisibleBy4 := aYear / 4 == 0.	^false.! !!Leap methodsFor: 'queries' stamp: 'AndyMarks 12/3/2023 11:26' prior: 33637991!leapYear: aYear	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"					| divisibleBy4 divisibleby100 divisibleBy400 |		divisibleBy4 := aYear / 4 == 0.	divisibleby100 := aYear / 100 == 0.	divisibleBy400 := aYear / 400 == 0.		^false.! !!Leap methodsFor: 'queries' stamp: 'AndyMarks 12/3/2023 11:27' prior: 33638287!leapYear: aYear	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"					| divisibleBy4 divisibleby100 divisibleBy400 |		divisibleBy4 := aYear / 4 == 0.	divisibleby100 := aYear / 100 == 0.	divisibleBy400 := aYear / 400 == 0.		^divisibleBy4.! !!Leap methodsFor: 'queries' stamp: 'AndyMarks 12/3/2023 13:11' prior: 33638659!leapYear: aYear	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"					| divisibleBy4 divisibleby100 divisibleBy400 |		divisibleBy4 := aYear / 4 == 0.	divisibleby100 := aYear / 100 == 0.	divisibleBy400 := aYear / 400 == 0.		^divisibleBy400	ifTrue: true	ifFalse:		divisibleby100 		ifTrue: true		ifFalse: divisibleBy4 ! !!Leap methodsFor: 'queries' stamp: 'AndyMarks 12/3/2023 13:12' prior: 33639038!leapYear: aYear	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"					| divisibleBy4 divisibleby100 divisibleBy400 |		divisibleBy4 := aYear / 4 == 0.	divisibleby100 := aYear / 100 == 0.	divisibleBy400 := aYear / 400 == 0.		^divisibleBy400	ifTrue: true	ifFalse: [ 		divisibleby100 		ifTrue: true		ifFalse: divisibleBy4  ]! !!Leap methodsFor: 'queries' stamp: 'AndyMarks 12/3/2023 13:16' prior: 33639500!leapYear: aYear	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"					| divisibleBy4 divisibleby100 divisibleBy400 |		divisibleBy4 := aYear / 4 == 0.	divisibleby100 := aYear / 100 == 0.	divisibleBy400 := aYear / 400 == 0.		^divisibleBy400		ifTrue: true		ifFalse: [ 			divisibleby100 				ifTrue: true				ifFalse: divisibleBy4  ]! !!Leap methodsFor: 'queries' stamp: 'AndyMarks 12/3/2023 13:20' prior: 33639967!leapYear: aYear	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"					| divisibleBy4 divisibleby100 divisibleBy400 |		divisibleBy4 := aYear // 4 == 0.	divisibleby100 := aYear // 100 == 0.	divisibleBy400 := aYear // 400 == 0.		^divisibleBy400		ifTrue: true		ifFalse: [ 			divisibleby100 				ifTrue: true				ifFalse: divisibleBy4  ]! !!Leap methodsFor: 'queries' stamp: 'AndyMarks 12/3/2023 13:24' prior: 33640441!leapYear: aYear	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"					| divisibleBy4 divisibleby100 divisibleBy400 |		divisibleBy4 := aYear rem: 4 == 0.	divisibleby100 := aYear rem: 100 == 0.	divisibleBy400 := aYear rem: 400 == 0.		^divisibleBy400		ifTrue: true		ifFalse: [ 			divisibleby100 				ifTrue: true				ifFalse: divisibleBy4  ]! !!Leap methodsFor: 'queries' stamp: 'AndyMarks 12/3/2023 13:26' prior: 33640918!leapYear: aYear	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"					| divisibleBy4 divisibleby100 divisibleBy400 |		divisibleBy4 := (aYear rem: 4) == 0.	divisibleby100 := (aYear rem: 100) == 0.	divisibleBy400 := (aYear rem: 400) == 0.		^divisibleBy400		ifTrue: true		ifFalse: [ 			divisibleby100 				ifTrue: true				ifFalse: divisibleBy4  ]! !!Leap methodsFor: 'queries' stamp: 'AndyMarks 12/3/2023 13:33' prior: 33641401!leapYear: aYear	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"					| divisibleBy4 divisibleby100 divisibleBy400 |		divisibleBy4 := (aYear rem: 4) == 0.	divisibleby100 := (aYear rem: 100) == 0.	divisibleBy400 := (aYear rem: 400) == 0.	^divisibleBy4 		ifTrue: [ 			divisibleby100 and: divisibleBy400 				ifTrue: true				ifFalse: false			 ]		ifFalse: false.	! !!Leap methodsFor: 'queries' stamp: 'AndyMarks 12/3/2023 13:34' prior: 33641401!leapYear: aYear	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"					| divisibleBy4 divisibleby100 divisibleBy400 |		divisibleBy4 := (aYear rem: 4) == 0.	divisibleby100 := (aYear rem: 100) == 0.	divisibleBy400 := (aYear rem: 400) == 0.	^divisibleBy4 		ifTrue: [ 			divisibleBy400				ifTrue: true				ifFalse: divisibleby100 			 ]		ifFalse: false.	! !!Leap methodsFor: 'queries' stamp: 'AndyMarks 12/3/2023 13:36' prior: 33642397!leapYear: aYear	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"					| divisibleBy4 divisibleby100 divisibleBy400 |		divisibleBy4 := (aYear rem: 4) == 0.	divisibleby100 := (aYear rem: 100) == 0.	divisibleBy400 := (aYear rem: 400) == 0.	^divisibleBy4 		ifTrue: [ 			divisibleby100 not and: divisibleBy400 				ifTrue: true				ifFalse: divisibleby100 ]		ifFalse: false.	! !!Leap methodsFor: 'queries' stamp: 'AndyMarks 12/3/2023 13:36' prior: 33642893!leapYear: aYear	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"					| divisibleBy4 divisibleby100 divisibleBy400 |		divisibleBy4 := (aYear rem: 4) == 0.	divisibleby100 := (aYear rem: 100) == 0.	divisibleBy400 := (aYear rem: 400) == 0.	^divisibleBy4 		ifTrue: [ 			(divisibleby100 not and: divisibleBy400) 				ifTrue: true				ifFalse: divisibleby100 ]		ifFalse: false.	! !!Leap methodsFor: 'queries' stamp: 'AndyMarks 12/3/2023 13:38' prior: 33643409!leapYear: aYear	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"					| divisibleBy4 divisibleby100 divisibleBy400 |		divisibleBy4 := (aYear rem: 4) == 0.	divisibleby100 := (aYear rem: 100) == 0.	divisibleBy400 := (aYear rem: 400) == 0.	^divisibleBy4 		ifTrue: [ 			(divisibleby100 not and: divisibleBy400) 				ifTrue: true				ifFalse: divisibleBy4  ]		ifFalse: false.	! !!Leap methodsFor: 'queries' stamp: 'AndyMarks 12/3/2023 13:40' prior: 33643927!leapYear: aYear	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"					| divisibleBy4 divisibleby100 divisibleBy400 |		divisibleBy4 := (aYear rem: 4) == 0.	divisibleby100 := (aYear rem: 100) == 0.	divisibleBy400 := (aYear rem: 400) == 0.	^divisibleBy4 		ifTrue: [ 			divisibleby100				ifTrue: divisibleBy400 				ifFalse: false  ]		ifFalse: false.	! !!Leap methodsFor: 'queries' stamp: 'AndyMarks 12/3/2023 13:40' prior: 33644444!leapYear: aYear	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"					| divisibleBy4 divisibleby100 divisibleBy400 |		divisibleBy4 := (aYear rem: 4) == 0.	divisibleby100 := (aYear rem: 100) == 0.	divisibleBy400 := (aYear rem: 400) == 0.	^divisibleBy4 		ifTrue: [ 			divisibleby100				ifTrue: divisibleBy400 				ifFalse: true  ]		ifFalse: false.	! !!Leap methodsFor: 'queries' stamp: 'AndyMarks 12/3/2023 13:41' prior: 33644938!leapYear: aYear	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"					| divisibleBy4 divisibleby100 divisibleBy400 |		divisibleBy4 := (aYear rem: 4) == 0.	divisibleby100 := (aYear rem: 100) == 0.	divisibleBy400 := (aYear rem: 400) == 0.	^divisibleBy4 		ifTrue: 			divisibleby100				ifTrue: divisibleBy400 				ifFalse: true		ifFalse: false.	! !!Leap methodsFor: 'queries' stamp: 'AndyMarks 12/3/2023 13:41' prior: 33645431!leapYear: aYear	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"					| divisibleBy4 divisibleby100 divisibleBy400 |		divisibleBy4 := (aYear rem: 4) == 0.	divisibleby100 := (aYear rem: 100) == 0.	divisibleBy400 := (aYear rem: 400) == 0.	^divisibleBy4 		ifTrue: [			divisibleby100				ifTrue: divisibleBy400 				ifFalse: true  ]		ifFalse: false.	! !!ReverseStringTest commentStamp: '' prior: 0!# Reverse StringReverse a stringFor example:input: "cool"output: "looc"## HintWhile there is are `#reversed` and `#reverseDo:` methods for Strings, can you figure out how to do this yourself using lower level character iteration and streams? To help you browse code, Pharo has a neat code finder tool. Press Shift-Enter to activate it.NOTE: We have followed the Exercism convention of calling the solution ReverseString, however a more Smalltalk name would be StringReverser.## Smalltalk and StringsConcerning strings, there are some obvious little details like double quotes for comments, single quotes for strings, and special syntax for characters (e.g., $x for character x) that might confuse you on first reading as the conventions are different from those used by other languages. There is also the notion of a symbol which is a string that is unique memory-wide; i.e. when it is constructed (typically at compile-time), a memory search is made to determine if another one like it exists; and only the original is used. The rationale is not just memory saving but significant speed-up when comparing symbols.```smalltalk"this is a comment"'this is a string'#'this is a symbol'#thisIsASymbolToo```There are also very few commas in Smalltalk programs because they play no syntactic role.Thats why array literals, for example, are comma-free; e.g.`#(1 2 3 4 5)`However, comma is an operator in its own right and you will notice it when concatenating two strings; e.g.`'string1', 'string2'`Finally, it's worth knowing that Strings and Characters are distinct classes. String are a collection of Characters. This can catch you off guard when iterating over strings as you can end up giving characters to a method that expects strings. Consider...```smalltalk(('hello' at: 2) = $e) inspect.(('hello' at: 2) = 'e') inspect.```## Smalltalk and StreamsStreams are useful for sequential reading and writing.  They make code cleaner by avoiding the need to increment an index.Streams operate on any collection.```smalltalkstream := WriteStream on: String new.stream nextPut: $h ; nextPutAll: 'ell' ; nextPut: $o.stream contents inspect```!!ReverseStringTest class methodsFor: 'config'!exercise	"Answer the configured exercise meta data for this exercise, an ExercismExercise"		^(self createExerciseAfter: LeapTest)		isCore: true;		difficulty: 1;		topics: #('strings' 'iteration');		yourself					! !!ReverseStringTest class methodsFor: 'config'!uuid	"Answer a unique id for this exercise"	^'bab40685-2f87-4d4f-8886-0a4d21a0d90d'! !!ReverseStringTest class methodsFor: 'config'!version	"Generated from specification: 25 February 2019"	^'1.1.0'! !!ReverseStringTest methodsFor: 'running'!setUp	super setUp.	reverseStringCalculator := ReverseString new! !!ReverseStringTest methodsFor: 'tests'!test01_AnEmptyString	| result |	result := reverseStringCalculator reverseValue: '' .	self assert: result equals: ''! !!ReverseStringTest methodsFor: 'tests'!test02_AWord	| result |	result := reverseStringCalculator reverseValue: 'robot' .	self assert: result equals: 'tobor'! !!ReverseStringTest methodsFor: 'tests'!test03_ACapitalizedWord	| result |	result := reverseStringCalculator reverseValue: 'Ramen' .	self assert: result equals: 'nemaR'! !!ReverseStringTest methodsFor: 'tests'!test04_ASentenceWithPunctuation	| result |	result := reverseStringCalculator reverseValue: 'I''m hungry!!' .	self assert: result equals: '!!yrgnuh m''I'! !!ReverseStringTest methodsFor: 'tests'!test05_APalindrome	| result |	result := reverseStringCalculator reverseValue: 'racecar' .	self assert: result equals: 'racecar'! !!ReverseStringTest methodsFor: 'extra'!testMisuseOfSelector	self verifySolution: reverseStringCalculator class avoidsSelector: #reverse.	self verifySolution: reverseStringCalculator class avoidsSelector: #reversed! !Object subclass: #ReverseString	instanceVariableNames: '' 	classVariableNames: ''	package: ''!!ReverseString methodsFor: 'as yet unclassified' stamp: 'AndyMarks 12/4/2023 20:53'!reverseValue: aString	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"					^aString.! !!ReverseString methodsFor: 'as yet unclassified' stamp: 'AndyMarks 12/4/2023 20:54' prior: 33650487!reverseValue: aString	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"					^aString reversed .! !!ReverseString methodsFor: 'as yet unclassified' stamp: 'AndyMarks 12/4/2023 21:00' prior: 33650729!reverseValue: aString	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"			| reversed |				reversed := WriteStream on: String new.		^reversed.! !!ReverseString methodsFor: 'as yet unclassified' stamp: 'AndyMarks 12/4/2023 21:03' prior: 33650981!reverseValue: aString	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"			| reversed length |				reversed := WriteStream on: String new.	length := aString size .		aString doWithIndex: [ :char :i |  ].		^reversed.! !!ReverseString methodsFor: 'as yet unclassified' stamp: 'AndyMarks 12/4/2023 21:04' prior: 33651283!reverseValue: aString	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"			| reversed length |				reversed := WriteStream on: String new.	length := aString size .		aString doWithIndex: [ :char :i | reversed nextPut: aString at: (length - i) ].		^reversed.! !!ReverseString methodsFor: 'as yet unclassified' stamp: 'AndyMarks 12/4/2023 21:04' prior: 33651659!reverseValue: aString	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"			| reversed length |				reversed := WriteStream on: String new.	length := aString size .		aString doWithIndex: [ :char :i | reversed nextPut: (aString at: (length - i)) ].		^reversed.! !!ReverseString methodsFor: 'as yet unclassified' stamp: 'AndyMarks 12/4/2023 21:08' prior: 33652077!reverseValue: aString	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"			| reversed length |				reversed := WriteStream on: String new.	length := aString size .		aString doWithIndex: [ :char :i | reversed nextPut: (aString at: (length - i)) ].		^reversed contents inspect.! !Object subclass: #Scratch	instanceVariableNames: '' 	classVariableNames: ''	package: ''!!Scratch methodsFor: 'as yet unclassified' stamp: 'AndyMarks 12/4/2023 21:16'!methodSelectorAndArgumentNames	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"			| reversed length aString |				aString := 'robot'.	reversed := WriteStream on: String new.	length := aString size .		aString doWithIndex: [ :char :i | reversed nextPut: (aString at: (length - i)) ].		^reversed contents inspect.! !!Scratch methodsFor: 'as yet unclassified' stamp: 'AndyMarks 12/4/2023 21:17' prior: 33653005!methodSelectorAndArgumentNames	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"			| reversed length aString |				aString := 'robot'.	reversed := WriteStream on: String new.	length := aString size .		aString doWithIndex: [ :char :i | reversed nextPut: (aString at: ((length - i) + 1))].		^reversed contents inspect.! !!Scratch methodsFor: 'as yet unclassified' stamp: 'AndyMarks 12/4/2023 21:18' prior: 33653474!methodSelectorAndArgumentNames	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"			| reversed length aString result |				aString := 'robot'.	reversed := WriteStream on: String new.	length := aString size .		aString doWithIndex: [ :char :i | reversed nextPut: (aString at: ((length - i) + 1))].	result := reversed contents inspect.	^result.! !!ReverseString methodsFor: 'modifying' stamp: 'AndyMarks 12/4/2023 21:20' prior: 33652497!reverseValue: aString	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"			| reversed length |				reversed := WriteStream on: String new.	length := aString size .		aString doWithIndex: [ :char :i | reversed nextPut: (aString at: ((length - i) + 1)) ].		^reversed contents inspect.! !!ReverseString methodsFor: 'modifying' stamp: 'AndyMarks 12/9/2023 14:21' prior: 33654443!reverseValue: aString	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"			| reversed length |				reversed := WriteStream on: String new.	length := aString size .		aString doWithIndex: [ :char :i | reversed nextPut: (aString at: ((length - i) + 1)) ].		^reversed contents.! !!IsogramTest commentStamp: '' prior: 0!# IsogramDetermine if a word or phrase is an isogram.An isogram (also known as a "nonpattern word") is a word or phrase without a repeating letter, however spaces and hyphens are allowed to appear multiple times.Examples of isograms:- lumberjacks- background- downstream- six-year-oldThe word *isograms*, however, is not an isogram, because the s repeats.## HintThere is a range of interesting data types in Pharo, it's worth taking the time to browse the  hierarchy of class Collection and reading some of the class comments and running some of the examples.!!IsogramTest class methodsFor: 'config'!exercise	"Answer the configured exercise meta data for this exercise, an ExercismExercise"		^(self createExerciseAfter: ReverseStringTest)		isCore: true;		difficulty: 2;		topics: #('strings' 'iteration');		yourself! !!IsogramTest class methodsFor: 'config'!uuid	"Answer a unique id for this exercise"	^'9e0074be-4a3f-0d00-bb4e-73e5071d6982'! !!IsogramTest class methodsFor: 'config'!version	"Generated from specification: 28 February 2019"	^'1.7.0'! !!IsogramTest methodsFor: 'running'!setUp	super setUp.	isogramCalculator := Isogram new! !!IsogramTest methodsFor: 'tests'!test01_CheckIfTheGivenStringIsAnIsogramEmptyString	| result |	result := isogramCalculator isIsogramPhrase: '' .	self assert: result equals: true! !!IsogramTest methodsFor: 'tests'!test02_CheckIfTheGivenStringIsAnIsogramIsogramWithOnlyLowerCaseCharacters	| result |	result := isogramCalculator isIsogramPhrase: 'isogram' .	self assert: result equals: true! !!IsogramTest methodsFor: 'tests'!test03_CheckIfTheGivenStringIsAnIsogramWordWithOneDuplicatedCharacter	| result |	result := isogramCalculator isIsogramPhrase: 'eleven' .	self assert: result equals: false! !!IsogramTest methodsFor: 'tests'!test04_CheckIfTheGivenStringIsAnIsogramWordWithOneDuplicatedCharacterFromTheEndOfTheAlphabet	| result |	result := isogramCalculator isIsogramPhrase: 'zzyzx' .	self assert: result equals: false! !!IsogramTest methodsFor: 'tests'!test05_CheckIfTheGivenStringIsAnIsogramLongestReportedEnglishIsogram	| result |	result := isogramCalculator isIsogramPhrase: 'subdermatoglyphic' .	self assert: result equals: true! !!IsogramTest methodsFor: 'tests'!test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharacterInMixedCase	| result |	result := isogramCalculator isIsogramPhrase: 'Alphabet' .	self assert: result equals: false! !!IsogramTest methodsFor: 'tests'!test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharacterInMixedCaseLowercaseFirst	| result |	result := isogramCalculator isIsogramPhrase: 'alphAbet' .	self assert: result equals: false! !!IsogramTest methodsFor: 'tests'!test08_CheckIfTheGivenStringIsAnIsogramHypotheticalIsogrammicWordWithHyphen	| result |	result := isogramCalculator isIsogramPhrase: 'thumbscrew-japingly' .	self assert: result equals: true! !!IsogramTest methodsFor: 'tests'!test09_CheckIfTheGivenStringIsAnIsogramHypotheticalWordWithDuplicatedCharacterFollowingHyphen	| result |	result := isogramCalculator isIsogramPhrase: 'thumbscrew-jappingly' .	self assert: result equals: false! !!IsogramTest methodsFor: 'tests'!test10_CheckIfTheGivenStringIsAnIsogramIsogramWithDuplicatedHyphen	| result |	result := isogramCalculator isIsogramPhrase: 'six-year-old' .	self assert: result equals: true! !!IsogramTest methodsFor: 'tests'!test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIsAnIsogram	| result |	result := isogramCalculator isIsogramPhrase: 'Emily Jung Schwartzkopf' .	self assert: result equals: true! !!IsogramTest methodsFor: 'tests'!test12_CheckIfTheGivenStringIsAnIsogramDuplicatedCharacterInTheMiddle	| result |	result := isogramCalculator isIsogramPhrase: 'accentor' .	self assert: result equals: false! !!IsogramTest methodsFor: 'tests'!test13_CheckIfTheGivenStringIsAnIsogramSameFirstAndLastCharacters	| result |	result := isogramCalculator isIsogramPhrase: 'angola' .	self assert: result equals: false! !Object subclass: #Isogram	instanceVariableNames: '' 	classVariableNames: ''	package: ''!Object subclass: #Isogram	instanceVariableNames: '' 	classVariableNames: ''	package: 'Exercise@Isogram'!!Isogram methodsFor: 'queries' stamp: 'AndyMarks 12/9/2023 14:30'!isIsogramPhrase: aString 	self shouldBeImplemented.! !!Isogram methodsFor: 'queries' stamp: 'AndyMarks 12/9/2023 14:33' prior: 33659566!isIsogramPhrase: aString 	| letters |		letters := Set newFrom: aString.		^letters length == aString length.! !!Isogram methodsFor: 'queries' stamp: 'AndyMarks 12/9/2023 14:36' prior: 33659705!isIsogramPhrase: aString 	| letters |		letters := Set newFrom: aString.		^letters length == aString length.! !!Isogram methodsFor: 'queries' stamp: 'AndyMarks 12/9/2023 14:39' prior: 33659904!isIsogramPhrase: aString 	| letters |		letters := Set newFrom: aString.		^letters size == aString length.! !!Isogram methodsFor: 'queries' stamp: 'AndyMarks 12/9/2023 14:39' prior: 33660103!isIsogramPhrase: aString 	| letters |		letters := Set newFrom: aString.		^letters size == aString size.! !!Isogram methodsFor: 'queries' stamp: 'AndyMarks 12/9/2023 14:42' prior: 33660300!isIsogramPhrase: aString 	| letters |		letters := Set newFrom: (aString translateToLowercase).		^letters size == aString size.! !!Isogram methodsFor: 'queries' stamp: 'AndyMarks 12/9/2023 14:43' prior: 33660495!isIsogramPhrase: aString 	| letters |		letters := Set newFrom: aString.		^letters size == aString size.! !!Isogram methodsFor: 'queries' stamp: 'AndyMarks 12/9/2023 14:43' prior: 33660713!isIsogramPhrase: aString 	| letters |		letters := Set newFrom: aString translateToLowercase .		^letters size == aString size.! !!Isogram methodsFor: 'queries' stamp: 'AndyMarks 12/9/2023 14:44' prior: 33660908!isIsogramPhrase: aString 	| letters |		letters := Set newFrom: aString asLowercase  .		^letters size == aString size.! !!Isogram methodsFor: 'queries' stamp: 'AndyMarks 12/9/2023 14:53' prior: 33661125!isIsogramPhrase: aString 	| uniqueLetters cleanString |		cleanString := aString onlyLetters asLowercase .		uniqueLetters := Set newFrom: cleanString  .		^uniqueLetters size == cleanString size.! !!GrainsTest commentStamp: '' prior: 0!# GrainsCalculate the number of grains of wheat on a chessboard given that the numberon each square doubles.There once was a wise servant who saved the life of a prince. The kingpromised to pay whatever the servant could dream up. Knowing that theking loved chess, the servant told the king he would like to have grainsof wheat. One grain on the first square of a chess board, with the numberof grains doubling on each successive square.There are 64 squares on a chessboard (where square 1 has one grain, square 2 has two grains, and so on).Write code that shows:- how many grains were on a given square, and- the total number of grains on the chessboard## For bonus pointsDid you get the tests passing and the code clean? If you want to, theseare some additional things you could try:- Optimize for speed.- Optimize for readability.Then please share your thoughts in a comment on the submission. Did thisexperiment make the code better? Worse? Did you learn anything from it?## HintThese kinds of problems (where an answer is dependent on a previous) one are often called recursion. There are different ways to code for recursion, it might be worth reasearching if you are not familiar with this. Pharo is well optimised for recursion, and it is a commonly used pattern.Note: in the original problem specification, the grainsCalculator is called via #square, however we have renamed this method #atSquare: which is a more Smalltalk like name, that better describes that you are asking for an answer "at a square".  !!GrainsTest class methodsFor: 'config'!exercise	"Answer the configured exercise meta data for this exercise, an ExercismExercise"		^(self createExerciseAfter: IsogramTest)		isCore: true;		difficulty: 2;		topics: #('math' 'recursion');		yourself! !!GrainsTest class methodsFor: 'config'!uuid	"Answer a unique id for this exercise"	^'93dde1bb-8040-0d00-812a-052301deb008'! !!GrainsTest class methodsFor: 'config'!version	"Generated from specification: 15 March 2019"	^'1.2.0'! !!GrainsTest methodsFor: 'running'!setUp	super setUp.	grainsCalculator := Grains new! !!GrainsTest methodsFor: 'tests'!test01_ReturnsTheNumberOfGrainsOnTheSquareAt1	| result |	result := grainsCalculator atSquare: 1 .	self assert: result equals: 1! !!GrainsTest methodsFor: 'tests'!test02_ReturnsTheNumberOfGrainsOnTheSquareAt2	| result |	result := grainsCalculator atSquare: 2 .	self assert: result equals: 2! !!GrainsTest methodsFor: 'tests'!test03_ReturnsTheNumberOfGrainsOnTheSquareAt3	| result |	result := grainsCalculator atSquare: 3 .	self assert: result equals: 4! !!GrainsTest methodsFor: 'tests'!test04_ReturnsTheNumberOfGrainsOnTheSquareAt4	| result |	result := grainsCalculator atSquare: 4 .	self assert: result equals: 8! !!GrainsTest methodsFor: 'tests'!test05_ReturnsTheNumberOfGrainsOnTheSquareAt16	| result |	result := grainsCalculator atSquare: 16 .	self assert: result equals: 32768! !!GrainsTest methodsFor: 'tests'!test06_ReturnsTheNumberOfGrainsOnTheSquareAt32	| result |	result := grainsCalculator atSquare: 32 .	self assert: result equals: 2147483648! !!GrainsTest methodsFor: 'tests'!test07_ReturnsTheNumberOfGrainsOnTheSquareAt64	| result |	result := grainsCalculator atSquare: 64 .	self assert: result equals: 9223372036854775808! !!GrainsTest methodsFor: 'tests'!test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException	self		should: [grainsCalculator atSquare: 0]		raise: Error		whoseDescriptionIncludes: 'square must be between 1 and 64'		description: 'Should get an error with the correct description'.						! !!GrainsTest methodsFor: 'tests'!test09_ReturnsTheNumberOfGrainsOnTheSquareNegativeSquareRaisesAnException	self		should: [grainsCalculator atSquare: -1]		raise: Error		whoseDescriptionIncludes: 'square must be between 1 and 64'		description: 'Should get an error with the correct description'.! !!GrainsTest methodsFor: 'tests'!test10_ReturnsTheNumberOfGrainsOnTheSquareSquareGreaterThan64RaisesAnException	self		should: [grainsCalculator atSquare: 65]		raise: Error		whoseDescriptionIncludes: 'square must be between 1 and 64'		description: 'Should get an error with the correct description'.! !!GrainsTest methodsFor: 'tests'!test11_ReturnsTheTotalNumberOfGrainsOnTheBoard	| result |	result := grainsCalculator total.	self assert: result equals: 18446744073709551615! !Object subclass: #Grains	instanceVariableNames: '' 	classVariableNames: ''	package: 'Exercise@Grains'!!Grains methodsFor: 'as yet unclassified' stamp: 'AndyMarks 12/9/2023 15:02'!atSquare: aNumber	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"					^aNumber.! !!Grains methodsFor: 'accessing' stamp: 'AndyMarks 12/9/2023 15:03' prior: 33666204!atSquare: aNumber	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"					^aNumber pow: 2.! !!Grains methodsFor: 'accessing' stamp: 'AndyMarks 12/9/2023 15:08' prior: 33666425!atSquare: aNumber	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"					SmallInteger newFrom: aNumber pow: 2.	^aNumber pow: 2.! !!Grains methodsFor: 'accessing' stamp: 'AndyMarks 12/9/2023 15:08' prior: 33666653!atSquare: aNumber	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"					^aNumber pow: 2.! !!Grains methodsFor: 'accessing' stamp: 'AndyMarks 12/9/2023 15:13' prior: 33666920!atSquare: aNumber	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"					^aNumber ** 2.! !!Grains methodsFor: 'accessing' stamp: 'AndyMarks 12/9/2023 15:14' prior: 33667148!atSquare: aNumber	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"					^2 ** (aNumber - 1).! !!Grains methodsFor: 'accessing' stamp: 'AndyMarks 12/9/2023 15:15' prior: 33667374!atSquare: aNumber	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"					aNumber between: 1 and: 64	ifTrue: [ ^2 ** (aNumber - 1) ]	ifFalse: [self error ].! !!Grains methodsFor: 'accessing' stamp: 'AndyMarks 12/9/2023 15:17' prior: 33667606!atSquare: aNumber	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"					(aNumber between: 1 and: 64) 	ifTrue:  [^2 ** (aNumber - 1)]	ifFalse: [self error  ].! !!Grains methodsFor: 'accessing' stamp: 'AndyMarks 12/9/2023 15:18' prior: 33667902!atSquare: aNumber	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"					(aNumber between: 1 and: 64) 		ifTrue:  [^2 ** (aNumber - 1)]		ifFalse: [self error  ].! !!Grains methodsFor: 'accessing' stamp: 'AndyMarks 12/9/2023 15:19' prior: 33668201!atSquare: aNumber	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"					(aNumber between: 1 and: 64) 		ifTrue:  [^2 ** (aNumber - 1)]		ifFalse: [^self error  ].! !!Grains methodsFor: 'accessing' stamp: 'AndyMarks 12/9/2023 15:19' prior: 33668502!atSquare: aNumber	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"					(aNumber between: 1 and: 64) 		ifTrue:  [^2 ** (aNumber - 1)]		ifFalse: [^Error new  ].! !!Grains methodsFor: 'accessing' stamp: 'AndyMarks 12/9/2023 15:20' prior: 33668804!atSquare: aNumber	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"					(aNumber between: 1 and: 64) 		ifTrue:  [^2 ** (aNumber - 1)]		ifFalse: [^Error newFrom: 'square must be between 1 and 64' ].! !!Grains methodsFor: 'as yet unclassified' stamp: 'AndyMarks 12/9/2023 15:21'!total	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"					^0! !!Grains methodsFor: 'accessing' stamp: 'AndyMarks 12/9/2023 15:21' prior: 33669438!total	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"					^0.! !!Grains methodsFor: 'accessing' stamp: 'AndyMarks 12/9/2023 15:28' prior: 33669640!total	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"					^2 ** 128.! !!Grains methodsFor: 'accessing' stamp: 'AndyMarks 12/9/2023 15:29' prior: 33669843!total	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"					^2 ** 65.! !!Grains methodsFor: 'accessing' stamp: 'AndyMarks 12/9/2023 15:34' prior: 33670053!total	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"					^Interval from: 1 to: 64 sumNumbers: [ :square | self atSquare: square ].! !!Grains methodsFor: 'accessing' stamp: 'AndyMarks 12/9/2023 15:35' prior: 33670262!total	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"					^(Interval from: 1 to: 64) sumNumbers: [ :square | self atSquare: square ].! !!Grains methodsFor: 'accessing' stamp: 'AndyMarks 12/9/2023 15:35' prior: 33670535!total	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"					| allSquares |	allSquares := Interval from: 1 to: 64.	^allSquares sumNumbers: [ :square | self atSquare: square ].! !!Grains methodsFor: 'accessing' stamp: 'AndyMarks 12/9/2023 15:35' prior: 33670810!total	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"					| allSquares |	allSquares := Interval from: 1 to: 64.		^allSquares sumNumbers: [ :square | self atSquare: square ].! !!Grains methodsFor: 'accessing' stamp: 'AndyMarks 12/9/2023 15:37' prior: 33669105!atSquare: aNumber	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"					(aNumber between: 1 and: 64) 		ifTrue:  [^2 ** (aNumber - 1)]		ifFalse: [^self error: 'square must be between 1 and 64' ].! !!Grains methodsFor: 'accessing' stamp: 'AndyMarks 12/9/2023 15:37' prior: 33671444!atSquare: aNumber	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"					(aNumber between: 1 and: 64) 		ifTrue:  [^2 ** (aNumber - 1)]		ifFalse: [self error: 'square must be between 1 and 64' ].! !!AllergiesTest commentStamp: '' prior: 0!# AllergiesGiven a person's allergy score, determine whether or not they're allergic to a given item, and their full list of allergies.An allergy test produces a single numeric score which contains theinformation about all the allergies the person has (that they weretested for).The list of items (and their value) that were tested are:* eggs (1)* peanuts (2)* shellfish (4)* strawberries (8)* tomatoes (16)* chocolate (32)* pollen (64)* cats (128)So if Tom is allergic to peanuts and chocolate, he gets a score of 34.Now, given just that score of 34, your program should be able to say:- Whether Tom is allergic to any one of those allergens listed above.- All the allergens Tom is allergic to.Note: a given score may include allergens **not** listed above (i.e.allergens that score 256, 512, 1024, etc.).  Your program shouldignore those components of the score.  For example, if the allergyscore is 257, your program should only report the eggs (1) allergy.## HintNotice how each of the items is a power of 2, a property that you should be able to leverage.!!AllergiesTest class methodsFor: 'config'!exercise	"Answer the configured exercise meta data for this exercise, an ExercismExercise"	^(self createExerciseAfter: GrainsTest)		isCore: true;		difficulty: 3;		topics: #('bitwise_operations' 'filtering');		yourself! !!AllergiesTest class methodsFor: 'generator'!generator	"Potential generator hints"		^ {('@allergicToItem:score:' -> #allergicToItem:forScore:).	('@listScore:' -> #'allergyListForScore:')}! !!AllergiesTest class methodsFor: 'config'!uuid	"Answer a unique id for this exercise"	^'49ae8e78-a641-0d00-ba20-5f9f04641ab1'! !!AllergiesTest class methodsFor: 'config'!version	"Generated from specification: 1 April 2019"	^'1.2.1'! !!AllergiesTest methodsFor: 'running'!setUp	super setUp.	allergiesCalculator := Allergies new! !!AllergiesTest methodsFor: 'tests'!test01_NoAllergiesMeansNotAllergicToPeanuts	| result |	result := allergiesCalculator allergicToItem: 'peanuts' forScore: 0 .	self assert: result equals: false! !!AllergiesTest methodsFor: 'tests'!test02_NoAllergiesMeansNotAllergicToCats	| result |	result := allergiesCalculator allergicToItem: 'cats' forScore: 0 .	self assert: result equals: false! !!AllergiesTest methodsFor: 'tests'!test03_NoAllergiesMeansNotAllergicToStrawberries	| result |	result := allergiesCalculator allergicToItem: 'strawberries' forScore: 0 .	self assert: result equals: false! !!AllergiesTest methodsFor: 'tests'!test04_AllergicToOnlyEggs	| result |	result := allergiesCalculator allergicToItem: 'eggs' forScore: 1 .	self assert: result equals: true! !!AllergiesTest methodsFor: 'tests'!test05_AllergicToEggsInAdditionToOtherStuffLikeEggsRepeated	| result |	result := allergiesCalculator allergicToItem: 'eggs' forScore: 5 .	self assert: result equals: true! !!AllergiesTest methodsFor: 'tests'!test06_AllergicToEggsInAdditionToOtherStuffLikeShellfish	| result |	result := allergiesCalculator allergicToItem: 'shellfish' forScore: 5 .	self assert: result equals: true! !!AllergiesTest methodsFor: 'tests'!test07_AllergicToEggsInAdditionToOtherStuffLikeStrawberries	| result |	result := allergiesCalculator allergicToItem: 'strawberries' forScore: 5 .	self assert: result equals: false! !!AllergiesTest methodsFor: 'tests'!test08_AllergicToStrawberriesButNotPeanuts	| result |	result := allergiesCalculator allergicToItem: 'peanuts' forScore: 9 .	self assert: result equals: false! !!AllergiesTest methodsFor: 'tests'!test09_AllergicToStrawberriesButNotShellfish	| result |	result := allergiesCalculator allergicToItem: 'shellfish' forScore: 9 .	self assert: result equals: false! !!AllergiesTest methodsFor: 'tests'!test10_AllergicToStrawberriesAndAlsoEggs	| result |	result := allergiesCalculator allergicToItem: 'eggs' forScore: 9 .	self assert: result equals: true! !!AllergiesTest methodsFor: 'tests'!test11_AllergicToStrawberriesAndAlsoStrawberriesRepeated	| result |	result := allergiesCalculator allergicToItem: 'strawberries' forScore: 9 .	self assert: result equals: true! !!AllergiesTest methodsFor: 'tests'!test12_ListWhenNoAllergies	| result |	result := allergiesCalculator allergyListForScore: 0 .	self assert: result equals: #()! !!AllergiesTest methodsFor: 'tests'!test13_ListWhenJustEggs	| result |	result := allergiesCalculator allergyListForScore: 1 .	self assert: result equals: #('eggs' )! !!AllergiesTest methodsFor: 'tests'!test14_ListWhenJustPeanuts	| result |	result := allergiesCalculator allergyListForScore: 2 .	self assert: result equals: #('peanuts' )! !!AllergiesTest methodsFor: 'tests'!test15_ListWhenJustStrawberries	| result |	result := allergiesCalculator allergyListForScore: 8 .	self assert: result equals: #('strawberries' )! !!AllergiesTest methodsFor: 'tests'!test16_ListWhenEggsAndPeanuts	| result |	result := allergiesCalculator allergyListForScore: 3 .	self assert: result equals: #('eggs' 'peanuts' )! !!AllergiesTest methodsFor: 'tests'!test17_ListWhenMoreThanEggsButNotPeanuts	| result |	result := allergiesCalculator allergyListForScore: 5 .	self assert: result equals: #('eggs' 'shellfish' )! !!AllergiesTest methodsFor: 'tests'!test18_ListWhenLotsOfStuff	| result |	result := allergiesCalculator allergyListForScore: 248 .	self assert: result equals: #('strawberries' 'tomatoes' 'chocolate' 'pollen' 'cats' )! !!AllergiesTest methodsFor: 'tests'!test19_ListWhenEverything	| result |	result := allergiesCalculator allergyListForScore: 255 .	self assert: result equals: #('eggs' 'peanuts' 'shellfish' 'strawberries' 'tomatoes' 'chocolate' 'pollen' 'cats' )! !!AllergiesTest methodsFor: 'tests'!test20_ListWhenNoAllergenScoreParts	| result |	result := allergiesCalculator allergyListForScore: 509 .	self assert: result equals: #('eggs' 'shellfish' 'strawberries' 'tomatoes' 'chocolate' 'pollen' 'cats' )! !Object subclass: #Allergies	instanceVariableNames: '' 	classVariableNames: ''	package: ''!!Allergies methodsFor: 'queries' stamp: 'AndyMarks 12/10/2023 08:44'!allergicToItem: aString forScore: anInteger 	self shouldBeImplemented.! !!Allergies methodsFor: 'queries' stamp: 'AndyMarks 12/10/2023 08:45' prior: 33678229!allergicToItem: aString forScore: anInteger 	^False.! !!Allergies methodsFor: 'queries' stamp: 'AndyMarks 12/10/2023 08:46' prior: 33678390!allergicToItem: aString forScore: anInteger 	^false.! !!Allergies methodsFor: 'querying' stamp: 'AndyMarks 12/10/2023 08:46'!allergyListForScore: anInteger 	self shouldBeImplemented.! !!Allergies methodsFor: 'querying' stamp: 'AndyMarks 12/10/2023 08:47' prior: 33678661!allergyListForScore: anInteger 	^#().! !!Allergies methodsFor: 'queries' stamp: 'AndyMarks 12/10/2023 08:50' prior: 33678533!allergicToItem: anAllergy forScore: aScore 	^aScore anyMask: 2.! !!Allergies methodsFor: 'queries' stamp: 'AndyMarks 12/10/2023 08:51' prior: 33678938!allergicToItem: anAllergy forScore: aScore 	^aScore anyMask: 1.! !!Allergies methodsFor: 'queries' stamp: 'AndyMarks 12/10/2023 08:54' prior: 33679092!allergicToItem: anAllergy forScore: aScore 	| allergies |		allergies := SmallDictionary newFromKeys: #('eggs' 'peanuts' 'shellfish' 'strawberries' 'tomatoes' 'chocolate' 'pollen' 'cats') andValues: #(1 2 4 8 16 32 64 128).		^aScore anyMask: 1.! !!Allergies methodsFor: 'queries' stamp: 'AndyMarks 12/10/2023 08:55' prior: 33679246!allergicToItem: anAllergy forScore: aScore 	| allergies |		allergies := SmallDictionary newFromKeys: #('eggs' 'peanuts' 'shellfish' 'strawberries' 'tomatoes' 'chocolate' 'pollen' 'cats') andValues: #(1 2 4 8 16 32 64 128).		^aScore anyMask: (allergies at: anAllergy).! !!Allergies methodsFor: 'querying' stamp: 'AndyMarks 12/10/2023 08:58' prior: 33678810!allergyListForScore: anInteger 	| allergyList |		allergyList := #().	^allergyList .! !!Allergies methodsFor: 'querying' stamp: 'AndyMarks 12/10/2023 09:01' prior: 33679947!allergyListForScore: anInteger 	| allergyList allergies |		allergies := SmallDictionary newFromKeys: #('eggs' 'peanuts' 'shellfish' 'strawberries' 'tomatoes' 'chocolate' 'pollen' 'cats') andValues: #(1 2 4 8 16 32 64 128).		allergyList := #().	^allergyList .! !!Allergies methodsFor: 'querying' stamp: 'AndyMarks 12/10/2023 09:02' prior: 33680125!allergyListForScore: anInteger 	| allergyList allergies |		allergies := SmallDictionary newFromKeys: #(1 2 4 8 16 32 64 128) andValues: #('eggs' 'peanuts' 'shellfish' 'strawberries' 'tomatoes' 'chocolate' 'pollen' 'cats') .		allergyList := #().	^allergyList .! !!Allergies methodsFor: 'querying' stamp: 'AndyMarks 12/10/2023 09:06' prior: 33680481!allergyListForScore: aScore	| allergyList allergies |		allergies := SmallDictionary newFromKeys: #(1 2 4 8 16 32 64 128) andValues: #('eggs' 'peanuts' 'shellfish' 'strawberries' 'tomatoes' 'chocolate' 'pollen' 'cats') .	allergyList := #().	allergies keysAndValuesDo: [ :value :allergy | 		aScore anyMask: value		ifTrue: [ allergyList put allergy]		].	^allergyList .! !!Allergies methodsFor: 'querying' stamp: 'AndyMarks 12/10/2023 09:07' prior: 33680837!allergyListForScore: aScore	| allergyList allergies |		allergies := SmallDictionary newFromKeys: #(1 2 4 8 16 32 64 128) andValues: #('eggs' 'peanuts' 'shellfish' 'strawberries' 'tomatoes' 'chocolate' 'pollen' 'cats') .	allergyList := #().	allergies keysAndValuesDo: [ :value :allergy | 		aScore anyMask: value			ifTrue: [ allergyList put allergy ]		].	^allergyList .! !!Allergies methodsFor: 'querying' stamp: 'AndyMarks 12/10/2023 09:07' prior: 33681302!allergyListForScore: aScore	| allergyList allergies |		allergies := SmallDictionary newFromKeys: #(1 2 4 8 16 32 64 128) andValues: #('eggs' 'peanuts' 'shellfish' 'strawberries' 'tomatoes' 'chocolate' 'pollen' 'cats') .	allergyList := #().	allergies keysAndValuesDo: [ :value :allergy | 		(aScore anyMask: value)			ifTrue: [ allergyList put allergy ]		].	^allergyList .! !!Allergies methodsFor: 'querying' stamp: 'AndyMarks 12/10/2023 09:08' prior: 33681769!allergyListForScore: aScore	| allergyList allergies |		allergies := SmallDictionary newFromKeys: #(1 2 4 8 16 32 64 128) andValues: #('eggs' 'peanuts' 'shellfish' 'strawberries' 'tomatoes' 'chocolate' 'pollen' 'cats') .	allergyList := #().	allergies keysAndValuesDo: [ :value :allergy | 		(aScore anyMask: value)			ifTrue: [ allergyList put allergy ]		].		^allergyList .! !!Allergies methodsFor: 'querying' stamp: 'AndyMarks 12/10/2023 09:10' prior: 33682238!allergyListForScore: aScore	| allergyList allergies |		allergies := SmallDictionary newFromKeys: #(1 2 4 8 16 32 64 128) andValues: #('eggs' 'peanuts' 'shellfish' 'strawberries' 'tomatoes' 'chocolate' 'pollen' 'cats') .	allergyList := #().	allergies keysAndValuesDo: [ :value :allergy | 		(aScore anyMask: value)			ifTrue: [ allergyList put allergy ].		].		^allergyList .! !!Allergies methodsFor: 'querying' stamp: 'AndyMarks 12/10/2023 09:10' prior: 33682709!allergyListForScore: aScore	| allergyList allergies |		allergies := SmallDictionary newFromKeys: #(1 2 4 8 16 32 64 128) andValues: #('eggs' 'peanuts' 'shellfish' 'strawberries' 'tomatoes' 'chocolate' 'pollen' 'cats') .	allergyList := #().	allergies keysAndValuesDo: [ :value :allergy | 		(aScore anyMask: value)			ifTrue: [ allergyList add: allergy ].		].		^allergyList .! !!Allergies methodsFor: 'querying' stamp: 'AndyMarks 12/10/2023 09:11' prior: 33683181!allergyListForScore: aScore	| allergyList allergies |		allergies := SmallDictionary newFromKeys: #(1 2 4 8 16 32 64 128) andValues: #('eggs' 'peanuts' 'shellfish' 'strawberries' 'tomatoes' 'chocolate' 'pollen' 'cats') .	allergyList := #().	allergies keysAndValuesDo: [ :value :allergy | 		(aScore anyMask: value)			ifTrue: [ allergyList put: allergy ].		].		^allergyList .! !!Allergies methodsFor: 'querying' stamp: 'AndyMarks 12/10/2023 09:15' prior: 33683654!allergyListForScore: aScore	| allergyList allergies |		allergies := SmallDictionary newFromKeys: #(1 2 4 8 16 32 64 128) andValues: #('eggs' 'peanuts' 'shellfish' 'strawberries' 'tomatoes' 'chocolate' 'pollen' 'cats') .	allergyList := #().	allergies keysAndValuesDo: [ :value :allergy | 		(aScore anyMask: value)			ifTrue: [ allergyList appendTo: allergy ].		].		^allergyList .! !!Allergies methodsFor: 'querying' stamp: 'AndyMarks 12/10/2023 09:17' prior: 33684127!allergyListForScore: aScore	| allergyList allergies |		allergies := SmallDictionary newFromKeys: #(1 2 4 8 16 32 64 128) andValues: #('eggs' 'peanuts' 'shellfish' 'strawberries' 'tomatoes' 'chocolate' 'pollen' 'cats') .	allergyList := OrderedCollection new.	allergies keysAndValuesDo: [ :value :allergy | 		(aScore anyMask: value)			ifTrue: [ allergyList add: allergy ].		].		^allergyList .! !!Allergies methodsFor: 'querying' stamp: 'AndyMarks 12/10/2023 09:17' prior: 33684605!allergyListForScore: aScore	| allergyList allergies |		allergies := SmallDictionary newFromKeys: #(1 2 4 8 16 32 64 128) andValues: #('eggs' 'peanuts' 'shellfish' 'strawberries' 'tomatoes' 'chocolate' 'pollen' 'cats') .	allergyList := OrderedCollection new.	allergies keysAndValuesDo: [ :value :allergy | 		(aScore anyMask: value)			ifTrue: [ allergyList add: allergy ].		].		^allergyList asArray  .! !----QUIT/NOSAVE----2023-12-16T07:59:14.955436+11:00 Pharo.image priorSource: 99!----QUIT/NOSAVE----2023-12-16T07:59:47.177615+11:00 Pharo.image priorSource: 99!!BaselineOfExercism commentStamp: '' prior: 0!Project baseline to load entire Exercism Pharo track, including all its dependencies!!BaselineOfExercism class methodsFor: 'baselines' stamp: 'AndyMarks 12/16/2023 08:09'!exerciseGoldenTestPackageNames	"Answer the list of exercise package names used for golden tests executed by Exercism's test runner"	^ #('Exercise@ExampleAllFail' 'Exercise@ExampleAllPass' 'Exercise@ExampleAllRaiseError' 'Exercise@ExampleEmptySolutionClass' 'Exercise@ExampleEmptySolutionFile' 'Exercise@ExampleErrorFailPass' 'Exercise@ExampleExtensionMethod' 'Exercise@ExampleSyntaxError' 'Exercise@ExampleTypoInMethodName')! !!BaselineOfExercism class methodsFor: 'baselines' stamp: 'AndyMarks 12/16/2023 08:09'!exercisePackageNames	"Answer the list of exercise package names (as we don't yet have proper projects)"	^ #('Exercise@Acronym' 'Exercise@Allergies' 'Exercise@Anagram' 'Exercise@ArmstrongNumbers' 'Exercise@AtbashCipher' 'Exercise@Binary' 'Exercise@BinarySearchTree' 'Exercise@Bowling' 'Exercise@CircularBuffer' 'Exercise@Clock' 'Exercise@CollatzConjecture' 'Exercise@Darts' 'Exercise@Diamond' 'Exercise@Die' 'Exercise@Etl' 'Exercise@FlattenArray' 'Exercise@Forth' 'Exercise@GradeSchool' 'Exercise@Grains' 'Exercise@Hamming' 'Exercise@HelloWorld' 'Exercise@HighScores' 'Exercise@IsbnVerifier' 'Exercise@Isogram' 'Exercise@Leap' 'Exercise@Luhn' 'Exercise@MatchingBrackets' 'Exercise@Matrix' 'Exercise@Minesweeper' 'Exercise@Pangram' 'Exercise@Proverb' 'Exercise@Raindrops' 'Exercise@ResistorColorDuo' 'Exercise@ReverseString' 'Exercise@RobotSimulator' 'Exercise@RomanNumerals' 'Exercise@SecretHandshake' 'Exercise@Sieve' 'Exercise@SimpleCipher' 'Exercise@SpaceAge' 'Exercise@SumOfMultiples' 'Exercise@Tournament' 'Exercise@TwelveDays' 'Exercise@TwoFer' 'Exercise@Welcome' 'Exercise@WordCount')! !!BaselineOfExercism class methodsFor: 'baselines' stamp: 'AndyMarks 12/16/2023 08:09'!exerciseTestPackageNames	"Answer the list of exercise package names used for testing (as we don't yet have proper projects)"	^ #('ExercismTests-ExerciseEmpty' 'ExercismTests-ExerciseMany' 'ExercismTests-ExerciseNormal' 'ExercismTests-ExerciseExtension')! !!BaselineOfExercism methodsFor: 'baselines' stamp: 'AndyMarks 12/16/2023 08:09'!baseline: spec	<baseline>	spec		for: #common		do: [ self setExercismLogo.			self setUpDependencies: spec.			self setUpExercisesFor: spec.			self setUpGoldenTestsFor: spec.			spec				package: 'ExercismTools';				package: 'ExercismMocking' with: [ spec requires: #('Mocketry') ];				package: 'ExercismTests'					with: [ spec						requires:							#('ExercismTools' 'ExercismMocking')								, self class exerciseTestPackageNames ];				package: 'ExercismSystemTests'					with: [ spec requires: #('ExercismTests') ];				package: 'ExercismWIP'					with: [ spec requires: #('ExercismTools') ];				package: 'ExercismDev'					with: [ spec						requires:							#('ExercismTools' 'OSSubprocess' 'OSWinSubprocess')								, self class exercisePackageNames	"For shelling out to configlet" ];				package: 'ExercismTestRunner'					with:						[ spec requires: #('ExercismTools') , self class exercisePackageNames ];				package: 'ExercismTestRunnerTests'					with: [ spec requires: #('ExercismTestRunner' 'ExercismTests') ];				package: 'ExercismV3';				group: 'default' with: #('ExercismTools' 'Exercise@Welcome');				group: 'mentor' with: #('ExercismDev');				group: 'dev'					with: #('ExercismDev' 'ExercismWIP' 'ExercismSystemTests');				group: 'testRunner' with: #('ExercismTestRunner');				group: 'testRunnerTests' with: #('ExercismTestRunnerTests'), self class exerciseGoldenTestPackageNames;				group: 'v3' with: #('ExercismV3')			].			spec for: #'pharo9.x' do: [ 				spec package: 'ExercismTools' with: [ spec includes: #('ExercismPharo90') ].				spec package: 'ExercismPharo90' ].			spec for: #'pharo11.x' do: [				"ExercismTools must be loaded prior compatibilty package, to overwrite original class definition of ExTonelWriter"				spec package: 'ExercismTools' with: [ spec includes: #('ExercismPharo110') ].				spec package: 'ExercismPharo110' with: [ spec requires: 'ExercismTools' ]			]		! !!BaselineOfExercism methodsFor: 'baselines' stamp: 'AndyMarks 12/16/2023 08:10'!projectClass	^ MetacelloCypressBaselineProject! !!BaselineOfExercism methodsFor: 'baselines' stamp: 'AndyMarks 12/16/2023 08:10'!setExercismLogo	| exercismLogo |	exercismLogo := (AlphaImageMorph		withForm:		(ZnEasy		getPng:			'https://user-images.githubusercontent.com/38899847/48952150-634e9b80-eefe-11e8-890e-7a233d56df65.png'))		layout: #scaledAspect;		extent: 100 @ 100;		position: 10 @ 135;		lock.	World addMorph: exercismLogo! !!BaselineOfExercism methodsFor: 'baselines' stamp: 'AndyMarks 12/16/2023 08:10'!setUpDependencies: spec	spec 		baseline: 'OSSubprocess' 		with: [spec repository: 'github://pharo-contributions/OSSubprocess:master/repository'].		spec 		baseline: 'OSWinSubprocess' 		with: [spec repository: 'github://pharo-contributions/OSWinSubprocess:master/repository'].						spec    	baseline: 'Mocketry'    	with: [ spec repository: 'github://dionisiydk/Mocketry:v6.0.x' ].		spec    	baseline: 'Ring2'    	with: [ spec repository: 'github://pavel-krivanek/Ring2'; loads: #(calypso)].! !!BaselineOfExercism methodsFor: 'baselines' stamp: 'AndyMarks 12/16/2023 08:10'!setUpExercisesFor: spec	self class exercisePackageNames, self class exerciseTestPackageNames 		do:			[ :name | spec package: name with: [ spec requires: #('ExercismTools') ] ]! !!BaselineOfExercism methodsFor: 'baselines' stamp: 'AndyMarks 12/16/2023 08:10'!setUpGoldenTestsFor: spec		self class exerciseGoldenTestPackageNames 		do:			[ :name | spec package: name with: [ spec requires: #('ExercismTools') ] ]! !!TExercise commentStamp: '' prior: 0!# TExerciseI am a trait containing methods for getting exercise meta data fromobjects that play the role of a Exercism version 3 exercise.## UsageMy methods reference instance variables and methods that must be implemented by objects that use me. ## Instance Variables These will need to be initialized in the using classes `#initialize` method.- solutionId - customData: An `Array`. This can be safely initialized empty.- isActive: A `Boolean`. Is the exercise active (not depricated or for testing).- isCustom: A `Boolean`. `true` if `customData` is not empty.- uuid: A `String`. The exercises unique ID in the Execism project.- version- aliasesAndHints: An `Array`. This can be safely initialized empty.## Methods### `#configuredExerciseMetadata`Must answer the configured exercise meta data for this exercise, an `ExercismExercise`.!!ExercismTest commentStamp: '' prior: 0!I am the root of Exercism test examples but also provide a hook to specify some simple exercise metadata that can be used to generate the exercism config.json file (used by the platform to unlock exercises for users as they progress).!!ExercismHintTwoFerReuseRule commentStamp: '' prior: 0!The TwoFer exercise introduces you to calling between methods.For practice, your '#who'  method should reuse your  '#who:'  method. !!ExercismError commentStamp: '' prior: 0!I am a hierarchy of Exercism errors, so its east to catch them!!ExUnauthorized commentStamp: '' prior: 0!I am an authorisation error for Exercism!!ExTonelWriter commentStamp: '' prior: 0!I am a TonelWriter that provides finer level control of writing Tonel files for Exercism!!StaticTextMorph commentStamp: '' prior: 0!Provide a non editable text morph suitable for hosting a clickable URL!!ExercismExercise commentStamp: '' prior: 0!I am the meta data for an exercise, and am typically created from the #excerise method on any of the specified ExercismTest tests (which are a type of SUnit test).Of note is that the exercise submission id is stored as a class instance variable on ExercismTest.!!MockExercismExercise commentStamp: '' prior: 0!# MockExercismExerciseI am a subclass of `ExercismExercise` exclusively for use in testing. I override `#allExercises`to return a small number of exercises instead of all the exercises in production,which can grow in number. This is to help keep tests fast and predictable.## Overridden Methods### `#allExercises`Answers a small constant number of exercises.!!ExercismHttpClient commentStamp: '' prior: 0!I am a wrapper over a ZnClient to streamline the HTTP interactions with exercism, and to also make it re-testable.!!ExercismHttpCommand commentStamp: '' prior: 0!I am the root of Http commands that will use a (now) seperate httpClient object to fetch/put solution data!!ExercismDownloadCommand commentStamp: '' prior: 0!I am the command for dowloading an exercise and installing it in the image!!ExercismSubmitCommand commentStamp: '' prior: 0!I am a command for submitting an exercise. !!ExercismManager commentStamp: '' prior: 0!I am  responsible for managing the interaction with the lower level Exercism command line tool.!!ExercismSubmission commentStamp: '' prior: 0!I am a wrapper over the exercism json submission data. Crucially I have a solutionId that is needed when submitting exercises that have been downloaded.!